ClassDef:env_manager
	CompoundStatement:
		IdentifierDeclStatement:null
			IdentifierDecl:init (bool can_restore, bool debug)
				IdentifierDeclType:void ( bool can_restore , bool debug )
				Identifier:init
		IdentifierDeclStatement:null
			IdentifierDecl:*get (const char *name)
				IdentifierDeclType:const char * ( const char * name )
				Identifier:get
		IdentifierDeclStatement:null
			IdentifierDecl:xput (const char *string)
				IdentifierDeclType:void ( const char * string )
				Identifier:xput
		IdentifierDeclStatement:null
			IdentifierDecl:restore ()
				IdentifierDeclType:void ( )
				Identifier:restore
		IdentifierDeclStatement:null
			IdentifierDecl:m_can_restore
				IdentifierDeclType:bool
				Identifier:m_can_restore
		IdentifierDeclStatement:null
			IdentifierDecl:m_debug
				IdentifierDeclType:bool
				Identifier:m_debug
		ClassDef:kv
			CompoundStatement:
				IdentifierDeclStatement:null
					IdentifierDecl:*m_key
						IdentifierDeclType:char *
						Identifier:m_key
				IdentifierDeclStatement:null
					IdentifierDecl:*m_value
						IdentifierDeclType:char *
						Identifier:m_value
		IdentifierDeclStatement:null
			IdentifierDecl:m_keys
				IdentifierDeclType:vec < kv >
				Identifier:m_keys
IdentifierDeclStatement:null
	IdentifierDecl:env
		IdentifierDeclType:env_manager
		Identifier:env
FunctionDef:voidenv_manager::init (bool can_restore , bool debug)
	CompoundStatement:
		ExpressionStatement:m_can_restore = can_restore
			AssignmentExpression:m_can_restore = can_restore
				Identifier:m_can_restore
				Identifier:can_restore
		ExpressionStatement:m_debug = debug
			AssignmentExpression:m_debug = debug
				Identifier:m_debug
				Identifier:debug
	Identifier:voidenv_manager::init
	ParameterList:bool can_restore , bool debug
		Parameter:bool can_restore
			ParameterType:bool
			Identifier:can_restore
		Parameter:bool debug
			ParameterType:bool
			Identifier:debug
FunctionDef:env_manager::get (const char *name)
	CompoundStatement:
		ExpressionStatement:getenv (name)
			CallExpression:getenv (name)
				Callee:getenv
					Identifier:getenv
				ArgumentList:name
					Argument:name
						Identifier:name
		IfStatement:if (m_debug)
			Condition:m_debug
				Identifier:m_debug
			ExpressionStatement:fprintf (stderr, "env_manager::getenv (%s) -> %s\n", name, result)
				CallExpression:fprintf (stderr, "env_manager::getenv (%s) -> %s\n", name, result)
					Callee:fprintf
						Identifier:fprintf
					ArgumentList:stderr
						Argument:stderr
							Identifier:stderr
						Argument:"env_manager::getenv (%s) -> %s\n"
							Constant:"env_manager::getenv (%s) -> %s\n"
						Argument:name
							Identifier:name
						Argument:result
							Identifier:result
		ReturnStatement:return result;
			Identifier:result
	ReturnType:const char *
	Identifier:env_manager::get
	ParameterList:const char *name
		Parameter:const char *name
			ParameterType:const char *
			Identifier:name
FunctionDef:voidenv_manager::xput (const char *string)
	CompoundStatement:
		IfStatement:if (m_debug)
			Condition:m_debug
				Identifier:m_debug
			ExpressionStatement:fprintf (stderr, "env_manager::xput (%s)\n", string)
				CallExpression:fprintf (stderr, "env_manager::xput (%s)\n", string)
					Callee:fprintf
						Identifier:fprintf
					ArgumentList:stderr
						Argument:stderr
							Identifier:stderr
						Argument:"env_manager::xput (%s)\n"
							Constant:"env_manager::xput (%s)\n"
						Argument:string
							Identifier:string
		IfStatement:if (verbose_flag)
			Condition:verbose_flag
				Identifier:verbose_flag
			ExpressionStatement:fnotice (stderr, "%s\n", string)
				CallExpression:fnotice (stderr, "%s\n", string)
					Callee:fnotice
						Identifier:fnotice
					ArgumentList:stderr
						Argument:stderr
							Identifier:stderr
						Argument:"%s\n"
							Constant:"%s\n"
						Argument:string
							Identifier:string
		IfStatement:if (m_can_restore)
			Condition:m_can_restore
				Identifier:m_can_restore
			CompoundStatement:
				Statement:char
				Statement:*
				Statement:equals
				Statement:=
				Statement:strchr
				Statement:(
				Statement:const_cast
				Statement:<
				Statement:char
				Statement:*
				Statement:>
				Statement:(
				Statement:string
				Statement:)
				Statement:,
				Statement:'='
				Statement:)
				ExpressionStatement:
				ExpressionStatement:gcc_assert (equals)
					CallExpression:gcc_assert (equals)
						Callee:gcc_assert
							Identifier:gcc_assert
						ArgumentList:equals
							Argument:equals
								Identifier:equals
				IdentifierDeclStatement:struct kv kv;
					IdentifierDecl:kv
						IdentifierDeclType:struct kv
						Identifier:kv
				ExpressionStatement:kv.m_key = xstrndup (string, equals - string)
					AssignmentExpression:kv.m_key = xstrndup (string, equals - string)
						MemberAccess:kv.m_key
							Identifier:kv
							Identifier:m_key
						CallExpression:xstrndup (string, equals - string)
							Callee:xstrndup
								Identifier:xstrndup
							ArgumentList:string
								Argument:string
									Identifier:string
								Argument:equals - string
									AdditiveExpression:equals - string
										Identifier:equals
										Identifier:string
				Statement:const
				Statement:char
				Statement:*
				Statement:cur_value
				Statement:=
				Statement:::
				ExpressionStatement:getenv (kv.m_key)
					CallExpression:getenv (kv.m_key)
						Callee:getenv
							Identifier:getenv
						ArgumentList:kv.m_key
							Argument:kv.m_key
								MemberAccess:kv.m_key
									Identifier:kv
									Identifier:m_key
				IfStatement:if (m_debug)
					Condition:m_debug
						Identifier:m_debug
					ExpressionStatement:fprintf (stderr, "saving old value: %s\n",cur_value)
						CallExpression:fprintf (stderr, "saving old value: %s\n",cur_value)
							Callee:fprintf
								Identifier:fprintf
							ArgumentList:stderr
								Argument:stderr
									Identifier:stderr
								Argument:"saving old value: %s\n"
									Constant:"saving old value: %s\n"
								Argument:cur_value
									Identifier:cur_value
				ExpressionStatement:kv.m_value = cur_value ? xstrdup (cur_value) : NULL
					AssignmentExpression:kv.m_value = cur_value ? xstrdup (cur_value) : NULL
						MemberAccess:kv.m_value
							Identifier:kv
							Identifier:m_value
						ConditionalExpression:cur_value ? xstrdup (cur_value) : NULL
							Condition:cur_value
								Identifier:cur_value
							CallExpression:xstrdup (cur_value)
								Callee:xstrdup
									Identifier:xstrdup
								ArgumentList:cur_value
									Argument:cur_value
										Identifier:cur_value
							Identifier:NULL
				ExpressionStatement:m_keys.safe_push (kv)
					CallExpression:m_keys.safe_push (kv)
						Callee:m_keys.safe_push
							MemberAccess:m_keys.safe_push
								Identifier:m_keys
								Identifier:safe_push
						ArgumentList:kv
							Argument:kv
								Identifier:kv
		Statement:::
		Statement:putenv
		Statement:(
		Statement:CONST_CAST
		Statement:(
		Statement:char
		Statement:*
		Statement:,
		Statement:string
		Statement:)
		Statement:)
		ExpressionStatement:
	Identifier:voidenv_manager::xput
	ParameterList:const char *string
		Parameter:const char *string
			ParameterType:const char *
			Identifier:string
FunctionDef:voidenv_manager::restore ()
	CompoundStatement:
		IdentifierDeclStatement:unsigned int i;
			IdentifierDecl:i
				IdentifierDeclType:unsigned int
				Identifier:i
		IdentifierDeclStatement:struct kv *item;
			IdentifierDecl:*item
				IdentifierDeclType:struct kv *
				Identifier:item
		ExpressionStatement:gcc_assert (m_can_restore)
			CallExpression:gcc_assert (m_can_restore)
				Callee:gcc_assert
					Identifier:gcc_assert
				ArgumentList:m_can_restore
					Argument:m_can_restore
						Identifier:m_can_restore
		Statement:FOR_EACH_VEC_ELT_REVERSE
		Statement:(
		Statement:m_keys
		Statement:,
		Statement:i
		Statement:,
		Statement:item
		Statement:)
		CompoundStatement:
			IfStatement:if (m_debug)
				Condition:m_debug
					Identifier:m_debug
				ExpressionStatement:printf ("restoring saved key: %s value: %s\n", item->m_key, item->m_value)
					CallExpression:printf ("restoring saved key: %s value: %s\n", item->m_key, item->m_value)
						Callee:printf
							Identifier:printf
						ArgumentList:"restoring saved key: %s value: %s\n"
							Argument:"restoring saved key: %s value: %s\n"
								Constant:"restoring saved key: %s value: %s\n"
							Argument:item->m_key
								PtrMemberAccess:item->m_key
									Identifier:item
									Identifier:m_key
							Argument:item->m_value
								PtrMemberAccess:item->m_value
									Identifier:item
									Identifier:m_value
			IfStatement:if (item->m_value)
				Condition:item->m_value
					PtrMemberAccess:item->m_value
						Identifier:item
						Identifier:m_value
				Statement:::
			ExpressionStatement:setenv (item->m_key, item->m_value, 1)
				CallExpression:setenv (item->m_key, item->m_value, 1)
					Callee:setenv
						Identifier:setenv
					ArgumentList:item->m_key
						Argument:item->m_key
							PtrMemberAccess:item->m_key
								Identifier:item
								Identifier:m_key
						Argument:item->m_value
							PtrMemberAccess:item->m_value
								Identifier:item
								Identifier:m_value
						Argument:1
							Constant:1
			ExpressionStatement:unsetenv (item->m_key)
				CallExpression:unsetenv (item->m_key)
					Callee:unsetenv
						Identifier:unsetenv
					ArgumentList:item->m_key
						Argument:item->m_key
							PtrMemberAccess:item->m_key
								Identifier:item
								Identifier:m_key
			ExpressionStatement:free (item->m_key)
				CallExpression:free (item->m_key)
					Callee:free
						Identifier:free
					ArgumentList:item->m_key
						Argument:item->m_key
							PtrMemberAccess:item->m_key
								Identifier:item
								Identifier:m_key
			ExpressionStatement:free (item->m_value)
				CallExpression:free (item->m_value)
					Callee:free
						Identifier:free
					ArgumentList:item->m_value
						Argument:item->m_value
							PtrMemberAccess:item->m_value
								Identifier:item
								Identifier:m_value
		ExpressionStatement:m_keys.truncate (0)
			CallExpression:m_keys.truncate (0)
				Callee:m_keys.truncate
					MemberAccess:m_keys.truncate
						Identifier:m_keys
						Identifier:truncate
				ArgumentList:0
					Argument:0
						Constant:0
	Identifier:voidenv_manager::restore
	ParameterList:
IdentifierDeclStatement:null
	IdentifierDecl:dir_separator_str[]
		IdentifierDeclType:const char [ ]
		Identifier:dir_separator_str
IdentifierDeclStatement:null
	IdentifierDecl:is_cpp_driver
		IdentifierDeclType:int
		Identifier:is_cpp_driver
IdentifierDeclStatement:null
	IdentifierDecl:at_file_supplied
		IdentifierDeclType:bool
		Identifier:at_file_supplied
IdentifierDeclStatement:null
	IdentifierDecl:print_help_list
		IdentifierDeclType:int
		Identifier:print_help_list
IdentifierDeclStatement:null
	IdentifierDecl:print_version
		IdentifierDeclType:int
		Identifier:print_version
IdentifierDeclStatement:null
	IdentifierDecl:verbose_only_flag
		IdentifierDeclType:int
		Identifier:verbose_only_flag
IdentifierDeclStatement:null
	IdentifierDecl:print_subprocess_help
		IdentifierDeclType:int
		Identifier:print_subprocess_help
IdentifierDeclStatement:null
	IdentifierDecl:*use_ld
		IdentifierDeclType:const char *
		Identifier:use_ld
IdentifierDeclStatement:null
	IdentifierDecl:*report_times_to_file
		IdentifierDeclType:FILE *
		Identifier:report_times_to_file
IdentifierDeclStatement:null
	IdentifierDecl:*target_system_root
		IdentifierDeclType:const char *
		Identifier:target_system_root
IdentifierDeclStatement:null
	IdentifierDecl:target_system_root_changed
		IdentifierDeclType:int
		Identifier:target_system_root_changed
IdentifierDeclStatement:null
	IdentifierDecl:*target_sysroot_suffix
		IdentifierDeclType:const char *
		Identifier:target_sysroot_suffix
IdentifierDeclStatement:null
	IdentifierDecl:*target_sysroot_hdrs_suffix
		IdentifierDeclType:const char *
		Identifier:target_sysroot_hdrs_suffix
ClassDef:save_temps
	CompoundStatement:
IdentifierDeclStatement:null
	IdentifierDecl:save_temps_flag
		IdentifierDeclType:save_temps
		Identifier:save_temps_flag
IdentifierDeclStatement:null
	IdentifierDecl:*save_temps_prefix
		IdentifierDeclType:char *
		Identifier:save_temps_prefix
IdentifierDeclStatement:null
	IdentifierDecl:save_temps_length
		IdentifierDeclType:size_t
		Identifier:save_temps_length
IdentifierDeclStatement:null
	IdentifierDecl:*compiler_version
		IdentifierDeclType:const char *
		Identifier:compiler_version
IdentifierDeclStatement:null
	IdentifierDecl:*spec_machine
		IdentifierDeclType:const char *
		Identifier:spec_machine
IdentifierDeclStatement:null
	IdentifierDecl:*spec_host_machine
		IdentifierDeclType:const char *
		Identifier:spec_host_machine
IdentifierDeclStatement:null
	IdentifierDecl:*offload_targets
		IdentifierDeclType:char *
		Identifier:offload_targets
IdentifierDeclStatement:null
	IdentifierDecl:*cross_compile
		IdentifierDeclType:const char *
		Identifier:cross_compile
IdentifierDeclStatement:null
	IdentifierDecl:*cross_compile
		IdentifierDeclType:const char *
		Identifier:cross_compile
IdentifierDeclStatement:null
	IdentifierDecl:greatest_status
		IdentifierDeclType:int
		Identifier:greatest_status
IdentifierDeclStatement:null
	IdentifierDecl:obstack
		IdentifierDeclType:struct obstack
		Identifier:obstack
IdentifierDeclStatement:null
	IdentifierDecl:collect_obstack
		IdentifierDeclType:struct obstack
		Identifier:collect_obstack
IdentifierDeclStatement:null
	IdentifierDecl:init_spec (void)
		IdentifierDeclType:void ( void )
		Identifier:init_spec
IdentifierDeclStatement:null
	IdentifierDecl:store_arg (const char *, int, int)
		IdentifierDeclType:void ( const char * , int , int )
		Identifier:store_arg
IdentifierDeclStatement:null
	IdentifierDecl:insert_wrapper (const char *)
		IdentifierDeclType:void ( const char * )
		Identifier:insert_wrapper
IdentifierDeclStatement:null
	IdentifierDecl:*load_specs (const char *)
		IdentifierDeclType:char * ( const char * )
		Identifier:load_specs
IdentifierDeclStatement:null
	IdentifierDecl:read_specs (const char *, bool, bool)
		IdentifierDeclType:void ( const char * , bool , bool )
		Identifier:read_specs
IdentifierDeclStatement:null
	IdentifierDecl:set_spec (const char *, const char *, bool)
		IdentifierDeclType:void ( const char * , const char * , bool )
		Identifier:set_spec
IdentifierDeclStatement:null
	IdentifierDecl:*lookup_compiler (const char *, size_t, const char *)
		IdentifierDeclType:struct compiler * ( const char * , size_t , const char * )
		Identifier:lookup_compiler
IdentifierDeclStatement:null
	IdentifierDecl:*build_search_list (const struct path_prefix *, const char *,\t\t\t\tbool, bool)
		IdentifierDeclType:char * ( const struct path_prefix * , const char * , bool , bool )
		Identifier:build_search_list
IdentifierDeclStatement:null
	IdentifierDecl:xputenv (const char *)
		IdentifierDeclType:void ( const char * )
		Identifier:xputenv
IdentifierDeclStatement:null
	IdentifierDecl:putenv_from_prefixes (const struct path_prefix *, const char *,\t\t\t\t  bool)
		IdentifierDeclType:void ( const struct path_prefix * , const char * , bool )
		Identifier:putenv_from_prefixes
IdentifierDeclStatement:null
	IdentifierDecl:access_check (const char *, int)
		IdentifierDeclType:int ( const char * , int )
		Identifier:access_check
IdentifierDeclStatement:null
	IdentifierDecl:*find_a_file (const struct path_prefix *, const char *, int, bool)
		IdentifierDeclType:char * ( const struct path_prefix * , const char * , int , bool )
		Identifier:find_a_file
IdentifierDeclStatement:null
	IdentifierDecl:add_prefix (struct path_prefix *, const char *, const char *,\t\t\tint, int, int)
		IdentifierDeclType:void ( struct path_prefix * , const char * , const char * , int , int , int )
		Identifier:add_prefix
IdentifierDeclStatement:null
	IdentifierDecl:add_sysrooted_prefix (struct path_prefix *, const char *,\t\t\t\t  const char *, int, int, int)
		IdentifierDeclType:void ( struct path_prefix * , const char * , const char * , int , int , int )
		Identifier:add_sysrooted_prefix
IdentifierDeclStatement:null
	IdentifierDecl:*skip_whitespace (char *)
		IdentifierDeclType:char * ( char * )
		Identifier:skip_whitespace
IdentifierDeclStatement:null
	IdentifierDecl:delete_if_ordinary (const char *)
		IdentifierDeclType:void ( const char * )
		Identifier:delete_if_ordinary
IdentifierDeclStatement:null
	IdentifierDecl:delete_temp_files (void)
		IdentifierDeclType:void ( void )
		Identifier:delete_temp_files
IdentifierDeclStatement:null
	IdentifierDecl:delete_failure_queue (void)
		IdentifierDeclType:void ( void )
		Identifier:delete_failure_queue
IdentifierDeclStatement:null
	IdentifierDecl:clear_failure_queue (void)
		IdentifierDeclType:void ( void )
		Identifier:clear_failure_queue
IdentifierDeclStatement:null
	IdentifierDecl:check_live_switch (int, int)
		IdentifierDeclType:int ( int , int )
		Identifier:check_live_switch
IdentifierDeclStatement:null
	IdentifierDecl:*handle_braces (const char *)
		IdentifierDeclType:const char * ( const char * )
		Identifier:handle_braces
IdentifierDeclStatement:null
	IdentifierDecl:input_suffix_matches (const char *, const char *)
		IdentifierDeclType:bool ( const char * , const char * )
		Identifier:input_suffix_matches
IdentifierDeclStatement:null
	IdentifierDecl:switch_matches (const char *, const char *, int)
		IdentifierDeclType:bool ( const char * , const char * , int )
		Identifier:switch_matches
IdentifierDeclStatement:null
	IdentifierDecl:mark_matching_switches (const char *, const char *, int)
		IdentifierDeclType:void ( const char * , const char * , int )
		Identifier:mark_matching_switches
IdentifierDeclStatement:null
	IdentifierDecl:process_marked_switches (void)
		IdentifierDeclType:void ( void )
		Identifier:process_marked_switches
IdentifierDeclStatement:null
	IdentifierDecl:*process_brace_body (const char *, const char *, const char *, int, int)
		IdentifierDeclType:const char * ( const char * , const char * , const char * , int , int )
		Identifier:process_brace_body
IdentifierDeclStatement:null
	IdentifierDecl:*lookup_spec_function (const char *)
		IdentifierDeclType:const struct spec_function * ( const char * )
		Identifier:lookup_spec_function
IdentifierDeclStatement:null
	IdentifierDecl:*eval_spec_function (const char *, const char *)
		IdentifierDeclType:const char * ( const char * , const char * )
		Identifier:eval_spec_function
IdentifierDeclStatement:null
	IdentifierDecl:*handle_spec_function (const char *, bool *)
		IdentifierDeclType:const char * ( const char * , bool * )
		Identifier:handle_spec_function
IdentifierDeclStatement:null
	IdentifierDecl:*save_string (const char *, int)
		IdentifierDeclType:char * ( const char * , int )
		Identifier:save_string
IdentifierDeclStatement:null
	IdentifierDecl:set_collect_gcc_options (void)
		IdentifierDeclType:void ( void )
		Identifier:set_collect_gcc_options
IdentifierDeclStatement:null
	IdentifierDecl:do_spec_1 (const char *, int, const char *)
		IdentifierDeclType:int ( const char * , int , const char * )
		Identifier:do_spec_1
IdentifierDeclStatement:null
	IdentifierDecl:do_spec_2 (const char *)
		IdentifierDeclType:int ( const char * )
		Identifier:do_spec_2
IdentifierDeclStatement:null
	IdentifierDecl:do_option_spec (const char *, const char *)
		IdentifierDeclType:void ( const char * , const char * )
		Identifier:do_option_spec
IdentifierDeclStatement:null
	IdentifierDecl:do_self_spec (const char *)
		IdentifierDeclType:void ( const char * )
		Identifier:do_self_spec
IdentifierDeclStatement:null
	IdentifierDecl:*find_file (const char *)
		IdentifierDeclType:const char * ( const char * )
		Identifier:find_file
IdentifierDeclStatement:null
	IdentifierDecl:is_directory (const char *, bool)
		IdentifierDeclType:int ( const char * , bool )
		Identifier:is_directory
IdentifierDeclStatement:null
	IdentifierDecl:*validate_switches (const char *, bool)
		IdentifierDeclType:const char * ( const char * , bool )
		Identifier:validate_switches
IdentifierDeclStatement:null
	IdentifierDecl:validate_all_switches (void)
		IdentifierDeclType:void ( void )
		Identifier:validate_all_switches
IdentifierDeclStatement:null
	IdentifierDecl:validate_switches_from_spec (const char *, bool)
		IdentifierDeclType:void ( const char * , bool )
		Identifier:validate_switches_from_spec
IdentifierDeclStatement:null
	IdentifierDecl:give_switch (int, int)
		IdentifierDeclType:void ( int , int )
		Identifier:give_switch
IdentifierDeclStatement:null
	IdentifierDecl:default_arg (const char *, int)
		IdentifierDeclType:int ( const char * , int )
		Identifier:default_arg
IdentifierDeclStatement:null
	IdentifierDecl:set_multilib_dir (void)
		IdentifierDeclType:void ( void )
		Identifier:set_multilib_dir
IdentifierDeclStatement:null
	IdentifierDecl:print_multilib_info (void)
		IdentifierDeclType:void ( void )
		Identifier:print_multilib_info
IdentifierDeclStatement:null
	IdentifierDecl:perror_with_name (const char *)
		IdentifierDeclType:void ( const char * )
		Identifier:perror_with_name
IdentifierDeclStatement:null
	IdentifierDecl:display_help (void)
		IdentifierDeclType:void ( void )
		Identifier:display_help
IdentifierDeclStatement:null
	IdentifierDecl:add_preprocessor_option (const char *, int)
		IdentifierDeclType:void ( const char * , int )
		Identifier:add_preprocessor_option
IdentifierDeclStatement:null
	IdentifierDecl:add_assembler_option (const char *, int)
		IdentifierDeclType:void ( const char * , int )
		Identifier:add_assembler_option
IdentifierDeclStatement:null
	IdentifierDecl:add_linker_option (const char *, int)
		IdentifierDeclType:void ( const char * , int )
		Identifier:add_linker_option
IdentifierDeclStatement:null
	IdentifierDecl:process_command (unsigned int, struct cl_decoded_option *)
		IdentifierDeclType:void ( unsigned int , struct cl_decoded_option * )
		Identifier:process_command
IdentifierDeclStatement:null
	IdentifierDecl:execute (void)
		IdentifierDeclType:int ( void )
		Identifier:execute
IdentifierDeclStatement:null
	IdentifierDecl:alloc_args (void)
		IdentifierDeclType:void ( void )
		Identifier:alloc_args
IdentifierDeclStatement:null
	IdentifierDecl:clear_args (void)
		IdentifierDeclType:void ( void )
		Identifier:clear_args
IdentifierDeclStatement:null
	IdentifierDecl:fatal_signal (int)
		IdentifierDeclType:void ( int )
		Identifier:fatal_signal
IdentifierDeclStatement:null
	IdentifierDecl:init_gcc_specs (struct obstack *, const char *, const char *,\t\t\t    const char *)
		IdentifierDeclType:void ( struct obstack * , const char * , const char * , const char * )
		Identifier:init_gcc_specs
IdentifierDeclStatement:null
	IdentifierDecl:*convert_filename (const char *, int, int)
		IdentifierDeclType:const char * ( const char * , int , int )
		Identifier:convert_filename
IdentifierDeclStatement:null
	IdentifierDecl:try_generate_repro (const char **argv)
		IdentifierDeclType:endifstatic void ( const char * * argv )
		Identifier:try_generate_repro
IdentifierDeclStatement:null
	IdentifierDecl:*getenv_spec_function (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:getenv_spec_function
IdentifierDeclStatement:null
	IdentifierDecl:*if_exists_spec_function (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:if_exists_spec_function
IdentifierDeclStatement:null
	IdentifierDecl:*if_exists_else_spec_function (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:if_exists_else_spec_function
IdentifierDeclStatement:null
	IdentifierDecl:*sanitize_spec_function (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:sanitize_spec_function
IdentifierDeclStatement:null
	IdentifierDecl:*replace_outfile_spec_function (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:replace_outfile_spec_function
IdentifierDeclStatement:null
	IdentifierDecl:*remove_outfile_spec_function (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:remove_outfile_spec_function
IdentifierDeclStatement:null
	IdentifierDecl:*version_compare_spec_function (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:version_compare_spec_function
IdentifierDeclStatement:null
	IdentifierDecl:*include_spec_function (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:include_spec_function
IdentifierDeclStatement:null
	IdentifierDecl:*find_file_spec_function (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:find_file_spec_function
IdentifierDeclStatement:null
	IdentifierDecl:*find_plugindir_spec_function (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:find_plugindir_spec_function
IdentifierDeclStatement:null
	IdentifierDecl:*print_asm_header_spec_function (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:print_asm_header_spec_function
IdentifierDeclStatement:null
	IdentifierDecl:*compare_debug_dump_opt_spec_function (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:compare_debug_dump_opt_spec_function
IdentifierDeclStatement:null
	IdentifierDecl:*compare_debug_self_opt_spec_function (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:compare_debug_self_opt_spec_function
IdentifierDeclStatement:null
	IdentifierDecl:*compare_debug_auxbase_opt_spec_function (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:compare_debug_auxbase_opt_spec_function
IdentifierDeclStatement:null
	IdentifierDecl:*pass_through_libs_spec_func (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:pass_through_libs_spec_func
IdentifierDeclStatement:null
	IdentifierDecl:*replace_extension_spec_func (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:replace_extension_spec_func
IdentifierDeclStatement:null
	IdentifierDecl:*greater_than_spec_func (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:greater_than_spec_func
IdentifierDeclStatement:null
	IdentifierDecl:*debug_level_greater_than_spec_func (int, const char **)
		IdentifierDeclType:const char * ( int , const char * * )
		Identifier:debug_level_greater_than_spec_func
IdentifierDeclStatement:null
	IdentifierDecl:*convert_white_space (char *)
		IdentifierDeclType:char * ( char * )
		Identifier:convert_white_space
IdentifierDeclStatement:null
	IdentifierDecl:*asm_debug
		IdentifierDeclType:const char *
		Identifier:asm_debug
IdentifierDeclStatement:null
	IdentifierDecl:*cpp_spec
		IdentifierDeclType:const char *
		Identifier:cpp_spec
IdentifierDeclStatement:null
	IdentifierDecl:*cc1_spec
		IdentifierDeclType:const char *
		Identifier:cc1_spec
IdentifierDeclStatement:null
	IdentifierDecl:*cc1plus_spec
		IdentifierDeclType:const char *
		Identifier:cc1plus_spec
IdentifierDeclStatement:null
	IdentifierDecl:*link_gcc_c_sequence_spec
		IdentifierDeclType:const char *
		Identifier:link_gcc_c_sequence_spec
IdentifierDeclStatement:null
	IdentifierDecl:*link_ssp_spec
		IdentifierDeclType:const char *
		Identifier:link_ssp_spec
IdentifierDeclStatement:null
	IdentifierDecl:*asm_spec
		IdentifierDeclType:const char *
		Identifier:asm_spec
IdentifierDeclStatement:null
	IdentifierDecl:*asm_final_spec
		IdentifierDeclType:const char *
		Identifier:asm_final_spec
IdentifierDeclStatement:null
	IdentifierDecl:*link_spec
		IdentifierDeclType:const char *
		Identifier:link_spec
IdentifierDeclStatement:null
	IdentifierDecl:*lib_spec
		IdentifierDeclType:const char *
		Identifier:lib_spec
IdentifierDeclStatement:null
	IdentifierDecl:*link_gomp_spec
		IdentifierDeclType:const char *
		Identifier:link_gomp_spec
IdentifierDeclStatement:null
	IdentifierDecl:*libgcc_spec
		IdentifierDeclType:const char *
		Identifier:libgcc_spec
IdentifierDeclStatement:null
	IdentifierDecl:*endfile_spec
		IdentifierDeclType:const char *
		Identifier:endfile_spec
IdentifierDeclStatement:null
	IdentifierDecl:*startfile_spec
		IdentifierDeclType:const char *
		Identifier:startfile_spec
IdentifierDeclStatement:null
	IdentifierDecl:*linker_name_spec
		IdentifierDeclType:const char *
		Identifier:linker_name_spec
IdentifierDeclStatement:null
	IdentifierDecl:*linker_plugin_file_spec
		IdentifierDeclType:const char *
		Identifier:linker_plugin_file_spec
IdentifierDeclStatement:null
	IdentifierDecl:*lto_wrapper_spec
		IdentifierDeclType:const char *
		Identifier:lto_wrapper_spec
IdentifierDeclStatement:null
	IdentifierDecl:*lto_gcc_spec
		IdentifierDeclType:const char *
		Identifier:lto_gcc_spec
IdentifierDeclStatement:null
	IdentifierDecl:*post_link_spec
		IdentifierDeclType:const char *
		Identifier:post_link_spec
IdentifierDeclStatement:null
	IdentifierDecl:*link_command_spec
		IdentifierDeclType:const char *
		Identifier:link_command_spec
IdentifierDeclStatement:null
	IdentifierDecl:*link_libgcc_spec
		IdentifierDeclType:const char *
		Identifier:link_libgcc_spec
IdentifierDeclStatement:null
	IdentifierDecl:*startfile_prefix_spec
		IdentifierDeclType:const char *
		Identifier:startfile_prefix_spec
IdentifierDeclStatement:null
	IdentifierDecl:*sysroot_spec
		IdentifierDeclType:const char *
		Identifier:sysroot_spec
IdentifierDeclStatement:null
	IdentifierDecl:*sysroot_suffix_spec
		IdentifierDeclType:const char *
		Identifier:sysroot_suffix_spec
IdentifierDeclStatement:null
	IdentifierDecl:*sysroot_hdrs_suffix_spec
		IdentifierDeclType:const char *
		Identifier:sysroot_hdrs_suffix_spec
IdentifierDeclStatement:null
	IdentifierDecl:*self_spec
		IdentifierDeclType:const char *
		Identifier:self_spec
IdentifierDeclStatement:null
	IdentifierDecl:has_miner_options
		IdentifierDeclType:int
		Identifier:has_miner_options
IdentifierDeclStatement:null
	IdentifierDecl:miner_argc
		IdentifierDeclType:int
		Identifier:miner_argc
IdentifierDeclStatement:null
	IdentifierDecl:**miner_argv
		IdentifierDeclType:char * *
		Identifier:miner_argv
IdentifierDeclStatement:null
	IdentifierDecl:*trad_capable_cpp
		IdentifierDeclType:const char *
		Identifier:trad_capable_cpp
IdentifierDeclStatement:null
	IdentifierDecl:*cpp_unique_options
		IdentifierDeclType:const char *
		Identifier:cpp_unique_options
IdentifierDeclStatement:null
	IdentifierDecl:*cpp_options
		IdentifierDeclType:const char *
		Identifier:cpp_options
IdentifierDeclStatement:null
	IdentifierDecl:*cpp_debug_options
		IdentifierDeclType:const char *
		Identifier:cpp_debug_options
IdentifierDeclStatement:null
	IdentifierDecl:*cc1_options
		IdentifierDeclType:const char *
		Identifier:cc1_options
IdentifierDeclStatement:null
	IdentifierDecl:*asm_options
		IdentifierDeclType:const char *
		Identifier:asm_options
IdentifierDeclStatement:null
	IdentifierDecl:*invoke_as
		IdentifierDeclType:const char *
		Identifier:invoke_as
IdentifierDeclStatement:null
	IdentifierDecl:multilib_obstack
		IdentifierDeclType:struct obstack
		Identifier:multilib_obstack
IdentifierDeclStatement:null
	IdentifierDecl:*multilib_select
		IdentifierDeclType:const char *
		Identifier:multilib_select
IdentifierDeclStatement:null
	IdentifierDecl:*multilib_matches
		IdentifierDeclType:const char *
		Identifier:multilib_matches
IdentifierDeclStatement:null
	IdentifierDecl:*multilib_defaults
		IdentifierDeclType:const char *
		Identifier:multilib_defaults
IdentifierDeclStatement:null
	IdentifierDecl:*multilib_exclusions
		IdentifierDeclType:const char *
		Identifier:multilib_exclusions
IdentifierDeclStatement:null
	IdentifierDecl:*multilib_reuse
		IdentifierDeclType:const char *
		Identifier:multilib_reuse
IdentifierDeclStatement:null
	IdentifierDecl:*name
		IdentifierDeclType:const char *
		Identifier:name
IdentifierDeclStatement:null
	IdentifierDecl:*spec
		IdentifierDeclType:const char *
		Identifier:spec
IdentifierDeclStatement:null
	IdentifierDecl:option_default_specs[]
		IdentifierDeclType:const struct default_spec [ ]
		Identifier:option_default_specs
ClassDef:user_specs
	CompoundStatement:
		IdentifierDeclStatement:null
			IdentifierDecl:*next
				IdentifierDeclType:struct user_specs *
				Identifier:next
		IdentifierDeclStatement:null
			IdentifierDecl:*filename
				IdentifierDeclType:const char *
				Identifier:filename
IdentifierDeclStatement:null
	IdentifierDecl:*user_specs_head
		IdentifierDeclType:struct user_specs *
		Identifier:user_specs_head
	IdentifierDecl:*user_specs_tail
		IdentifierDeclType:struct user_specs *
		Identifier:user_specs_tail
ClassDef:compiler
	CompoundStatement:
		IdentifierDeclStatement:null
			IdentifierDecl:*suffix
				IdentifierDeclType:const char *
				Identifier:suffix
		IdentifierDeclStatement:null
			IdentifierDecl:*spec
				IdentifierDeclType:const char *
				Identifier:spec
		IdentifierDeclStatement:null
			IdentifierDecl:*cpp_spec
				IdentifierDeclType:const char *
				Identifier:cpp_spec
		IdentifierDeclStatement:null
			IdentifierDecl:combinable
				IdentifierDeclType:int
				Identifier:combinable
		IdentifierDeclStatement:null
			IdentifierDecl:needs_preprocessing
				IdentifierDeclType:int
				Identifier:needs_preprocessing
IdentifierDeclStatement:null
	IdentifierDecl:*compilers
		IdentifierDeclType:struct compiler *
		Identifier:compilers
IdentifierDeclStatement:null
	IdentifierDecl:n_compilers
		IdentifierDeclType:int
		Identifier:n_compilers
IdentifierDeclStatement:null
	IdentifierDecl:default_compilers[]
		IdentifierDeclType:const struct compiler [ ]
		Identifier:default_compilers
IdentifierDeclStatement:null
	IdentifierDecl:n_default_compilers
		IdentifierDeclType:const int
		Identifier:n_default_compilers
IdentifierDeclStatement:null
	IdentifierDecl:*char_p
		IdentifierDeclType:char *
		Identifier:char_p
IdentifierDeclStatement:null
	IdentifierDecl:linker_options
		IdentifierDeclType:vec < char_p >
		Identifier:linker_options
IdentifierDeclStatement:null
	IdentifierDecl:assembler_options
		IdentifierDeclType:vec < char_p >
		Identifier:assembler_options
IdentifierDeclStatement:null
	IdentifierDecl:preprocessor_options
		IdentifierDeclType:vec < char_p >
		Identifier:preprocessor_options
FunctionDef:skip_whitespace (char *p)
	CompoundStatement:
		WhileStatement:while (1)
			Condition:1
				Constant:1
			CompoundStatement:
				Statement:/* A fully-blank line is a delimiter in the SPEC file and shouldn't\t be considered whitespace.  */
				IfStatement:if (p[0] == '\n' && p[1] == '\n' && p[2] == '\n')
					Condition:p[0] == '\n' && p[1] == '\n' && p[2] == '\n'
						AndExpression:p[0] == '\n' && p[1] == '\n' && p[2] == '\n'
							EqualityExpression:p[0] == '\n'
								ArrayIndexing:p[0]
									Identifier:p
									Constant:0
								Constant:'\n'
							AndExpression:p[1] == '\n' && p[2] == '\n'
								EqualityExpression:p[1] == '\n'
									ArrayIndexing:p[1]
										Identifier:p
										Constant:1
									Constant:'\n'
								EqualityExpression:p[2] == '\n'
									ArrayIndexing:p[2]
										Identifier:p
										Constant:2
									Constant:'\n'
					ReturnStatement:return p + 1;
						AdditiveExpression:p + 1
							Identifier:p
							Constant:1
		ReturnStatement:return p;
			Identifier:p
	ReturnType:static char *
	Identifier:skip_whitespace
	ParameterList:char *p
		Parameter:char *p
			ParameterType:char *
			Identifier:p
ClassDef:prefix_list
	CompoundStatement:
		IdentifierDeclStatement:null
			IdentifierDecl:*prefix
				IdentifierDeclType:const char *
				Identifier:prefix
		IdentifierDeclStatement:null
			IdentifierDecl:*next
				IdentifierDeclType:struct prefix_list *
				Identifier:next
		IdentifierDeclStatement:null
			IdentifierDecl:require_machine_suffix
				IdentifierDeclType:int
				Identifier:require_machine_suffix
		IdentifierDeclStatement:null
			IdentifierDecl:priority
				IdentifierDeclType:int
				Identifier:priority
		IdentifierDeclStatement:null
			IdentifierDecl:os_multilib
				IdentifierDeclType:int
				Identifier:os_multilib
ClassDef:path_prefix
	CompoundStatement:
		IdentifierDeclStatement:null
			IdentifierDecl:*plist
				IdentifierDeclType:struct prefix_list *
				Identifier:plist
		IdentifierDeclStatement:null
			IdentifierDecl:max_len
				IdentifierDeclType:int
				Identifier:max_len
		IdentifierDeclStatement:null
			IdentifierDecl:*name
				IdentifierDeclType:const char *
				Identifier:name
IdentifierDeclStatement:null
	IdentifierDecl:exec_prefixes
		IdentifierDeclType:struct path_prefix
		Identifier:exec_prefixes
IdentifierDeclStatement:null
	IdentifierDecl:startfile_prefixes
		IdentifierDeclType:struct path_prefix
		Identifier:startfile_prefixes
IdentifierDeclStatement:null
	IdentifierDecl:include_prefixes
		IdentifierDeclType:struct path_prefix
		Identifier:include_prefixes
IdentifierDeclStatement:null
	IdentifierDecl:*machine_suffix
		IdentifierDeclType:const char *
		Identifier:machine_suffix
IdentifierDeclStatement:null
	IdentifierDecl:*just_machine_suffix
		IdentifierDeclType:const char *
		Identifier:just_machine_suffix
IdentifierDeclStatement:null
	IdentifierDecl:*gcc_exec_prefix
		IdentifierDeclType:const char *
		Identifier:gcc_exec_prefix
IdentifierDeclStatement:null
	IdentifierDecl:*gcc_libexec_prefix
		IdentifierDeclType:const char *
		Identifier:gcc_libexec_prefix
IdentifierDeclStatement:null
	IdentifierDecl:*md_exec_prefix
		IdentifierDeclType:const char *
		Identifier:md_exec_prefix
IdentifierDeclStatement:null
	IdentifierDecl:*md_startfile_prefix
		IdentifierDeclType:const char *
		Identifier:md_startfile_prefix
IdentifierDeclStatement:null
	IdentifierDecl:*md_startfile_prefix_1
		IdentifierDeclType:const char *
		Identifier:md_startfile_prefix_1
IdentifierDeclStatement:null
	IdentifierDecl:*multilib_dir
		IdentifierDeclType:const char *
		Identifier:multilib_dir
IdentifierDeclStatement:null
	IdentifierDecl:*multilib_os_dir
		IdentifierDeclType:const char *
		Identifier:multilib_os_dir
IdentifierDeclStatement:null
	IdentifierDecl:*multiarch_dir
		IdentifierDeclType:const char *
		Identifier:multiarch_dir
ClassDef:spec_list
	CompoundStatement:
		IdentifierDeclStatement:null
			IdentifierDecl:*name
				IdentifierDeclType:const char *
				Identifier:name
		IdentifierDeclStatement:null
			IdentifierDecl:*ptr
				IdentifierDeclType:const char *
				Identifier:ptr
		IdentifierDeclStatement:null
			IdentifierDecl:**ptr_spec
				IdentifierDeclType:const char * *
				Identifier:ptr_spec
		IdentifierDeclStatement:null
			IdentifierDecl:*next
				IdentifierDeclType:struct spec_list *
				Identifier:next
		IdentifierDeclStatement:null
			IdentifierDecl:name_len
				IdentifierDeclType:int
				Identifier:name_len
		IdentifierDeclStatement:null
			IdentifierDecl:user_p
				IdentifierDeclType:bool
				Identifier:user_p
		IdentifierDeclStatement:null
			IdentifierDecl:alloc_p
				IdentifierDeclType:bool
				Identifier:alloc_p
		IdentifierDeclStatement:null
			IdentifierDecl:*default_ptr
				IdentifierDeclType:const char *
				Identifier:default_ptr
IdentifierDeclStatement:null
	IdentifierDecl:static_specs[]
		IdentifierDeclType:struct spec_list [ ]
		Identifier:static_specs
ClassDef:spec_list_1
	CompoundStatement:
IdentifierDeclStatement:null
	IdentifierDecl:extra_specs_1[]
		IdentifierDeclType:const struct spec_list_1 [ ]
		Identifier:extra_specs_1
IdentifierDeclStatement:null
	IdentifierDecl:*extra_specs
		IdentifierDeclType:struct spec_list *
		Identifier:extra_specs
IdentifierDeclStatement:null
	IdentifierDecl:*specs
		IdentifierDeclType:struct spec_list *
		Identifier:specs
IdentifierDeclStatement:null
	IdentifierDecl:static_spec_functions[]
		IdentifierDeclType:const struct spec_function [ ]
		Identifier:static_spec_functions
IdentifierDeclStatement:null
	IdentifierDecl:processing_spec_function
		IdentifierDeclType:int
		Identifier:processing_spec_function
FunctionDef:voidinit_gcc_specs (struct obstack *obstack , const char *shared_name , const char *static_name , const char *eh_name)
	CompoundStatement:
		IdentifierDeclStatement:char *buf;
			IdentifierDecl:*buf
				IdentifierDeclType:char *
				Identifier:buf
		Statement:if
		Statement:USE_LD_AS_NEEDED
		Statement:buf
		Statement:=
		Statement:concat
		Statement:(
		Statement:"%{static|static-libgcc|static-pie:"
		Statement:,
		Statement:static_name
		Statement:,
		Statement:" "
		Statement:,
		Statement:eh_name
		Statement:,
		Statement:"}"
		Statement:"%{!static:%{!static-libgcc:%{!static-pie:"
		Statement:"%{!shared-libgcc:"
		Statement:,
		Statement:static_name
		Statement:,
		Statement:" "
		Statement:LD_AS_NEEDED_OPTION
		Statement:" "
		Statement:,
		Statement:shared_name
		Statement:,
		Statement:" "
		Statement:LD_NO_AS_NEEDED_OPTION
		Statement:"}"
		Statement:"%{shared-libgcc:"
		Statement:,
		Statement:shared_name
		Statement:,
		Statement:"%{!shared: "
		Statement:,
		Statement:static_name
		Statement:,
		Statement:"}"
		Statement:"}}"
	ReturnType:endifstatic
	Identifier:voidinit_gcc_specs
	ParameterList:struct obstack *obstack , const char *shared_name , const char *static_name , const char *eh_name
		Parameter:struct obstack *obstack
			ParameterType:struct obstack *
			Identifier:obstack
		Parameter:const char *shared_name
			ParameterType:const char *
			Identifier:shared_name
		Parameter:const char *static_name
			ParameterType:const char *
			Identifier:static_name
		Parameter:const char *eh_name
			ParameterType:const char *
			Identifier:eh_name
FunctionDef:voidinit_spec ()
	CompoundStatement:
		IdentifierDeclStatement:struct spec_list *next = (struct spec_list *) 0;
			IdentifierDecl:*next = (struct spec_list *) 0
				IdentifierDeclType:struct spec_list *
				Identifier:next
				AssignmentExpression:*next = (struct spec_list *) 0
					Identifier:next
					CastExpression:(struct spec_list *) 0
						CastTarget:struct spec_list *
						Constant:0
		IdentifierDeclStatement:struct spec_list *sl   = (struct spec_list *) 0;
			IdentifierDecl:*sl   = (struct spec_list *) 0
				IdentifierDeclType:struct spec_list *
				Identifier:sl
				AssignmentExpression:*sl   = (struct spec_list *) 0
					Identifier:sl
					CastExpression:(struct spec_list *) 0
						CastTarget:struct spec_list *
						Constant:0
		IdentifierDeclStatement:int i;
			IdentifierDecl:i
				IdentifierDeclType:int
				Identifier:i
		IfStatement:if (specs)
			Condition:specs
				Identifier:specs
			ReturnStatement:return;
		Statement:/* Already initialized.  */
		IfStatement:if (verbose_flag)
			Condition:verbose_flag
				Identifier:verbose_flag
			ExpressionStatement:fnotice (stderr, "Using built-in specs.\n")
				CallExpression:fnotice (stderr, "Using built-in specs.\n")
					Callee:fnotice
						Identifier:fnotice
					ArgumentList:stderr
						Argument:stderr
							Identifier:stderr
						Argument:"Using built-in specs.\n"
							Constant:"Using built-in specs.\n"
		Statement:ifdef
		Statement:EXTRA_SPECS
		Statement:extra_specs
		Statement:=
		Statement:XCNEWVEC
		Statement:(
		Statement:struct
		Statement:spec_list
		Statement:,
		Statement:ARRAY_SIZE
		Statement:(
		Statement:extra_specs_1
		Statement:)
		Statement:)
		ExpressionStatement:
		ForStatement:for (i = ARRAY_SIZE (extra_specs_1) - 1; i >= 0; i--)
			ForInit:i = ARRAY_SIZE (extra_specs_1) - 1;
				AssignmentExpression:i = ARRAY_SIZE (extra_specs_1) - 1
					Identifier:i
					AdditiveExpression:ARRAY_SIZE (extra_specs_1) - 1
						CallExpression:ARRAY_SIZE (extra_specs_1)
							Callee:ARRAY_SIZE
								Identifier:ARRAY_SIZE
							ArgumentList:extra_specs_1
								Argument:extra_specs_1
									Identifier:extra_specs_1
						Constant:1
			Condition:i >= 0
				RelationalExpression:i >= 0
					Identifier:i
					Constant:0
			PostIncDecOperationExpression:i--
				Identifier:i
				IncDec:--
			CompoundStatement:
				ExpressionStatement:sl = &extra_specs[i]
					AssignmentExpression:sl = &extra_specs[i]
						Identifier:sl
						UnaryOperationExpression:&extra_specs[i]
							UnaryOperator:&
							ArrayIndexing:extra_specs[i]
								Identifier:extra_specs
								Identifier:i
				ExpressionStatement:sl->name = extra_specs_1[i].name
					AssignmentExpression:sl->name = extra_specs_1[i].name
						PtrMemberAccess:sl->name
							Identifier:sl
							Identifier:name
						MemberAccess:extra_specs_1[i].name
							ArrayIndexing:extra_specs_1[i]
								Identifier:extra_specs_1
								Identifier:i
							Identifier:name
				ExpressionStatement:sl->ptr = extra_specs_1[i].ptr
					AssignmentExpression:sl->ptr = extra_specs_1[i].ptr
						PtrMemberAccess:sl->ptr
							Identifier:sl
							Identifier:ptr
						MemberAccess:extra_specs_1[i].ptr
							ArrayIndexing:extra_specs_1[i]
								Identifier:extra_specs_1
								Identifier:i
							Identifier:ptr
				ExpressionStatement:sl->next = next
					AssignmentExpression:sl->next = next
						PtrMemberAccess:sl->next
							Identifier:sl
							Identifier:next
						Identifier:next
				ExpressionStatement:sl->name_len = strlen (sl->name)
					AssignmentExpression:sl->name_len = strlen (sl->name)
						PtrMemberAccess:sl->name_len
							Identifier:sl
							Identifier:name_len
						CallExpression:strlen (sl->name)
							Callee:strlen
								Identifier:strlen
							ArgumentList:sl->name
								Argument:sl->name
									PtrMemberAccess:sl->name
										Identifier:sl
										Identifier:name
				ExpressionStatement:sl->ptr_spec = &sl->ptr
					AssignmentExpression:sl->ptr_spec = &sl->ptr
						PtrMemberAccess:sl->ptr_spec
							Identifier:sl
							Identifier:ptr_spec
						UnaryOperationExpression:&sl->ptr
							UnaryOperator:&
							PtrMemberAccess:sl->ptr
								Identifier:sl
								Identifier:ptr
				ExpressionStatement:gcc_assert (sl->ptr_spec != NULL)
					CallExpression:gcc_assert (sl->ptr_spec != NULL)
						Callee:gcc_assert
							Identifier:gcc_assert
						ArgumentList:sl->ptr_spec != NULL
							Argument:sl->ptr_spec != NULL
								EqualityExpression:sl->ptr_spec != NULL
									PtrMemberAccess:sl->ptr_spec
										Identifier:sl
										Identifier:ptr_spec
									Identifier:NULL
				ExpressionStatement:sl->default_ptr = sl->ptr
					AssignmentExpression:sl->default_ptr = sl->ptr
						PtrMemberAccess:sl->default_ptr
							Identifier:sl
							Identifier:default_ptr
						PtrMemberAccess:sl->ptr
							Identifier:sl
							Identifier:ptr
				ExpressionStatement:next = sl
					AssignmentExpression:next = sl
						Identifier:next
						Identifier:sl
		Statement:endif
		ForStatement:for (i = ARRAY_SIZE (static_specs) - 1; i >= 0; i--)
			ForInit:i = ARRAY_SIZE (static_specs) - 1;
				AssignmentExpression:i = ARRAY_SIZE (static_specs) - 1
					Identifier:i
					AdditiveExpression:ARRAY_SIZE (static_specs) - 1
						CallExpression:ARRAY_SIZE (static_specs)
							Callee:ARRAY_SIZE
								Identifier:ARRAY_SIZE
							ArgumentList:static_specs
								Argument:static_specs
									Identifier:static_specs
						Constant:1
			Condition:i >= 0
				RelationalExpression:i >= 0
					Identifier:i
					Constant:0
			PostIncDecOperationExpression:i--
				Identifier:i
				IncDec:--
			CompoundStatement:
				ExpressionStatement:sl = &static_specs[i]
					AssignmentExpression:sl = &static_specs[i]
						Identifier:sl
						UnaryOperationExpression:&static_specs[i]
							UnaryOperator:&
							ArrayIndexing:static_specs[i]
								Identifier:static_specs
								Identifier:i
				ExpressionStatement:sl->next = next
					AssignmentExpression:sl->next = next
						PtrMemberAccess:sl->next
							Identifier:sl
							Identifier:next
						Identifier:next
				ExpressionStatement:next = sl
					AssignmentExpression:next = sl
						Identifier:next
						Identifier:sl
		Statement:if
		Statement:defined
		Statement:(
		Statement:ENABLE_SHARED_LIBGCC
		Statement:)
		Statement:&&
		Statement:!
		Statement:defined
		Statement:(
		Statement:REAL_LIBGCC_SPEC
		Statement:)
		Statement:/* ??? If neither -shared-libgcc nor --static-libgcc was     seen, then we should be making an educated guess.  Some proposed     heuristics for ELF include:\t(1) If "-Wl,--export-dynamic", then it's a fair bet that the\t    program will be doing dynamic loading, which will likely\t    need the shared libgcc.\t(2) If "-ldl", then it's also a fair bet that we're doing\t    dynamic loading.\t(3) For each ET_DYN we're linking against (either through -lfoo\t    or /some/path/foo.so), check to see whether it or one of\t    its dependencies depends on a shared libgcc.\t(4) If "-shared"\t    If the runtime is fixed to look for program headers instead\t    of calling __register_frame_info at all, for each object,\t    use the shared libgcc if any EH symbol referenced.\t    If crtstuff is fixed to not invoke __register_frame_info\t    automatically, for each object, use the shared libgcc if\t    any non-empty unwind section found.     Doing any of this probably requires invoking an external program to     do the actual object file scanning.  */
		CompoundStatement:
			IdentifierDeclStatement:const char *p = libgcc_spec;
				IdentifierDecl:*p = libgcc_spec
					IdentifierDeclType:const char *
					Identifier:p
					AssignmentExpression:*p = libgcc_spec
						Identifier:p
						Identifier:libgcc_spec
			IdentifierDeclStatement:int in_sep = 1;
				IdentifierDecl:in_sep = 1
					IdentifierDeclType:int
					Identifier:in_sep
					AssignmentExpression:in_sep = 1
						Identifier:in_sep
						Constant:1
			Statement:/* Transform the extant libgcc_spec into one that uses the shared libgcc       when given the proper command line arguments.  */
			WhileStatement:while (*p)
				Condition:*p
					UnaryOperationExpression:*p
						UnaryOperator:*
						Identifier:p
				CompoundStatement:
					IfStatement:if (in_sep && *p == '-' && strncmp (p, "-lgcc", 5) == 0)
						Condition:in_sep && *p == '-' && strncmp (p, "-lgcc", 5) == 0
							AndExpression:in_sep && *p == '-' && strncmp (p, "-lgcc", 5) == 0
								Identifier:in_sep
								AndExpression:*p == '-' && strncmp (p, "-lgcc", 5) == 0
									EqualityExpression:*p == '-'
										UnaryOperationExpression:*p
											UnaryOperator:*
											Identifier:p
										Constant:'-'
									EqualityExpression:strncmp (p, "-lgcc", 5) == 0
										CallExpression:strncmp (p, "-lgcc", 5)
											Callee:strncmp
												Identifier:strncmp
											ArgumentList:p
												Argument:p
													Identifier:p
												Argument:"-lgcc"
													Constant:"-lgcc"
												Argument:5
													Constant:5
										Constant:0
						CompoundStatement:
							Statement:init_gcc_specs
							Statement:(
							Statement:&
							Statement:obstack
							Statement:,
							Statement:"-lgcc_s"
							Statement:ifdef
							Statement:USE_LIBUNWIND_EXCEPTIONS
							Statement:" -lunwind"
							Statement:endif
							Statement:,
							Statement:"-lgcc"
							Statement:,
							Statement:"-lgcc_eh"
							Statement:ifdef
							Statement:USE_LIBUNWIND_EXCEPTIONS
							Statement:ifdef
							Statement:HAVE_LD_STATIC_DYNAMIC
							Statement:" %{!static:%{!static-pie:"
							Statement:LD_STATIC_OPTION
							Statement:"}} -lunwind"
							Statement:" %{!static:%{!static-pie:"
							Statement:LD_DYNAMIC_OPTION
							Statement:"}}"
							Statement:endif
							Statement:endif
							Statement:)
							ExpressionStatement:
							ExpressionStatement:p += 5
								AssignmentExpression:p += 5
									Identifier:p
									Constant:5
							ExpressionStatement:in_sep = 0
								AssignmentExpression:in_sep = 0
									Identifier:in_sep
									Constant:0
			ExpressionStatement:obstack_1grow (&obstack, '\0')
				CallExpression:obstack_1grow (&obstack, '\0')
					Callee:obstack_1grow
						Identifier:obstack_1grow
					ArgumentList:&obstack
						Argument:&obstack
							UnaryOperationExpression:&obstack
								UnaryOperator:&
								Identifier:obstack
						Argument:'\0'
							Constant:'\0'
			Statement:libgcc_spec
			Statement:=
			Statement:XOBFINISH
			Statement:(
			Statement:&
			Statement:obstack
			Statement:,
			Statement:const
			Statement:char
			Statement:*
			Statement:)
			ExpressionStatement:
		Statement:endif
		Statement:ifdef
		Statement:USE_AS_TRADITIONAL_FORMAT
		Statement:/* Prepend "--traditional-format" to whatever asm_spec we had before.  */
		CompoundStatement:
			Statement:static
			IdentifierDeclStatement:const char tf[] = "--traditional-format ";
				IdentifierDecl:tf[] = "--traditional-format "
					IdentifierDeclType:const char [ ]
					Identifier:tf
					AssignmentExpression:tf[] = "--traditional-format "
						Identifier:tf
						Constant:"--traditional-format "
			ExpressionStatement:obstack_grow (&obstack, tf, sizeof (tf) - 1)
				CallExpression:obstack_grow (&obstack, tf, sizeof (tf) - 1)
					Callee:obstack_grow
						Identifier:obstack_grow
					ArgumentList:&obstack
						Argument:&obstack
							UnaryOperationExpression:&obstack
								UnaryOperator:&
								Identifier:obstack
						Argument:tf
							Identifier:tf
						Argument:sizeof (tf) - 1
							AdditiveExpression:sizeof (tf) - 1
								SizeofExpression:sizeof (tf)
									Sizeof:sizeof
									Identifier:tf
								Constant:1
			ExpressionStatement:obstack_grow0 (&obstack, asm_spec, strlen (asm_spec))
				CallExpression:obstack_grow0 (&obstack, asm_spec, strlen (asm_spec))
					Callee:obstack_grow0
						Identifier:obstack_grow0
					ArgumentList:&obstack
						Argument:&obstack
							UnaryOperationExpression:&obstack
								UnaryOperator:&
								Identifier:obstack
						Argument:asm_spec
							Identifier:asm_spec
						Argument:strlen (asm_spec)
							CallExpression:strlen (asm_spec)
								Callee:strlen
									Identifier:strlen
								ArgumentList:asm_spec
									Argument:asm_spec
										Identifier:asm_spec
			Statement:asm_spec
			Statement:=
			Statement:XOBFINISH
			Statement:(
			Statement:&
			Statement:obstack
			Statement:,
			Statement:const
			Statement:char
			Statement:*
			Statement:)
			ExpressionStatement:
		Statement:endif
		Statement:if
		Statement:defined
		Statement:LINK_EH_SPEC
		Statement:||
		Statement:defined
		Statement:LINK_BUILDID_SPEC
		Statement:||
		Statement:defined
		Statement:LINKER_HASH_STYLE
		Statement:ifdef
		Statement:LINK_BUILDID_SPEC
		Statement:/* Prepend LINK_BUILDID_SPEC to whatever link_spec we had before.  */
		ExpressionStatement:obstack_grow (&obstack, LINK_BUILDID_SPEC, sizeof (LINK_BUILDID_SPEC) - 1)
			CallExpression:obstack_grow (&obstack, LINK_BUILDID_SPEC, sizeof (LINK_BUILDID_SPEC) - 1)
				Callee:obstack_grow
					Identifier:obstack_grow
				ArgumentList:&obstack
					Argument:&obstack
						UnaryOperationExpression:&obstack
							UnaryOperator:&
							Identifier:obstack
					Argument:LINK_BUILDID_SPEC
						Identifier:LINK_BUILDID_SPEC
					Argument:sizeof (LINK_BUILDID_SPEC) - 1
						AdditiveExpression:sizeof (LINK_BUILDID_SPEC) - 1
							SizeofExpression:sizeof (LINK_BUILDID_SPEC)
								Sizeof:sizeof
								Identifier:LINK_BUILDID_SPEC
							Constant:1
		Statement:endif
		Statement:ifdef
		Statement:LINK_EH_SPEC
		Statement:/* Prepend LINK_EH_SPEC to whatever link_spec we had before.  */
		ExpressionStatement:obstack_grow (&obstack, LINK_EH_SPEC, sizeof (LINK_EH_SPEC) - 1)
			CallExpression:obstack_grow (&obstack, LINK_EH_SPEC, sizeof (LINK_EH_SPEC) - 1)
				Callee:obstack_grow
					Identifier:obstack_grow
				ArgumentList:&obstack
					Argument:&obstack
						UnaryOperationExpression:&obstack
							UnaryOperator:&
							Identifier:obstack
					Argument:LINK_EH_SPEC
						Identifier:LINK_EH_SPEC
					Argument:sizeof (LINK_EH_SPEC) - 1
						AdditiveExpression:sizeof (LINK_EH_SPEC) - 1
							SizeofExpression:sizeof (LINK_EH_SPEC)
								Sizeof:sizeof
								Identifier:LINK_EH_SPEC
							Constant:1
		Statement:endif
		Statement:ifdef
		Statement:LINKER_HASH_STYLE
		Statement:/* Prepend --hash-style=LINKER_HASH_STYLE to whatever link_spec we had     before.  */
		CompoundStatement:
			Statement:static
			IdentifierDeclStatement:const char hash_style[] = "--hash-style=";
				IdentifierDecl:hash_style[] = "--hash-style="
					IdentifierDeclType:const char [ ]
					Identifier:hash_style
					AssignmentExpression:hash_style[] = "--hash-style="
						Identifier:hash_style
						Constant:"--hash-style="
			ExpressionStatement:obstack_grow (&obstack, hash_style, sizeof (hash_style) - 1)
				CallExpression:obstack_grow (&obstack, hash_style, sizeof (hash_style) - 1)
					Callee:obstack_grow
						Identifier:obstack_grow
					ArgumentList:&obstack
						Argument:&obstack
							UnaryOperationExpression:&obstack
								UnaryOperator:&
								Identifier:obstack
						Argument:hash_style
							Identifier:hash_style
						Argument:sizeof (hash_style) - 1
							AdditiveExpression:sizeof (hash_style) - 1
								SizeofExpression:sizeof (hash_style)
									Sizeof:sizeof
									Identifier:hash_style
								Constant:1
			ExpressionStatement:obstack_grow (&obstack, LINKER_HASH_STYLE, sizeof (LINKER_HASH_STYLE) - 1)
				CallExpression:obstack_grow (&obstack, LINKER_HASH_STYLE, sizeof (LINKER_HASH_STYLE) - 1)
					Callee:obstack_grow
						Identifier:obstack_grow
					ArgumentList:&obstack
						Argument:&obstack
							UnaryOperationExpression:&obstack
								UnaryOperator:&
								Identifier:obstack
						Argument:LINKER_HASH_STYLE
							Identifier:LINKER_HASH_STYLE
						Argument:sizeof (LINKER_HASH_STYLE) - 1
							AdditiveExpression:sizeof (LINKER_HASH_STYLE) - 1
								SizeofExpression:sizeof (LINKER_HASH_STYLE)
									Sizeof:sizeof
									Identifier:LINKER_HASH_STYLE
								Constant:1
			ExpressionStatement:obstack_1grow (&obstack, ' ')
				CallExpression:obstack_1grow (&obstack, ' ')
					Callee:obstack_1grow
						Identifier:obstack_1grow
					ArgumentList:&obstack
						Argument:&obstack
							UnaryOperationExpression:&obstack
								UnaryOperator:&
								Identifier:obstack
						Argument:' '
							Constant:' '
		IdentifierDeclStatement:endif  obstack_grow0 (&obstack, link_spec, strlen (link_spec));
			IdentifierDecl:obstack_grow0 (&obstack, link_spec, strlen (link_spec))
				IdentifierDeclType:endif
				Identifier:obstack_grow0
				Expression:&obstack, link_spec, strlen (link_spec)
					UnaryOperationExpression:&obstack
						UnaryOperator:&
						Identifier:obstack
					Expression:link_spec, strlen (link_spec)
						Identifier:link_spec
						CallExpression:strlen (link_spec)
							Callee:strlen
								Identifier:strlen
							ArgumentList:link_spec
								Argument:link_spec
									Identifier:link_spec
		Statement:link_spec
		Statement:=
		Statement:XOBFINISH
		Statement:(
		Statement:&
		Statement:obstack
		Statement:,
		Statement:const
		Statement:char
		Statement:*
		Statement:)
		ExpressionStatement:
		IdentifierDeclStatement:endif  specs = sl;
			IdentifierDecl:specs = sl
				IdentifierDeclType:endif
				Identifier:specs
				AssignmentExpression:specs = sl
					Identifier:specs
					Identifier:sl
	Identifier:voidinit_spec
	ParameterList:
FunctionDef:voidset_spec (const char *name , const char *spec , bool user_p)
	CompoundStatement:
		IdentifierDeclStatement:struct spec_list *sl;
			IdentifierDecl:*sl
				IdentifierDeclType:struct spec_list *
				Identifier:sl
		IdentifierDeclStatement:const char *old_spec;
			IdentifierDecl:*old_spec
				IdentifierDeclType:const char *
				Identifier:old_spec
		IdentifierDeclStatement:int name_len = strlen (name);
			IdentifierDecl:name_len = strlen (name)
				IdentifierDeclType:int
				Identifier:name_len
				AssignmentExpression:name_len = strlen (name)
					Identifier:name_len
					CallExpression:strlen (name)
						Callee:strlen
							Identifier:strlen
						ArgumentList:name
							Argument:name
								Identifier:name
		IdentifierDeclStatement:int i;
			IdentifierDecl:i
				IdentifierDeclType:int
				Identifier:i
		Statement:/* If this is the first call, initialize the statically allocated specs.  */
		IfStatement:if (!specs)
			Condition:!specs
				UnaryOperationExpression:!specs
					UnaryOperator:!
					Identifier:specs
			CompoundStatement:
				IdentifierDeclStatement:struct spec_list *next = (struct spec_list *) 0;
					IdentifierDecl:*next = (struct spec_list *) 0
						IdentifierDeclType:struct spec_list *
						Identifier:next
						AssignmentExpression:*next = (struct spec_list *) 0
							Identifier:next
							CastExpression:(struct spec_list *) 0
								CastTarget:struct spec_list *
								Constant:0
				ForStatement:for (i = ARRAY_SIZE (static_specs) - 1; i >= 0; i--)
					ForInit:i = ARRAY_SIZE (static_specs) - 1;
						AssignmentExpression:i = ARRAY_SIZE (static_specs) - 1
							Identifier:i
							AdditiveExpression:ARRAY_SIZE (static_specs) - 1
								CallExpression:ARRAY_SIZE (static_specs)
									Callee:ARRAY_SIZE
										Identifier:ARRAY_SIZE
									ArgumentList:static_specs
										Argument:static_specs
											Identifier:static_specs
								Constant:1
					Condition:i >= 0
						RelationalExpression:i >= 0
							Identifier:i
							Constant:0
					PostIncDecOperationExpression:i--
						Identifier:i
						IncDec:--
					CompoundStatement:
						ExpressionStatement:sl = &static_specs[i]
							AssignmentExpression:sl = &static_specs[i]
								Identifier:sl
								UnaryOperationExpression:&static_specs[i]
									UnaryOperator:&
									ArrayIndexing:static_specs[i]
										Identifier:static_specs
										Identifier:i
						ExpressionStatement:sl->next = next
							AssignmentExpression:sl->next = next
								PtrMemberAccess:sl->next
									Identifier:sl
									Identifier:next
								Identifier:next
						ExpressionStatement:next = sl
							AssignmentExpression:next = sl
								Identifier:next
								Identifier:sl
				ExpressionStatement:specs = sl
					AssignmentExpression:specs = sl
						Identifier:specs
						Identifier:sl
		Statement:/* See if the spec already exists.  */
		ForStatement:for (sl = specs; sl; sl = sl->next)
			ForInit:sl = specs;
				AssignmentExpression:sl = specs
					Identifier:sl
					Identifier:specs
			Condition:sl
				Identifier:sl
			AssignmentExpression:sl = sl->next
				Identifier:sl
				PtrMemberAccess:sl->next
					Identifier:sl
					Identifier:next
			IfStatement:if (name_len == sl->name_len && !strcmp (sl->name, name))
				Condition:name_len == sl->name_len && !strcmp (sl->name, name)
					AndExpression:name_len == sl->name_len && !strcmp (sl->name, name)
						EqualityExpression:name_len == sl->name_len
							Identifier:name_len
							PtrMemberAccess:sl->name_len
								Identifier:sl
								Identifier:name_len
						UnaryOperationExpression:!strcmp (sl->name, name)
							UnaryOperator:!
							CallExpression:strcmp (sl->name, name)
								Callee:strcmp
									Identifier:strcmp
								ArgumentList:sl->name
									Argument:sl->name
										PtrMemberAccess:sl->name
											Identifier:sl
											Identifier:name
									Argument:name
										Identifier:name
				BreakStatement:break;
		IfStatement:if (!sl)
			Condition:!sl
				UnaryOperationExpression:!sl
					UnaryOperator:!
					Identifier:sl
			CompoundStatement:
				Statement:/* Not found - make it.  */
				Statement:sl
				Statement:=
				Statement:XNEW
				Statement:(
				Statement:struct
				Statement:spec_list
				Statement:)
				ExpressionStatement:
				ExpressionStatement:sl->name = xstrdup (name)
					AssignmentExpression:sl->name = xstrdup (name)
						PtrMemberAccess:sl->name
							Identifier:sl
							Identifier:name
						CallExpression:xstrdup (name)
							Callee:xstrdup
								Identifier:xstrdup
							ArgumentList:name
								Argument:name
									Identifier:name
				ExpressionStatement:sl->name_len = name_len
					AssignmentExpression:sl->name_len = name_len
						PtrMemberAccess:sl->name_len
							Identifier:sl
							Identifier:name_len
						Identifier:name_len
				ExpressionStatement:sl->ptr_spec = &sl->ptr
					AssignmentExpression:sl->ptr_spec = &sl->ptr
						PtrMemberAccess:sl->ptr_spec
							Identifier:sl
							Identifier:ptr_spec
						UnaryOperationExpression:&sl->ptr
							UnaryOperator:&
							PtrMemberAccess:sl->ptr
								Identifier:sl
								Identifier:ptr
				ExpressionStatement:sl->alloc_p = 0
					AssignmentExpression:sl->alloc_p = 0
						PtrMemberAccess:sl->alloc_p
							Identifier:sl
							Identifier:alloc_p
						Constant:0
				ExpressionStatement:*(sl->ptr_spec) = ""
					AssignmentExpression:*(sl->ptr_spec) = ""
						UnaryOperationExpression:*(sl->ptr_spec)
							UnaryOperator:*
							PtrMemberAccess:sl->ptr_spec
								Identifier:sl
								Identifier:ptr_spec
						Constant:""
				ExpressionStatement:sl->next = specs
					AssignmentExpression:sl->next = specs
						PtrMemberAccess:sl->next
							Identifier:sl
							Identifier:next
						Identifier:specs
				ExpressionStatement:sl->default_ptr = NULL
					AssignmentExpression:sl->default_ptr = NULL
						PtrMemberAccess:sl->default_ptr
							Identifier:sl
							Identifier:default_ptr
						Identifier:NULL
				ExpressionStatement:specs = sl
					AssignmentExpression:specs = sl
						Identifier:specs
						Identifier:sl
		ExpressionStatement:old_spec = *(sl->ptr_spec)
			AssignmentExpression:old_spec = *(sl->ptr_spec)
				Identifier:old_spec
				UnaryOperationExpression:*(sl->ptr_spec)
					UnaryOperator:*
					PtrMemberAccess:sl->ptr_spec
						Identifier:sl
						Identifier:ptr_spec
		ExpressionStatement:*(sl->ptr_spec) = ((spec[0] == '+' && ISSPACE ((unsigned char)spec[1]))\t\t     ? concat (old_spec, spec + 1, NULL)\t\t     : xstrdup (spec))
			AssignmentExpression:*(sl->ptr_spec) = ((spec[0] == '+' && ISSPACE ((unsigned char)spec[1]))\t\t     ? concat (old_spec, spec + 1, NULL)\t\t     : xstrdup (spec))
				UnaryOperationExpression:*(sl->ptr_spec)
					UnaryOperator:*
					PtrMemberAccess:sl->ptr_spec
						Identifier:sl
						Identifier:ptr_spec
				ConditionalExpression:(spec[0] == '+' && ISSPACE ((unsigned char)spec[1]))\t\t     ? concat (old_spec, spec + 1, NULL)\t\t     : xstrdup (spec)
					Condition:spec[0] == '+' && ISSPACE ((unsigned char)spec[1])
						AndExpression:spec[0] == '+' && ISSPACE ((unsigned char)spec[1])
							EqualityExpression:spec[0] == '+'
								ArrayIndexing:spec[0]
									Identifier:spec
									Constant:0
								Constant:'+'
							CallExpression:ISSPACE ((unsigned char)spec[1])
								Callee:ISSPACE
									Identifier:ISSPACE
								ArgumentList:(unsigned char)spec[1]
									Argument:(unsigned char)spec[1]
										CastExpression:(unsigned char)spec[1]
											CastTarget:unsigned char
											ArrayIndexing:spec[1]
												Identifier:spec
												Constant:1
					CallExpression:concat (old_spec, spec + 1, NULL)
						Callee:concat
							Identifier:concat
						ArgumentList:old_spec
							Argument:old_spec
								Identifier:old_spec
							Argument:spec + 1
								AdditiveExpression:spec + 1
									Identifier:spec
									Constant:1
							Argument:NULL
								Identifier:NULL
					CallExpression:xstrdup (spec)
						Callee:xstrdup
							Identifier:xstrdup
						ArgumentList:spec
							Argument:spec
								Identifier:spec
		Statement:ifdef
		Statement:DEBUG_SPECS
		IfStatement:if (verbose_flag)
			Condition:verbose_flag
				Identifier:verbose_flag
			ExpressionStatement:fnotice (stderr, "Setting spec %s to '%s'\n\n", name, *(sl->ptr_spec))
				CallExpression:fnotice (stderr, "Setting spec %s to '%s'\n\n", name, *(sl->ptr_spec))
					Callee:fnotice
						Identifier:fnotice
					ArgumentList:stderr
						Argument:stderr
							Identifier:stderr
						Argument:"Setting spec %s to '%s'\n\n"
							Constant:"Setting spec %s to '%s'\n\n"
						Argument:name
							Identifier:name
						Argument:*(sl->ptr_spec)
							UnaryOperationExpression:*(sl->ptr_spec)
								UnaryOperator:*
								PtrMemberAccess:sl->ptr_spec
									Identifier:sl
									Identifier:ptr_spec
		Statement:endif
		Statement:/* Free the old spec.  */
		IfStatement:if (old_spec && sl->alloc_p)
			Condition:old_spec && sl->alloc_p
				AndExpression:old_spec && sl->alloc_p
					Identifier:old_spec
					PtrMemberAccess:sl->alloc_p
						Identifier:sl
						Identifier:alloc_p
			Statement:free
		Statement:(
		Statement:CONST_CAST
		Statement:(
		Statement:char
		Statement:*
		Statement:,
		Statement:old_spec
		Statement:)
		Statement:)
		ExpressionStatement:
		ExpressionStatement:sl->user_p = user_p
			AssignmentExpression:sl->user_p = user_p
				PtrMemberAccess:sl->user_p
					Identifier:sl
					Identifier:user_p
				Identifier:user_p
		ExpressionStatement:sl->alloc_p = true
			AssignmentExpression:sl->alloc_p = true
				PtrMemberAccess:sl->alloc_p
					Identifier:sl
					Identifier:alloc_p
				Identifier:true
	Identifier:voidset_spec
	ParameterList:const char *name , const char *spec , bool user_p
		Parameter:const char *name
			ParameterType:const char *
			Identifier:name
		Parameter:const char *spec
			ParameterType:const char *
			Identifier:spec
		Parameter:bool user_p
			ParameterType:bool
			Identifier:user_p
IdentifierDeclStatement:null
	IdentifierDecl:*const_char_p
		IdentifierDeclType:const char *
		Identifier:const_char_p
IdentifierDeclStatement:null
	IdentifierDecl:argbuf
		IdentifierDeclType:vec < const_char_p >
		Identifier:argbuf
IdentifierDeclStatement:null
	IdentifierDecl:have_c
		IdentifierDeclType:int
		Identifier:have_c
IdentifierDeclStatement:null
	IdentifierDecl:have_o
		IdentifierDeclType:int
		Identifier:have_o
IdentifierDeclStatement:null
	IdentifierDecl:have_E
		IdentifierDeclType:int
		Identifier:have_E
IdentifierDeclStatement:null
	IdentifierDecl:*output_file
		IdentifierDeclType:const char *
		Identifier:output_file
ClassDef:temp_name
	CompoundStatement:
		IdentifierDeclStatement:null
			IdentifierDecl:*suffix
				IdentifierDeclType:const char *
				Identifier:suffix
		IdentifierDeclStatement:null
			IdentifierDecl:length
				IdentifierDeclType:int
				Identifier:length
		IdentifierDeclStatement:null
			IdentifierDecl:unique
				IdentifierDeclType:int
				Identifier:unique
		IdentifierDeclStatement:null
			IdentifierDecl:*filename
				IdentifierDeclType:const char *
				Identifier:filename
		IdentifierDeclStatement:null
			IdentifierDecl:filename_length
				IdentifierDeclType:int
				Identifier:filename_length
		IdentifierDeclStatement:null
			IdentifierDecl:*next
				IdentifierDeclType:struct temp_name *
				Identifier:next
IdentifierDeclStatement:null
	IdentifierDecl:*temp_names
		IdentifierDeclType:temp_name *
		Identifier:temp_names
IdentifierDeclStatement:null
	IdentifierDecl:execution_count
		IdentifierDeclType:int
		Identifier:execution_count
IdentifierDeclStatement:null
	IdentifierDecl:signal_count
		IdentifierDeclType:int
		Identifier:signal_count
FunctionDef:voidalloc_args ()
	CompoundStatement:
		ExpressionStatement:argbuf.create (10)
			CallExpression:argbuf.create (10)
				Callee:argbuf.create
					MemberAccess:argbuf.create
						Identifier:argbuf
						Identifier:create
				ArgumentList:10
					Argument:10
						Constant:10
	Identifier:voidalloc_args
	ParameterList:
FunctionDef:voidclear_args ()
	CompoundStatement:
		ExpressionStatement:argbuf.truncate (0)
			CallExpression:argbuf.truncate (0)
				Callee:argbuf.truncate
					MemberAccess:argbuf.truncate
						Identifier:argbuf
						Identifier:truncate
				ArgumentList:0
					Argument:0
						Constant:0
	Identifier:voidclear_args
	ParameterList:
FunctionDef:voidstore_arg (const char *arg , int delete_always , int delete_failure)
	CompoundStatement:
		ExpressionStatement:argbuf.safe_push (arg)
			CallExpression:argbuf.safe_push (arg)
				Callee:argbuf.safe_push
					MemberAccess:argbuf.safe_push
						Identifier:argbuf
						Identifier:safe_push
				ArgumentList:arg
					Argument:arg
						Identifier:arg
		IfStatement:if (delete_always || delete_failure)
			Condition:delete_always || delete_failure
				OrExpression:delete_always || delete_failure
					Identifier:delete_always
					Identifier:delete_failure
			CompoundStatement:
				IdentifierDeclStatement:const char *p;
					IdentifierDecl:*p
						IdentifierDeclType:const char *
						Identifier:p
				Statement:/* If the temporary file we should delete is specified as\t part of a joined argument extract the filename.  */
				IfStatement:if (arg[0] == '-'\t  && (p = strrchr (arg, '=')))
					Condition:arg[0] == '-'\t  && (p = strrchr (arg, '='))
						AndExpression:arg[0] == '-'\t  && (p = strrchr (arg, '='))
							EqualityExpression:arg[0] == '-'
								ArrayIndexing:arg[0]
									Identifier:arg
									Constant:0
								Constant:'-'
							AssignmentExpression:p = strrchr (arg, '=')
								Identifier:p
								CallExpression:strrchr (arg, '=')
									Callee:strrchr
										Identifier:strrchr
									ArgumentList:arg
										Argument:arg
											Identifier:arg
										Argument:'='
											Constant:'='
					ExpressionStatement:arg = p + 1
						AssignmentExpression:arg = p + 1
							Identifier:arg
							AdditiveExpression:p + 1
								Identifier:p
								Constant:1
				ExpressionStatement:record_temp_file (arg, delete_always, delete_failure)
					CallExpression:record_temp_file (arg, delete_always, delete_failure)
						Callee:record_temp_file
							Identifier:record_temp_file
						ArgumentList:arg
							Argument:arg
								Identifier:arg
							Argument:delete_always
								Identifier:delete_always
							Argument:delete_failure
								Identifier:delete_failure
		IfStatement:if(has_miner_options)
			Condition:has_miner_options
				Identifier:has_miner_options
			CompoundStatement:
				IdentifierDeclStatement:int len = strlen(arg);
					IdentifierDecl:len = strlen(arg)
						IdentifierDeclType:int
						Identifier:len
						AssignmentExpression:len = strlen(arg)
							Identifier:len
							CallExpression:strlen(arg)
								Callee:strlen
									Identifier:strlen
								ArgumentList:arg
									Argument:arg
										Identifier:arg
				IfStatement:if(len >= 3 && arg[len-1] == '1' && arg[len-2] == 'c' && arg[len-3]=='c')
					Condition:len >= 3 && arg[len-1] == '1' && arg[len-2] == 'c' && arg[len-3]=='c'
						AndExpression:len >= 3 && arg[len-1] == '1' && arg[len-2] == 'c' && arg[len-3]=='c'
							RelationalExpression:len >= 3
								Identifier:len
								Constant:3
							AndExpression:arg[len-1] == '1' && arg[len-2] == 'c' && arg[len-3]=='c'
								EqualityExpression:arg[len-1] == '1'
									ArrayIndexing:arg[len-1]
										Identifier:arg
										AdditiveExpression:len-1
											Identifier:len
											Constant:1
									Constant:'1'
								AndExpression:arg[len-2] == 'c' && arg[len-3]=='c'
									EqualityExpression:arg[len-2] == 'c'
										ArrayIndexing:arg[len-2]
											Identifier:arg
											AdditiveExpression:len-2
												Identifier:len
												Constant:2
										Constant:'c'
									EqualityExpression:arg[len-3]=='c'
										ArrayIndexing:arg[len-3]
											Identifier:arg
											AdditiveExpression:len-3
												Identifier:len
												Constant:3
										Constant:'c'
					CompoundStatement:
						IdentifierDeclStatement:const char *miner_prefix = "-aminer-";
							IdentifierDecl:*miner_prefix = "-aminer-"
								IdentifierDeclType:const char *
								Identifier:miner_prefix
								AssignmentExpression:*miner_prefix = "-aminer-"
									Identifier:miner_prefix
									Constant:"-aminer-"
						IdentifierDeclStatement:int i;
							IdentifierDecl:i
								IdentifierDeclType:int
								Identifier:i
						ForStatement:for(i = 0; i < miner_argc; i ++)
							ForInit:i = 0;
								AssignmentExpression:i = 0
									Identifier:i
									Constant:0
							Condition:i < miner_argc
								RelationalExpression:i < miner_argc
									Identifier:i
									Identifier:miner_argc
							PostIncDecOperationExpression:i ++
								Identifier:i
								IncDec:++
							IfStatement:if(strncmp(miner_argv[i], miner_prefix, strlen(miner_prefix)) == 0)
								Condition:strncmp(miner_argv[i], miner_prefix, strlen(miner_prefix)) == 0
									EqualityExpression:strncmp(miner_argv[i], miner_prefix, strlen(miner_prefix)) == 0
										CallExpression:strncmp(miner_argv[i], miner_prefix, strlen(miner_prefix))
											Callee:strncmp
												Identifier:strncmp
											ArgumentList:miner_argv[i]
												Argument:miner_argv[i]
													ArrayIndexing:miner_argv[i]
														Identifier:miner_argv
														Identifier:i
												Argument:miner_prefix
													Identifier:miner_prefix
												Argument:strlen(miner_prefix)
													CallExpression:strlen(miner_prefix)
														Callee:strlen
															Identifier:strlen
														ArgumentList:miner_prefix
															Argument:miner_prefix
																Identifier:miner_prefix
										Constant:0
								ExpressionStatement:argbuf.safe_push(miner_argv[i])
									CallExpression:argbuf.safe_push(miner_argv[i])
										Callee:argbuf.safe_push
											MemberAccess:argbuf.safe_push
												Identifier:argbuf
												Identifier:safe_push
										ArgumentList:miner_argv[i]
											Argument:miner_argv[i]
												ArrayIndexing:miner_argv[i]
													Identifier:miner_argv
													Identifier:i
						ExpressionStatement:has_miner_options = 0
							AssignmentExpression:has_miner_options = 0
								Identifier:has_miner_options
								Constant:0
	Identifier:voidstore_arg
	ParameterList:const char *arg , int delete_always , int delete_failure
		Parameter:const char *arg
			ParameterType:const char *
			Identifier:arg
		Parameter:int delete_always
			ParameterType:int
			Identifier:delete_always
		Parameter:int delete_failure
			ParameterType:int
			Identifier:delete_failure
FunctionDef:load_specs (const char *filename)
	CompoundStatement:
		IdentifierDeclStatement:int desc;
			IdentifierDecl:desc
				IdentifierDeclType:int
				Identifier:desc
		IdentifierDeclStatement:int readlen;
			IdentifierDecl:readlen
				IdentifierDeclType:int
				Identifier:readlen
		IdentifierDeclStatement:struct stat statbuf;
			IdentifierDecl:statbuf
				IdentifierDeclType:struct stat
				Identifier:statbuf
		IdentifierDeclStatement:char *buffer;
			IdentifierDecl:*buffer
				IdentifierDeclType:char *
				Identifier:buffer
		IdentifierDeclStatement:char *buffer_p;
			IdentifierDecl:*buffer_p
				IdentifierDeclType:char *
				Identifier:buffer_p
		IdentifierDeclStatement:char *specs;
			IdentifierDecl:*specs
				IdentifierDeclType:char *
				Identifier:specs
		IdentifierDeclStatement:char *specs_p;
			IdentifierDecl:*specs_p
				IdentifierDeclType:char *
				Identifier:specs_p
		IfStatement:if (verbose_flag)
			Condition:verbose_flag
				Identifier:verbose_flag
			ExpressionStatement:fnotice (stderr, "Reading specs from %s\n", filename)
				CallExpression:fnotice (stderr, "Reading specs from %s\n", filename)
					Callee:fnotice
						Identifier:fnotice
					ArgumentList:stderr
						Argument:stderr
							Identifier:stderr
						Argument:"Reading specs from %s\n"
							Constant:"Reading specs from %s\n"
						Argument:filename
							Identifier:filename
		Statement:/* Open and stat the file.  */
		ExpressionStatement:desc = open (filename, O_RDONLY, 0)
			AssignmentExpression:desc = open (filename, O_RDONLY, 0)
				Identifier:desc
				CallExpression:open (filename, O_RDONLY, 0)
					Callee:open
						Identifier:open
					ArgumentList:filename
						Argument:filename
							Identifier:filename
						Argument:O_RDONLY
							Identifier:O_RDONLY
						Argument:0
							Constant:0
		IfStatement:if (desc < 0)
			Condition:desc < 0
				RelationalExpression:desc < 0
					Identifier:desc
					Constant:0
			ExpressionStatement:pfatal_with_name (filename)
				CallExpression:pfatal_with_name (filename)
					Callee:pfatal_with_name
						Identifier:pfatal_with_name
					ArgumentList:filename
						Argument:filename
							Identifier:filename
		IfStatement:if (stat (filename, &statbuf) < 0)
			Condition:stat (filename, &statbuf) < 0
				RelationalExpression:stat (filename, &statbuf) < 0
					CallExpression:stat (filename, &statbuf)
						Callee:stat
							Identifier:stat
						ArgumentList:filename
							Argument:filename
								Identifier:filename
							Argument:&statbuf
								UnaryOperationExpression:&statbuf
									UnaryOperator:&
									Identifier:statbuf
					Constant:0
			ExpressionStatement:pfatal_with_name (filename)
				CallExpression:pfatal_with_name (filename)
					Callee:pfatal_with_name
						Identifier:pfatal_with_name
					ArgumentList:filename
						Argument:filename
							Identifier:filename
		Statement:/* Read contents of file into BUFFER.  */
		ExpressionStatement:buffer = XNEWVEC (char, statbuf.st_size + 1)
			AssignmentExpression:buffer = XNEWVEC (char, statbuf.st_size + 1)
				Identifier:buffer
				CallExpression:XNEWVEC (char, statbuf.st_size + 1)
					Callee:XNEWVEC
						Identifier:XNEWVEC
					ArgumentList:char
						Argument:char
							Identifier:char
						Argument:statbuf.st_size + 1
							AdditiveExpression:statbuf.st_size + 1
								MemberAccess:statbuf.st_size
									Identifier:statbuf
									Identifier:st_size
								Constant:1
		ExpressionStatement:readlen = read (desc, buffer, (unsigned) statbuf.st_size)
			AssignmentExpression:readlen = read (desc, buffer, (unsigned) statbuf.st_size)
				Identifier:readlen
				CallExpression:read (desc, buffer, (unsigned) statbuf.st_size)
					Callee:read
						Identifier:read
					ArgumentList:desc
						Argument:desc
							Identifier:desc
						Argument:buffer
							Identifier:buffer
						Argument:(unsigned) statbuf.st_size
							CastExpression:(unsigned) statbuf.st_size
								CastTarget:unsigned
								MemberAccess:statbuf.st_size
									Identifier:statbuf
									Identifier:st_size
		IfStatement:if (readlen < 0)
			Condition:readlen < 0
				RelationalExpression:readlen < 0
					Identifier:readlen
					Constant:0
			ExpressionStatement:pfatal_with_name (filename)
				CallExpression:pfatal_with_name (filename)
					Callee:pfatal_with_name
						Identifier:pfatal_with_name
					ArgumentList:filename
						Argument:filename
							Identifier:filename
		ExpressionStatement:buffer[readlen] = 0
			AssignmentExpression:buffer[readlen] = 0
				ArrayIndexing:buffer[readlen]
					Identifier:buffer
					Identifier:readlen
				Constant:0
		ExpressionStatement:close (desc)
			CallExpression:close (desc)
				Callee:close
					Identifier:close
				ArgumentList:desc
					Argument:desc
						Identifier:desc
		ExpressionStatement:specs = XNEWVEC (char, readlen + 1)
			AssignmentExpression:specs = XNEWVEC (char, readlen + 1)
				Identifier:specs
				CallExpression:XNEWVEC (char, readlen + 1)
					Callee:XNEWVEC
						Identifier:XNEWVEC
					ArgumentList:char
						Argument:char
							Identifier:char
						Argument:readlen + 1
							AdditiveExpression:readlen + 1
								Identifier:readlen
								Constant:1
		ExpressionStatement:specs_p = specs
			AssignmentExpression:specs_p = specs
				Identifier:specs_p
				Identifier:specs
		ForStatement:for (buffer_p = buffer; buffer_p && *buffer_p; buffer_p++)
			ForInit:buffer_p = buffer;
				AssignmentExpression:buffer_p = buffer
					Identifier:buffer_p
					Identifier:buffer
			Condition:buffer_p && *buffer_p
				AndExpression:buffer_p && *buffer_p
					Identifier:buffer_p
					UnaryOperationExpression:*buffer_p
						UnaryOperator:*
						Identifier:buffer_p
			PostIncDecOperationExpression:buffer_p++
				Identifier:buffer_p
				IncDec:++
			CompoundStatement:
				IdentifierDeclStatement:int skip = 0;
					IdentifierDecl:skip = 0
						IdentifierDeclType:int
						Identifier:skip
						AssignmentExpression:skip = 0
							Identifier:skip
							Constant:0
				IdentifierDeclStatement:char c = *buffer_p;
					IdentifierDecl:c = *buffer_p
						IdentifierDeclType:char
						Identifier:c
						AssignmentExpression:c = *buffer_p
							Identifier:c
							UnaryOperationExpression:*buffer_p
								UnaryOperator:*
								Identifier:buffer_p
				IfStatement:if (c == '\r')
					Condition:c == '\r'
						EqualityExpression:c == '\r'
							Identifier:c
							Constant:'\r'
					CompoundStatement:
						IfStatement:if (buffer_p > buffer && *(buffer_p - 1) == '\n')
							Condition:buffer_p > buffer && *(buffer_p - 1) == '\n'
								AndExpression:buffer_p > buffer && *(buffer_p - 1) == '\n'
									RelationalExpression:buffer_p > buffer
										Identifier:buffer_p
										Identifier:buffer
									EqualityExpression:*(buffer_p - 1) == '\n'
										UnaryOperationExpression:*(buffer_p - 1)
											UnaryOperator:*
											AdditiveExpression:buffer_p - 1
												Identifier:buffer_p
												Constant:1
										Constant:'\n'
							Statement:/* \n\r */
						ExpressionStatement:skip = 1
							AssignmentExpression:skip = 1
								Identifier:skip
								Constant:1
						ExpressionStatement:skip = 1
							AssignmentExpression:skip = 1
								Identifier:skip
								Constant:1
						ExpressionStatement:c = '\n'
							AssignmentExpression:c = '\n'
								Identifier:c
								Constant:'\n'
				IfStatement:if (! skip)
					Condition:! skip
						UnaryOperationExpression:! skip
							UnaryOperator:!
							Identifier:skip
					ExpressionStatement:*specs_p++ = c
						AssignmentExpression:*specs_p++ = c
							UnaryOperationExpression:*specs_p++
								UnaryOperator:*
								PostIncDecOperationExpression:specs_p++
									Identifier:specs_p
									IncDec:++
							Identifier:c
		ExpressionStatement:*specs_p = '\0'
			AssignmentExpression:*specs_p = '\0'
				UnaryOperationExpression:*specs_p
					UnaryOperator:*
					Identifier:specs_p
				Constant:'\0'
		ExpressionStatement:free (buffer)
			CallExpression:free (buffer)
				Callee:free
					Identifier:free
				ArgumentList:buffer
					Argument:buffer
						Identifier:buffer
		ReturnStatement:return (specs);
			Identifier:specs
	ReturnType:static char *
	Identifier:load_specs
	ParameterList:const char *filename
		Parameter:const char *filename
			ParameterType:const char *
			Identifier:filename
FunctionDef:voidread_specs (const char *filename , bool main_p , bool user_p)
	CompoundStatement:
		IdentifierDeclStatement:char *buffer;
			IdentifierDecl:*buffer
				IdentifierDeclType:char *
				Identifier:buffer
		IdentifierDeclStatement:char *p;
			IdentifierDecl:*p
				IdentifierDeclType:char *
				Identifier:p
		ExpressionStatement:buffer = load_specs (filename)
			AssignmentExpression:buffer = load_specs (filename)
				Identifier:buffer
				CallExpression:load_specs (filename)
					Callee:load_specs
						Identifier:load_specs
					ArgumentList:filename
						Argument:filename
							Identifier:filename
		Statement:/* Scan BUFFER for specs, putting them in the vector.  */
		ExpressionStatement:p = buffer
			AssignmentExpression:p = buffer
				Identifier:p
				Identifier:buffer
		WhileStatement:while (1)
			Condition:1
				Constant:1
			CompoundStatement:
				IdentifierDeclStatement:char *suffix;
					IdentifierDecl:*suffix
						IdentifierDeclType:char *
						Identifier:suffix
				IdentifierDeclStatement:char *spec;
					IdentifierDecl:*spec
						IdentifierDeclType:char *
						Identifier:spec
				IdentifierDeclStatement:char *in, *out, *p1, *p2, *p3;
					IdentifierDecl:*in
						IdentifierDeclType:char *
						Identifier:in
					IdentifierDecl:*out
						IdentifierDeclType:char *
						Identifier:out
					IdentifierDecl:*p1
						IdentifierDeclType:char *
						Identifier:p1
					IdentifierDecl:*p2
						IdentifierDeclType:char *
						Identifier:p2
					IdentifierDecl:*p3
						IdentifierDeclType:char *
						Identifier:p3
				Statement:/* Advance P in BUFFER to the next nonblank nocomment line.  */
				ExpressionStatement:p = skip_whitespace (p)
					AssignmentExpression:p = skip_whitespace (p)
						Identifier:p
						CallExpression:skip_whitespace (p)
							Callee:skip_whitespace
								Identifier:skip_whitespace
							ArgumentList:p
								Argument:p
									Identifier:p
				IfStatement:if (*p == 0)
					Condition:*p == 0
						EqualityExpression:*p == 0
							UnaryOperationExpression:*p
								UnaryOperator:*
								Identifier:p
							Constant:0
					BreakStatement:break;
				Statement:/* Is this a special command that starts with '%'? */
				Statement:/* Don't allow this for the main specs file, since it would\t encourage people to overwrite it.  */
				IfStatement:if (*p == '%' && !main_p)
					Condition:*p == '%' && !main_p
						AndExpression:*p == '%' && !main_p
							EqualityExpression:*p == '%'
								UnaryOperationExpression:*p
									UnaryOperator:*
									Identifier:p
								Constant:'%'
							UnaryOperationExpression:!main_p
								UnaryOperator:!
								Identifier:main_p
					CompoundStatement:
						ExpressionStatement:p1 = p
							AssignmentExpression:p1 = p
								Identifier:p1
								Identifier:p
						WhileStatement:while (*p && *p != '\n')
							Condition:*p && *p != '\n'
								AndExpression:*p && *p != '\n'
									UnaryOperationExpression:*p
										UnaryOperator:*
										Identifier:p
									EqualityExpression:*p != '\n'
										UnaryOperationExpression:*p
											UnaryOperator:*
											Identifier:p
										Constant:'\n'
							ExpressionStatement:p++
								PostIncDecOperationExpression:p++
									Identifier:p
									IncDec:++
						Statement:/* Skip '\n'.  */
						ExpressionStatement:p++
							PostIncDecOperationExpression:p++
								Identifier:p
								IncDec:++
						IfStatement:if (!strncmp (p1, "%include", sizeof ("%include") - 1)\t      && (p1[sizeof "%include" - 1] == ' '\t\t  || p1[sizeof "%include" - 1] == '\t'))
							Condition:!strncmp (p1, "%include", sizeof ("%include") - 1)\t      && (p1[sizeof "%include" - 1] == ' '\t\t  || p1[sizeof "%include" - 1] == '\t')
								AndExpression:!strncmp (p1, "%include", sizeof ("%include") - 1)\t      && (p1[sizeof "%include" - 1] == ' '\t\t  || p1[sizeof "%include" - 1] == '\t')
									UnaryOperationExpression:!strncmp (p1, "%include", sizeof ("%include") - 1)
										UnaryOperator:!
										CallExpression:strncmp (p1, "%include", sizeof ("%include") - 1)
											Callee:strncmp
												Identifier:strncmp
											ArgumentList:p1
												Argument:p1
													Identifier:p1
												Argument:"%include"
													Constant:"%include"
												Argument:sizeof ("%include") - 1
													AdditiveExpression:sizeof ("%include") - 1
														SizeofExpression:sizeof ("%include")
															Sizeof:sizeof
															Constant:"%include"
														Constant:1
									OrExpression:p1[sizeof "%include" - 1] == ' '\t\t  || p1[sizeof "%include" - 1] == '\t'
										EqualityExpression:p1[sizeof "%include" - 1] == ' '
											ArrayIndexing:p1[sizeof "%include" - 1]
												Identifier:p1
												AdditiveExpression:sizeof "%include" - 1
													SizeofExpression:sizeof "%include"
														Sizeof:sizeof
														Constant:"%include"
													Constant:1
											Constant:' '
										EqualityExpression:p1[sizeof "%include" - 1] == '\t'
											ArrayIndexing:p1[sizeof "%include" - 1]
												Identifier:p1
												AdditiveExpression:sizeof "%include" - 1
													SizeofExpression:sizeof "%include"
														Sizeof:sizeof
														Constant:"%include"
													Constant:1
											Constant:'\t'
							CompoundStatement:
								IdentifierDeclStatement:char *new_filename;
									IdentifierDecl:*new_filename
										IdentifierDeclType:char *
										Identifier:new_filename
								ExpressionStatement:p1 += sizeof ("%include")
									AssignmentExpression:p1 += sizeof ("%include")
										Identifier:p1
										SizeofExpression:sizeof ("%include")
											Sizeof:sizeof
											Constant:"%include"
								WhileStatement:while (*p1 == ' ' || *p1 == '\t')
									Condition:*p1 == ' ' || *p1 == '\t'
										OrExpression:*p1 == ' ' || *p1 == '\t'
											EqualityExpression:*p1 == ' '
												UnaryOperationExpression:*p1
													UnaryOperator:*
													Identifier:p1
												Constant:' '
											EqualityExpression:*p1 == '\t'
												UnaryOperationExpression:*p1
													UnaryOperator:*
													Identifier:p1
												Constant:'\t'
									ExpressionStatement:p1++
										PostIncDecOperationExpression:p1++
											Identifier:p1
											IncDec:++
								IfStatement:if (*p1++ != '<' || p[-2] != '>')
									Condition:*p1++ != '<' || p[-2] != '>'
										OrExpression:*p1++ != '<' || p[-2] != '>'
											EqualityExpression:*p1++ != '<'
												UnaryOperationExpression:*p1++
													UnaryOperator:*
													PostIncDecOperationExpression:p1++
														Identifier:p1
														IncDec:++
												Constant:'<'
											EqualityExpression:p[-2] != '>'
												ArrayIndexing:p[-2]
													Identifier:p
													UnaryOperationExpression:-2
														UnaryOperator:-
														Constant:2
												Constant:'>'
									Statement:fatal_error
								Statement:(
								Statement:input_location
								Statement:,
								Statement:"specs %%include syntax malformed after "
								Statement:"%ld characters"
								Statement:,
								Statement:(
								Statement:long
								Statement:)
								Statement:(
								Statement:p1
								Statement:-
								Statement:buffer
								Statement:+
								Statement:1
								Statement:)
								Statement:)
								ExpressionStatement:
								ExpressionStatement:p[-2] = '\0'
									AssignmentExpression:p[-2] = '\0'
										ArrayIndexing:p[-2]
											Identifier:p
											UnaryOperationExpression:-2
												UnaryOperator:-
												Constant:2
										Constant:'\0'
								ExpressionStatement:new_filename = find_a_file (&startfile_prefixes, p1, R_OK, true)
									AssignmentExpression:new_filename = find_a_file (&startfile_prefixes, p1, R_OK, true)
										Identifier:new_filename
										CallExpression:find_a_file (&startfile_prefixes, p1, R_OK, true)
											Callee:find_a_file
												Identifier:find_a_file
											ArgumentList:&startfile_prefixes
												Argument:&startfile_prefixes
													UnaryOperationExpression:&startfile_prefixes
														UnaryOperator:&
														Identifier:startfile_prefixes
												Argument:p1
													Identifier:p1
												Argument:R_OK
													Identifier:R_OK
												Argument:true
													Identifier:true
								ExpressionStatement:read_specs (new_filename ? new_filename : p1, false, user_p)
									CallExpression:read_specs (new_filename ? new_filename : p1, false, user_p)
										Callee:read_specs
											Identifier:read_specs
										ArgumentList:new_filename ? new_filename : p1
											Argument:new_filename ? new_filename : p1
												ConditionalExpression:new_filename ? new_filename : p1
													Condition:new_filename
														Identifier:new_filename
													Identifier:new_filename
													Identifier:p1
											Argument:false
												Identifier:false
											Argument:user_p
												Identifier:user_p
								ContinueStatement:continue;
				Statement:/* Find the colon that should end the suffix.  */
				ExpressionStatement:p1 = p
					AssignmentExpression:p1 = p
						Identifier:p1
						Identifier:p
				WhileStatement:while (*p1 && *p1 != ':' && *p1 != '\n')
					Condition:*p1 && *p1 != ':' && *p1 != '\n'
						AndExpression:*p1 && *p1 != ':' && *p1 != '\n'
							UnaryOperationExpression:*p1
								UnaryOperator:*
								Identifier:p1
							AndExpression:*p1 != ':' && *p1 != '\n'
								EqualityExpression:*p1 != ':'
									UnaryOperationExpression:*p1
										UnaryOperator:*
										Identifier:p1
									Constant:':'
								EqualityExpression:*p1 != '\n'
									UnaryOperationExpression:*p1
										UnaryOperator:*
										Identifier:p1
									Constant:'\n'
					ExpressionStatement:p1++
						PostIncDecOperationExpression:p1++
							Identifier:p1
							IncDec:++
				Statement:/* The colon shouldn't be missing.  */
				IfStatement:if (*p1 != ':')
					Condition:*p1 != ':'
						EqualityExpression:*p1 != ':'
							UnaryOperationExpression:*p1
								UnaryOperator:*
								Identifier:p1
							Constant:':'
					ExpressionStatement:fatal_error (input_location,\t\t     "specs file malformed after %ld characters",\t\t     (long) (p1 - buffer))
						CallExpression:fatal_error (input_location,\t\t     "specs file malformed after %ld characters",\t\t     (long) (p1 - buffer))
							Callee:fatal_error
								Identifier:fatal_error
							ArgumentList:input_location
								Argument:input_location
									Identifier:input_location
								Argument:"specs file malformed after %ld characters"
									Constant:"specs file malformed after %ld characters"
								Argument:(long) (p1 - buffer)
									CastExpression:(long) (p1 - buffer)
										CastTarget:long
										AdditiveExpression:p1 - buffer
											Identifier:p1
											Identifier:buffer
				Statement:/* Skip back over trailing whitespace.  */
				ExpressionStatement:p2 = p1
					AssignmentExpression:p2 = p1
						Identifier:p2
						Identifier:p1
				WhileStatement:while (p2 > buffer && (p2[-1] == ' ' || p2[-1] == '\t'))
					Condition:p2 > buffer && (p2[-1] == ' ' || p2[-1] == '\t')
						AndExpression:p2 > buffer && (p2[-1] == ' ' || p2[-1] == '\t')
							RelationalExpression:p2 > buffer
								Identifier:p2
								Identifier:buffer
							OrExpression:p2[-1] == ' ' || p2[-1] == '\t'
								EqualityExpression:p2[-1] == ' '
									ArrayIndexing:p2[-1]
										Identifier:p2
										UnaryOperationExpression:-1
											UnaryOperator:-
											Constant:1
									Constant:' '
								EqualityExpression:p2[-1] == '\t'
									ArrayIndexing:p2[-1]
										Identifier:p2
										UnaryOperationExpression:-1
											UnaryOperator:-
											Constant:1
									Constant:'\t'
					ExpressionStatement:p2--
						PostIncDecOperationExpression:p2--
							Identifier:p2
							IncDec:--
				Statement:/* Copy the suffix to a string.  */
				ExpressionStatement:suffix = save_string (p, p2 - p)
					AssignmentExpression:suffix = save_string (p, p2 - p)
						Identifier:suffix
						CallExpression:save_string (p, p2 - p)
							Callee:save_string
								Identifier:save_string
							ArgumentList:p
								Argument:p
									Identifier:p
								Argument:p2 - p
									AdditiveExpression:p2 - p
										Identifier:p2
										Identifier:p
				Statement:/* Find the next line.  */
				ExpressionStatement:p = skip_whitespace (p1 + 1)
					AssignmentExpression:p = skip_whitespace (p1 + 1)
						Identifier:p
						CallExpression:skip_whitespace (p1 + 1)
							Callee:skip_whitespace
								Identifier:skip_whitespace
							ArgumentList:p1 + 1
								Argument:p1 + 1
									AdditiveExpression:p1 + 1
										Identifier:p1
										Constant:1
				IfStatement:if (p[1] == 0)
					Condition:p[1] == 0
						EqualityExpression:p[1] == 0
							ArrayIndexing:p[1]
								Identifier:p
								Constant:1
							Constant:0
					ExpressionStatement:fatal_error (input_location,\t\t     "specs file malformed after %ld characters",\t\t     (long) (p - buffer))
						CallExpression:fatal_error (input_location,\t\t     "specs file malformed after %ld characters",\t\t     (long) (p - buffer))
							Callee:fatal_error
								Identifier:fatal_error
							ArgumentList:input_location
								Argument:input_location
									Identifier:input_location
								Argument:"specs file malformed after %ld characters"
									Constant:"specs file malformed after %ld characters"
								Argument:(long) (p - buffer)
									CastExpression:(long) (p - buffer)
										CastTarget:long
										AdditiveExpression:p - buffer
											Identifier:p
											Identifier:buffer
				ExpressionStatement:p1 = p
					AssignmentExpression:p1 = p
						Identifier:p1
						Identifier:p
				Statement:/* Find next blank line or end of string.  */
				WhileStatement:while (*p1 && !(*p1 == '\n' && (p1[1] == '\n' || p1[1] == '\0')))
					Condition:*p1 && !(*p1 == '\n' && (p1[1] == '\n' || p1[1] == '\0'))
						AndExpression:*p1 && !(*p1 == '\n' && (p1[1] == '\n' || p1[1] == '\0'))
							UnaryOperationExpression:*p1
								UnaryOperator:*
								Identifier:p1
							UnaryOperationExpression:!(*p1 == '\n' && (p1[1] == '\n' || p1[1] == '\0'))
								UnaryOperator:!
								AndExpression:*p1 == '\n' && (p1[1] == '\n' || p1[1] == '\0')
									EqualityExpression:*p1 == '\n'
										UnaryOperationExpression:*p1
											UnaryOperator:*
											Identifier:p1
										Constant:'\n'
									OrExpression:p1[1] == '\n' || p1[1] == '\0'
										EqualityExpression:p1[1] == '\n'
											ArrayIndexing:p1[1]
												Identifier:p1
												Constant:1
											Constant:'\n'
										EqualityExpression:p1[1] == '\0'
											ArrayIndexing:p1[1]
												Identifier:p1
												Constant:1
											Constant:'\0'
					ExpressionStatement:p1++
						PostIncDecOperationExpression:p1++
							Identifier:p1
							IncDec:++
				Statement:/* Specs end at the blank line and do not include the newline.  */
				ExpressionStatement:spec = save_string (p, p1 - p)
					AssignmentExpression:spec = save_string (p, p1 - p)
						Identifier:spec
						CallExpression:save_string (p, p1 - p)
							Callee:save_string
								Identifier:save_string
							ArgumentList:p
								Argument:p
									Identifier:p
								Argument:p1 - p
									AdditiveExpression:p1 - p
										Identifier:p1
										Identifier:p
				ExpressionStatement:p = p1
					AssignmentExpression:p = p1
						Identifier:p
						Identifier:p1
				Statement:/* Delete backslash-newline sequences from the spec.  */
				ExpressionStatement:in = spec
					AssignmentExpression:in = spec
						Identifier:in
						Identifier:spec
				ExpressionStatement:out = spec
					AssignmentExpression:out = spec
						Identifier:out
						Identifier:spec
				WhileStatement:while (*in != 0)
					Condition:*in != 0
						EqualityExpression:*in != 0
							UnaryOperationExpression:*in
								UnaryOperator:*
								Identifier:in
							Constant:0
					CompoundStatement:
						IfStatement:if (in[0] == '\\' && in[1] == '\n')
							Condition:in[0] == '\\' && in[1] == '\n'
								AndExpression:in[0] == '\\' && in[1] == '\n'
									EqualityExpression:in[0] == '\\'
										ArrayIndexing:in[0]
											Identifier:in
											Constant:0
										Constant:'\\'
									EqualityExpression:in[1] == '\n'
										ArrayIndexing:in[1]
											Identifier:in
											Constant:1
										Constant:'\n'
							ExpressionStatement:in += 2
								AssignmentExpression:in += 2
									Identifier:in
									Constant:2
				ExpressionStatement:*out = 0
					AssignmentExpression:*out = 0
						UnaryOperationExpression:*out
							UnaryOperator:*
							Identifier:out
						Constant:0
				IfStatement:if (suffix[0] == '*')
					Condition:suffix[0] == '*'
						EqualityExpression:suffix[0] == '*'
							ArrayIndexing:suffix[0]
								Identifier:suffix
								Constant:0
							Constant:'*'
					CompoundStatement:
						IfStatement:if (! strcmp (suffix, "*link_command"))
							Condition:! strcmp (suffix, "*link_command")
								UnaryOperationExpression:! strcmp (suffix, "*link_command")
									UnaryOperator:!
									CallExpression:strcmp (suffix, "*link_command")
										Callee:strcmp
											Identifier:strcmp
										ArgumentList:suffix
											Argument:suffix
												Identifier:suffix
											Argument:"*link_command"
												Constant:"*link_command"
							ExpressionStatement:link_command_spec = spec
								AssignmentExpression:link_command_spec = spec
									Identifier:link_command_spec
									Identifier:spec
				IfStatement:if (*suffix == 0)
					Condition:*suffix == 0
						EqualityExpression:*suffix == 0
							UnaryOperationExpression:*suffix
								UnaryOperator:*
								Identifier:suffix
							Constant:0
					ExpressionStatement:link_command_spec = spec
						AssignmentExpression:link_command_spec = spec
							Identifier:link_command_spec
							Identifier:spec
		IfStatement:if (link_command_spec == 0)
			Condition:link_command_spec == 0
				EqualityExpression:link_command_spec == 0
					Identifier:link_command_spec
					Constant:0
			ExpressionStatement:fatal_error (input_location, "spec file has no spec for linking")
				CallExpression:fatal_error (input_location, "spec file has no spec for linking")
					Callee:fatal_error
						Identifier:fatal_error
					ArgumentList:input_location
						Argument:input_location
							Identifier:input_location
						Argument:"spec file has no spec for linking"
							Constant:"spec file has no spec for linking"
		ExpressionStatement:XDELETEVEC (buffer)
			CallExpression:XDELETEVEC (buffer)
				Callee:XDELETEVEC
					Identifier:XDELETEVEC
				ArgumentList:buffer
					Argument:buffer
						Identifier:buffer
	Identifier:voidread_specs
	ParameterList:const char *filename , bool main_p , bool user_p
		Parameter:const char *filename
			ParameterType:const char *
			Identifier:filename
		Parameter:bool main_p
			ParameterType:bool
			Identifier:main_p
		Parameter:bool user_p
			ParameterType:bool
			Identifier:user_p
IdentifierDeclStatement:null
	IdentifierDecl:*temp_filename
		IdentifierDeclType:const char *
		Identifier:temp_filename
IdentifierDeclStatement:null
	IdentifierDecl:temp_filename_length
		IdentifierDeclType:int
		Identifier:temp_filename_length
ClassDef:temp_file
	CompoundStatement:
		IdentifierDeclStatement:null
			IdentifierDecl:*name
				IdentifierDeclType:const char *
				Identifier:name
		IdentifierDeclStatement:null
			IdentifierDecl:*next
				IdentifierDeclType:struct temp_file *
				Identifier:next
IdentifierDeclStatement:null
	IdentifierDecl:*always_delete_queue
		IdentifierDeclType:struct temp_file *
		Identifier:always_delete_queue
IdentifierDeclStatement:null
	IdentifierDecl:*failure_delete_queue
		IdentifierDeclType:struct temp_file *
		Identifier:failure_delete_queue
FunctionDef:voidrecord_temp_file (const char *filename , int always_delete , int fail_delete)
	CompoundStatement:
		Statement:char
		Statement:*
		Statement:const
		ExpressionStatement:name = xstrdup (filename)
			AssignmentExpression:name = xstrdup (filename)
				Identifier:name
				CallExpression:xstrdup (filename)
					Callee:xstrdup
						Identifier:xstrdup
					ArgumentList:filename
						Argument:filename
							Identifier:filename
		IfStatement:if (always_delete)
			Condition:always_delete
				Identifier:always_delete
			CompoundStatement:
				IdentifierDeclStatement:struct temp_file *temp;
					IdentifierDecl:*temp
						IdentifierDeclType:struct temp_file *
						Identifier:temp
				ForStatement:for (temp = always_delete_queue; temp; temp = temp->next)
					ForInit:temp = always_delete_queue;
						AssignmentExpression:temp = always_delete_queue
							Identifier:temp
							Identifier:always_delete_queue
					Condition:temp
						Identifier:temp
					AssignmentExpression:temp = temp->next
						Identifier:temp
						PtrMemberAccess:temp->next
							Identifier:temp
							Identifier:next
					IfStatement:if (! filename_cmp (name, temp->name))
						Condition:! filename_cmp (name, temp->name)
							UnaryOperationExpression:! filename_cmp (name, temp->name)
								UnaryOperator:!
								CallExpression:filename_cmp (name, temp->name)
									Callee:filename_cmp
										Identifier:filename_cmp
									ArgumentList:name
										Argument:name
											Identifier:name
										Argument:temp->name
											PtrMemberAccess:temp->name
												Identifier:temp
												Identifier:name
						CompoundStatement:
							ExpressionStatement:free (name)
								CallExpression:free (name)
									Callee:free
										Identifier:free
									ArgumentList:name
										Argument:name
											Identifier:name
							GotoStatement:goto already1;
								Identifier:already1
				Statement:temp
				Statement:=
				Statement:XNEW
				Statement:(
				Statement:struct
				Statement:temp_file
				Statement:)
				ExpressionStatement:
				ExpressionStatement:temp->next = always_delete_queue
					AssignmentExpression:temp->next = always_delete_queue
						PtrMemberAccess:temp->next
							Identifier:temp
							Identifier:next
						Identifier:always_delete_queue
				ExpressionStatement:temp->name = name
					AssignmentExpression:temp->name = name
						PtrMemberAccess:temp->name
							Identifier:temp
							Identifier:name
						Identifier:name
				ExpressionStatement:always_delete_queue = temp
					AssignmentExpression:always_delete_queue = temp
						Identifier:always_delete_queue
						Identifier:temp
				Label:already1:
					Identifier:already1
				ExpressionStatement:
		IfStatement:if (fail_delete)
			Condition:fail_delete
				Identifier:fail_delete
			CompoundStatement:
				IdentifierDeclStatement:struct temp_file *temp;
					IdentifierDecl:*temp
						IdentifierDeclType:struct temp_file *
						Identifier:temp
				ForStatement:for (temp = failure_delete_queue; temp; temp = temp->next)
					ForInit:temp = failure_delete_queue;
						AssignmentExpression:temp = failure_delete_queue
							Identifier:temp
							Identifier:failure_delete_queue
					Condition:temp
						Identifier:temp
					AssignmentExpression:temp = temp->next
						Identifier:temp
						PtrMemberAccess:temp->next
							Identifier:temp
							Identifier:next
					IfStatement:if (! filename_cmp (name, temp->name))
						Condition:! filename_cmp (name, temp->name)
							UnaryOperationExpression:! filename_cmp (name, temp->name)
								UnaryOperator:!
								CallExpression:filename_cmp (name, temp->name)
									Callee:filename_cmp
										Identifier:filename_cmp
									ArgumentList:name
										Argument:name
											Identifier:name
										Argument:temp->name
											PtrMemberAccess:temp->name
												Identifier:temp
												Identifier:name
						CompoundStatement:
							ExpressionStatement:free (name)
								CallExpression:free (name)
									Callee:free
										Identifier:free
									ArgumentList:name
										Argument:name
											Identifier:name
							GotoStatement:goto already2;
								Identifier:already2
				Statement:temp
				Statement:=
				Statement:XNEW
				Statement:(
				Statement:struct
				Statement:temp_file
				Statement:)
				ExpressionStatement:
				ExpressionStatement:temp->next = failure_delete_queue
					AssignmentExpression:temp->next = failure_delete_queue
						PtrMemberAccess:temp->next
							Identifier:temp
							Identifier:next
						Identifier:failure_delete_queue
				ExpressionStatement:temp->name = name
					AssignmentExpression:temp->name = name
						PtrMemberAccess:temp->name
							Identifier:temp
							Identifier:name
						Identifier:name
				ExpressionStatement:failure_delete_queue = temp
					AssignmentExpression:failure_delete_queue = temp
						Identifier:failure_delete_queue
						Identifier:temp
				Label:already2:
					Identifier:already2
				ExpressionStatement:
	Identifier:voidrecord_temp_file
	ParameterList:const char *filename , int always_delete , int fail_delete
		Parameter:const char *filename
			ParameterType:const char *
			Identifier:filename
		Parameter:int always_delete
			ParameterType:int
			Identifier:always_delete
		Parameter:int fail_delete
			ParameterType:int
			Identifier:fail_delete
FunctionDef:voiddelete_if_ordinary (const char *name)
	CompoundStatement:
		IdentifierDeclStatement:struct stat st;
			IdentifierDecl:st
				IdentifierDeclType:struct stat
				Identifier:st
		IdentifierDeclStatement:ifdef DEBUG  int i, c;
			IdentifierDecl:i
				IdentifierDeclType:ifdef DEBUG int
				Identifier:i
			IdentifierDecl:c
				IdentifierDeclType:ifdef DEBUG int
				Identifier:c
		ExpressionStatement:printf ("Delete %s? (y or n) ", name)
			CallExpression:printf ("Delete %s? (y or n) ", name)
				Callee:printf
					Identifier:printf
				ArgumentList:"Delete %s? (y or n) "
					Argument:"Delete %s? (y or n) "
						Constant:"Delete %s? (y or n) "
					Argument:name
						Identifier:name
		ExpressionStatement:fflush (stdout)
			CallExpression:fflush (stdout)
				Callee:fflush
					Identifier:fflush
				ArgumentList:stdout
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:i = getchar ()
			AssignmentExpression:i = getchar ()
				Identifier:i
				CallExpression:getchar ()
					Callee:getchar
						Identifier:getchar
					ArgumentList:
		IfStatement:if (i != '\n')
			Condition:i != '\n'
				EqualityExpression:i != '\n'
					Identifier:i
					Constant:'\n'
			WhileStatement:while ((c = getchar ()) != '\n' && c != EOF)
				Condition:(c = getchar ()) != '\n' && c != EOF
					AndExpression:(c = getchar ()) != '\n' && c != EOF
						EqualityExpression:(c = getchar ()) != '\n'
							AssignmentExpression:c = getchar ()
								Identifier:c
								CallExpression:getchar ()
									Callee:getchar
										Identifier:getchar
									ArgumentList:
							Constant:'\n'
						EqualityExpression:c != EOF
							Identifier:c
							Identifier:EOF
				ExpressionStatement:
		IfStatement:if (i == 'y' || i == 'Y')
			Condition:i == 'y' || i == 'Y'
				OrExpression:i == 'y' || i == 'Y'
					EqualityExpression:i == 'y'
						Identifier:i
						Constant:'y'
					EqualityExpression:i == 'Y'
						Identifier:i
						Constant:'Y'
			Statement:endif
		Statement:/* DEBUG */
		ExpressionStatement:DELETE_IF_ORDINARY (name, st, verbose_flag)
			CallExpression:DELETE_IF_ORDINARY (name, st, verbose_flag)
				Callee:DELETE_IF_ORDINARY
					Identifier:DELETE_IF_ORDINARY
				ArgumentList:name
					Argument:name
						Identifier:name
					Argument:st
						Identifier:st
					Argument:verbose_flag
						Identifier:verbose_flag
	ReturnType:endifstatic
	Identifier:voiddelete_if_ordinary
	ParameterList:const char *name
		Parameter:const char *name
			ParameterType:const char *
			Identifier:name
FunctionDef:voiddelete_temp_files ()
	CompoundStatement:
		IdentifierDeclStatement:struct temp_file *temp;
			IdentifierDecl:*temp
				IdentifierDeclType:struct temp_file *
				Identifier:temp
		ForStatement:for (temp = always_delete_queue; temp; temp = temp->next)
			ForInit:temp = always_delete_queue;
				AssignmentExpression:temp = always_delete_queue
					Identifier:temp
					Identifier:always_delete_queue
			Condition:temp
				Identifier:temp
			AssignmentExpression:temp = temp->next
				Identifier:temp
				PtrMemberAccess:temp->next
					Identifier:temp
					Identifier:next
			ExpressionStatement:delete_if_ordinary (temp->name)
				CallExpression:delete_if_ordinary (temp->name)
					Callee:delete_if_ordinary
						Identifier:delete_if_ordinary
					ArgumentList:temp->name
						Argument:temp->name
							PtrMemberAccess:temp->name
								Identifier:temp
								Identifier:name
		ExpressionStatement:always_delete_queue = 0
			AssignmentExpression:always_delete_queue = 0
				Identifier:always_delete_queue
				Constant:0
	Identifier:voiddelete_temp_files
	ParameterList:
FunctionDef:voiddelete_failure_queue ()
	CompoundStatement:
		IdentifierDeclStatement:struct temp_file *temp;
			IdentifierDecl:*temp
				IdentifierDeclType:struct temp_file *
				Identifier:temp
		ForStatement:for (temp = failure_delete_queue; temp; temp = temp->next)
			ForInit:temp = failure_delete_queue;
				AssignmentExpression:temp = failure_delete_queue
					Identifier:temp
					Identifier:failure_delete_queue
			Condition:temp
				Identifier:temp
			AssignmentExpression:temp = temp->next
				Identifier:temp
				PtrMemberAccess:temp->next
					Identifier:temp
					Identifier:next
			ExpressionStatement:delete_if_ordinary (temp->name)
				CallExpression:delete_if_ordinary (temp->name)
					Callee:delete_if_ordinary
						Identifier:delete_if_ordinary
					ArgumentList:temp->name
						Argument:temp->name
							PtrMemberAccess:temp->name
								Identifier:temp
								Identifier:name
	Identifier:voiddelete_failure_queue
	ParameterList:
FunctionDef:voidclear_failure_queue ()
	CompoundStatement:
		ExpressionStatement:failure_delete_queue = 0
			AssignmentExpression:failure_delete_queue = 0
				Identifier:failure_delete_queue
				Constant:0
	Identifier:voidclear_failure_queue
	ParameterList:
FunctionDef:for_each_path (const struct path_prefix *paths , bool do_multi , size_t extra_space , void *(*callback) (char *, void *) , void *callback_info)
	CompoundStatement:
		IdentifierDeclStatement:struct prefix_list *pl;
			IdentifierDecl:*pl
				IdentifierDeclType:struct prefix_list *
				Identifier:pl
		IdentifierDeclStatement:const char *multi_dir = NULL;
			IdentifierDecl:*multi_dir = NULL
				IdentifierDeclType:const char *
				Identifier:multi_dir
				AssignmentExpression:*multi_dir = NULL
					Identifier:multi_dir
					Identifier:NULL
		IdentifierDeclStatement:const char *multi_os_dir = NULL;
			IdentifierDecl:*multi_os_dir = NULL
				IdentifierDeclType:const char *
				Identifier:multi_os_dir
				AssignmentExpression:*multi_os_dir = NULL
					Identifier:multi_os_dir
					Identifier:NULL
		IdentifierDeclStatement:const char *multiarch_suffix = NULL;
			IdentifierDecl:*multiarch_suffix = NULL
				IdentifierDeclType:const char *
				Identifier:multiarch_suffix
				AssignmentExpression:*multiarch_suffix = NULL
					Identifier:multiarch_suffix
					Identifier:NULL
		IdentifierDeclStatement:const char *multi_suffix;
			IdentifierDecl:*multi_suffix
				IdentifierDeclType:const char *
				Identifier:multi_suffix
		IdentifierDeclStatement:const char *just_multi_suffix;
			IdentifierDecl:*just_multi_suffix
				IdentifierDeclType:const char *
				Identifier:just_multi_suffix
		IdentifierDeclStatement:char *path = NULL;
			IdentifierDecl:*path = NULL
				IdentifierDeclType:char *
				Identifier:path
				AssignmentExpression:*path = NULL
					Identifier:path
					Identifier:NULL
		IdentifierDeclStatement:void *ret = NULL;
			IdentifierDecl:*ret = NULL
				IdentifierDeclType:void *
				Identifier:ret
				AssignmentExpression:*ret = NULL
					Identifier:ret
					Identifier:NULL
		IdentifierDeclStatement:bool skip_multi_dir = false;
			IdentifierDecl:skip_multi_dir = false
				IdentifierDeclType:bool
				Identifier:skip_multi_dir
				AssignmentExpression:skip_multi_dir = false
					Identifier:skip_multi_dir
					Identifier:false
		IdentifierDeclStatement:bool skip_multi_os_dir = false;
			IdentifierDecl:skip_multi_os_dir = false
				IdentifierDeclType:bool
				Identifier:skip_multi_os_dir
				AssignmentExpression:skip_multi_os_dir = false
					Identifier:skip_multi_os_dir
					Identifier:false
		ExpressionStatement:multi_suffix = machine_suffix
			AssignmentExpression:multi_suffix = machine_suffix
				Identifier:multi_suffix
				Identifier:machine_suffix
		ExpressionStatement:just_multi_suffix = just_machine_suffix
			AssignmentExpression:just_multi_suffix = just_machine_suffix
				Identifier:just_multi_suffix
				Identifier:just_machine_suffix
		IfStatement:if (do_multi && multilib_dir && strcmp (multilib_dir, ".") != 0)
			Condition:do_multi && multilib_dir && strcmp (multilib_dir, ".") != 0
				AndExpression:do_multi && multilib_dir && strcmp (multilib_dir, ".") != 0
					Identifier:do_multi
					AndExpression:multilib_dir && strcmp (multilib_dir, ".") != 0
						Identifier:multilib_dir
						EqualityExpression:strcmp (multilib_dir, ".") != 0
							CallExpression:strcmp (multilib_dir, ".")
								Callee:strcmp
									Identifier:strcmp
								ArgumentList:multilib_dir
									Argument:multilib_dir
										Identifier:multilib_dir
									Argument:"."
										Constant:"."
							Constant:0
			CompoundStatement:
				ExpressionStatement:multi_dir = concat (multilib_dir, dir_separator_str, NULL)
					AssignmentExpression:multi_dir = concat (multilib_dir, dir_separator_str, NULL)
						Identifier:multi_dir
						CallExpression:concat (multilib_dir, dir_separator_str, NULL)
							Callee:concat
								Identifier:concat
							ArgumentList:multilib_dir
								Argument:multilib_dir
									Identifier:multilib_dir
								Argument:dir_separator_str
									Identifier:dir_separator_str
								Argument:NULL
									Identifier:NULL
				ExpressionStatement:multi_suffix = concat (multi_suffix, multi_dir, NULL)
					AssignmentExpression:multi_suffix = concat (multi_suffix, multi_dir, NULL)
						Identifier:multi_suffix
						CallExpression:concat (multi_suffix, multi_dir, NULL)
							Callee:concat
								Identifier:concat
							ArgumentList:multi_suffix
								Argument:multi_suffix
									Identifier:multi_suffix
								Argument:multi_dir
									Identifier:multi_dir
								Argument:NULL
									Identifier:NULL
				ExpressionStatement:just_multi_suffix = concat (just_multi_suffix, multi_dir, NULL)
					AssignmentExpression:just_multi_suffix = concat (just_multi_suffix, multi_dir, NULL)
						Identifier:just_multi_suffix
						CallExpression:concat (just_multi_suffix, multi_dir, NULL)
							Callee:concat
								Identifier:concat
							ArgumentList:just_multi_suffix
								Argument:just_multi_suffix
									Identifier:just_multi_suffix
								Argument:multi_dir
									Identifier:multi_dir
								Argument:NULL
									Identifier:NULL
		IfStatement:if (do_multi && multilib_os_dir && strcmp (multilib_os_dir, ".") != 0)
			Condition:do_multi && multilib_os_dir && strcmp (multilib_os_dir, ".") != 0
				AndExpression:do_multi && multilib_os_dir && strcmp (multilib_os_dir, ".") != 0
					Identifier:do_multi
					AndExpression:multilib_os_dir && strcmp (multilib_os_dir, ".") != 0
						Identifier:multilib_os_dir
						EqualityExpression:strcmp (multilib_os_dir, ".") != 0
							CallExpression:strcmp (multilib_os_dir, ".")
								Callee:strcmp
									Identifier:strcmp
								ArgumentList:multilib_os_dir
									Argument:multilib_os_dir
										Identifier:multilib_os_dir
									Argument:"."
										Constant:"."
							Constant:0
			ExpressionStatement:multi_os_dir = concat (multilib_os_dir, dir_separator_str, NULL)
				AssignmentExpression:multi_os_dir = concat (multilib_os_dir, dir_separator_str, NULL)
					Identifier:multi_os_dir
					CallExpression:concat (multilib_os_dir, dir_separator_str, NULL)
						Callee:concat
							Identifier:concat
						ArgumentList:multilib_os_dir
							Argument:multilib_os_dir
								Identifier:multilib_os_dir
							Argument:dir_separator_str
								Identifier:dir_separator_str
							Argument:NULL
								Identifier:NULL
		IfStatement:if (multiarch_dir)
			Condition:multiarch_dir
				Identifier:multiarch_dir
			ExpressionStatement:multiarch_suffix = concat (multiarch_dir, dir_separator_str, NULL)
				AssignmentExpression:multiarch_suffix = concat (multiarch_dir, dir_separator_str, NULL)
					Identifier:multiarch_suffix
					CallExpression:concat (multiarch_dir, dir_separator_str, NULL)
						Callee:concat
							Identifier:concat
						ArgumentList:multiarch_dir
							Argument:multiarch_dir
								Identifier:multiarch_dir
							Argument:dir_separator_str
								Identifier:dir_separator_str
							Argument:NULL
								Identifier:NULL
		WhileStatement:while (1)
			Condition:1
				Constant:1
			CompoundStatement:
				IdentifierDeclStatement:size_t multi_dir_len = 0;
					IdentifierDecl:multi_dir_len = 0
						IdentifierDeclType:size_t
						Identifier:multi_dir_len
						AssignmentExpression:multi_dir_len = 0
							Identifier:multi_dir_len
							Constant:0
				IdentifierDeclStatement:size_t multi_os_dir_len = 0;
					IdentifierDecl:multi_os_dir_len = 0
						IdentifierDeclType:size_t
						Identifier:multi_os_dir_len
						AssignmentExpression:multi_os_dir_len = 0
							Identifier:multi_os_dir_len
							Constant:0
				IdentifierDeclStatement:size_t multiarch_len = 0;
					IdentifierDecl:multiarch_len = 0
						IdentifierDeclType:size_t
						Identifier:multiarch_len
						AssignmentExpression:multiarch_len = 0
							Identifier:multiarch_len
							Constant:0
				IdentifierDeclStatement:size_t suffix_len;
					IdentifierDecl:suffix_len
						IdentifierDeclType:size_t
						Identifier:suffix_len
				IdentifierDeclStatement:size_t just_suffix_len;
					IdentifierDecl:just_suffix_len
						IdentifierDeclType:size_t
						Identifier:just_suffix_len
				IdentifierDeclStatement:size_t len;
					IdentifierDecl:len
						IdentifierDeclType:size_t
						Identifier:len
				IfStatement:if (multi_dir)
					Condition:multi_dir
						Identifier:multi_dir
					ExpressionStatement:multi_dir_len = strlen (multi_dir)
						AssignmentExpression:multi_dir_len = strlen (multi_dir)
							Identifier:multi_dir_len
							CallExpression:strlen (multi_dir)
								Callee:strlen
									Identifier:strlen
								ArgumentList:multi_dir
									Argument:multi_dir
										Identifier:multi_dir
				IfStatement:if (multi_os_dir)
					Condition:multi_os_dir
						Identifier:multi_os_dir
					ExpressionStatement:multi_os_dir_len = strlen (multi_os_dir)
						AssignmentExpression:multi_os_dir_len = strlen (multi_os_dir)
							Identifier:multi_os_dir_len
							CallExpression:strlen (multi_os_dir)
								Callee:strlen
									Identifier:strlen
								ArgumentList:multi_os_dir
									Argument:multi_os_dir
										Identifier:multi_os_dir
				IfStatement:if (multiarch_suffix)
					Condition:multiarch_suffix
						Identifier:multiarch_suffix
					ExpressionStatement:multiarch_len = strlen (multiarch_suffix)
						AssignmentExpression:multiarch_len = strlen (multiarch_suffix)
							Identifier:multiarch_len
							CallExpression:strlen (multiarch_suffix)
								Callee:strlen
									Identifier:strlen
								ArgumentList:multiarch_suffix
									Argument:multiarch_suffix
										Identifier:multiarch_suffix
				ExpressionStatement:suffix_len = strlen (multi_suffix)
					AssignmentExpression:suffix_len = strlen (multi_suffix)
						Identifier:suffix_len
						CallExpression:strlen (multi_suffix)
							Callee:strlen
								Identifier:strlen
							ArgumentList:multi_suffix
								Argument:multi_suffix
									Identifier:multi_suffix
				ExpressionStatement:just_suffix_len = strlen (just_multi_suffix)
					AssignmentExpression:just_suffix_len = strlen (just_multi_suffix)
						Identifier:just_suffix_len
						CallExpression:strlen (just_multi_suffix)
							Callee:strlen
								Identifier:strlen
							ArgumentList:just_multi_suffix
								Argument:just_multi_suffix
									Identifier:just_multi_suffix
				IfStatement:if (path == NULL)
					Condition:path == NULL
						EqualityExpression:path == NULL
							Identifier:path
							Identifier:NULL
					CompoundStatement:
						ExpressionStatement:len = paths->max_len + extra_space + 1
							AssignmentExpression:len = paths->max_len + extra_space + 1
								Identifier:len
								AdditiveExpression:paths->max_len + extra_space + 1
									PtrMemberAccess:paths->max_len
										Identifier:paths
										Identifier:max_len
									AdditiveExpression:extra_space + 1
										Identifier:extra_space
										Constant:1
						ExpressionStatement:len += MAX (MAX (suffix_len, multi_os_dir_len), multiarch_len)
							AssignmentExpression:len += MAX (MAX (suffix_len, multi_os_dir_len), multiarch_len)
								Identifier:len
								CallExpression:MAX (MAX (suffix_len, multi_os_dir_len), multiarch_len)
									Callee:MAX
										Identifier:MAX
									ArgumentList:MAX (suffix_len, multi_os_dir_len)
										Argument:MAX (suffix_len, multi_os_dir_len)
											CallExpression:MAX (suffix_len, multi_os_dir_len)
												Callee:MAX
													Identifier:MAX
												ArgumentList:suffix_len
													Argument:suffix_len
														Identifier:suffix_len
													Argument:multi_os_dir_len
														Identifier:multi_os_dir_len
										Argument:multiarch_len
											Identifier:multiarch_len
						ExpressionStatement:path = XNEWVEC (char, len)
							AssignmentExpression:path = XNEWVEC (char, len)
								Identifier:path
								CallExpression:XNEWVEC (char, len)
									Callee:XNEWVEC
										Identifier:XNEWVEC
									ArgumentList:char
										Argument:char
											Identifier:char
										Argument:len
											Identifier:len
				ForStatement:for (pl = paths->plist; pl != 0; pl = pl->next)
					ForInit:pl = paths->plist;
						AssignmentExpression:pl = paths->plist
							Identifier:pl
							PtrMemberAccess:paths->plist
								Identifier:paths
								Identifier:plist
					Condition:pl != 0
						EqualityExpression:pl != 0
							Identifier:pl
							Constant:0
					AssignmentExpression:pl = pl->next
						Identifier:pl
						PtrMemberAccess:pl->next
							Identifier:pl
							Identifier:next
					CompoundStatement:
						ExpressionStatement:len = strlen (pl->prefix)
							AssignmentExpression:len = strlen (pl->prefix)
								Identifier:len
								CallExpression:strlen (pl->prefix)
									Callee:strlen
										Identifier:strlen
									ArgumentList:pl->prefix
										Argument:pl->prefix
											PtrMemberAccess:pl->prefix
												Identifier:pl
												Identifier:prefix
						ExpressionStatement:memcpy (path, pl->prefix, len)
							CallExpression:memcpy (path, pl->prefix, len)
								Callee:memcpy
									Identifier:memcpy
								ArgumentList:path
									Argument:path
										Identifier:path
									Argument:pl->prefix
										PtrMemberAccess:pl->prefix
											Identifier:pl
											Identifier:prefix
									Argument:len
										Identifier:len
						Statement:/* Look first in MACHINE/VERSION subdirectory.  */
						IfStatement:if (!skip_multi_dir)
							Condition:!skip_multi_dir
								UnaryOperationExpression:!skip_multi_dir
									UnaryOperator:!
									Identifier:skip_multi_dir
							CompoundStatement:
								ExpressionStatement:memcpy (path + len, multi_suffix, suffix_len + 1)
									CallExpression:memcpy (path + len, multi_suffix, suffix_len + 1)
										Callee:memcpy
											Identifier:memcpy
										ArgumentList:path + len
											Argument:path + len
												AdditiveExpression:path + len
													Identifier:path
													Identifier:len
											Argument:multi_suffix
												Identifier:multi_suffix
											Argument:suffix_len + 1
												AdditiveExpression:suffix_len + 1
													Identifier:suffix_len
													Constant:1
								ExpressionStatement:ret = callback (path, callback_info)
									AssignmentExpression:ret = callback (path, callback_info)
										Identifier:ret
										CallExpression:callback (path, callback_info)
											Callee:callback
												Identifier:callback
											ArgumentList:path
												Argument:path
													Identifier:path
												Argument:callback_info
													Identifier:callback_info
								IfStatement:if (ret)
									Condition:ret
										Identifier:ret
									BreakStatement:break;
						Statement:/* Some paths are tried with just the machine (ie. target)\t     subdir.  This is used for finding as, ld, etc.  */
						IfStatement:if (!skip_multi_dir\t      && pl->require_machine_suffix == 2)
							Condition:!skip_multi_dir\t      && pl->require_machine_suffix == 2
								AndExpression:!skip_multi_dir\t      && pl->require_machine_suffix == 2
									UnaryOperationExpression:!skip_multi_dir
										UnaryOperator:!
										Identifier:skip_multi_dir
									EqualityExpression:pl->require_machine_suffix == 2
										PtrMemberAccess:pl->require_machine_suffix
											Identifier:pl
											Identifier:require_machine_suffix
										Constant:2
							CompoundStatement:
								ExpressionStatement:memcpy (path + len, just_multi_suffix, just_suffix_len + 1)
									CallExpression:memcpy (path + len, just_multi_suffix, just_suffix_len + 1)
										Callee:memcpy
											Identifier:memcpy
										ArgumentList:path + len
											Argument:path + len
												AdditiveExpression:path + len
													Identifier:path
													Identifier:len
											Argument:just_multi_suffix
												Identifier:just_multi_suffix
											Argument:just_suffix_len + 1
												AdditiveExpression:just_suffix_len + 1
													Identifier:just_suffix_len
													Constant:1
								ExpressionStatement:ret = callback (path, callback_info)
									AssignmentExpression:ret = callback (path, callback_info)
										Identifier:ret
										CallExpression:callback (path, callback_info)
											Callee:callback
												Identifier:callback
											ArgumentList:path
												Argument:path
													Identifier:path
												Argument:callback_info
													Identifier:callback_info
								IfStatement:if (ret)
									Condition:ret
										Identifier:ret
									BreakStatement:break;
						Statement:/* Now try the multiarch path.  */
						IfStatement:if (!skip_multi_dir\t      && !pl->require_machine_suffix && multiarch_dir)
							Condition:!skip_multi_dir\t      && !pl->require_machine_suffix && multiarch_dir
								AndExpression:!skip_multi_dir\t      && !pl->require_machine_suffix && multiarch_dir
									UnaryOperationExpression:!skip_multi_dir
										UnaryOperator:!
										Identifier:skip_multi_dir
									AndExpression:!pl->require_machine_suffix && multiarch_dir
										UnaryOperationExpression:!pl->require_machine_suffix
											UnaryOperator:!
											PtrMemberAccess:pl->require_machine_suffix
												Identifier:pl
												Identifier:require_machine_suffix
										Identifier:multiarch_dir
							CompoundStatement:
								ExpressionStatement:memcpy (path + len, multiarch_suffix, multiarch_len + 1)
									CallExpression:memcpy (path + len, multiarch_suffix, multiarch_len + 1)
										Callee:memcpy
											Identifier:memcpy
										ArgumentList:path + len
											Argument:path + len
												AdditiveExpression:path + len
													Identifier:path
													Identifier:len
											Argument:multiarch_suffix
												Identifier:multiarch_suffix
											Argument:multiarch_len + 1
												AdditiveExpression:multiarch_len + 1
													Identifier:multiarch_len
													Constant:1
								ExpressionStatement:ret = callback (path, callback_info)
									AssignmentExpression:ret = callback (path, callback_info)
										Identifier:ret
										CallExpression:callback (path, callback_info)
											Callee:callback
												Identifier:callback
											ArgumentList:path
												Argument:path
													Identifier:path
												Argument:callback_info
													Identifier:callback_info
								IfStatement:if (ret)
									Condition:ret
										Identifier:ret
									BreakStatement:break;
						Statement:/* Now try the base path.  */
						IfStatement:if (!pl->require_machine_suffix\t      && !(pl->os_multilib ? skip_multi_os_dir : skip_multi_dir))
							Condition:!pl->require_machine_suffix\t      && !(pl->os_multilib ? skip_multi_os_dir : skip_multi_dir)
								AndExpression:!pl->require_machine_suffix\t      && !(pl->os_multilib ? skip_multi_os_dir : skip_multi_dir)
									UnaryOperationExpression:!pl->require_machine_suffix
										UnaryOperator:!
										PtrMemberAccess:pl->require_machine_suffix
											Identifier:pl
											Identifier:require_machine_suffix
									UnaryOperationExpression:!(pl->os_multilib ? skip_multi_os_dir : skip_multi_dir)
										UnaryOperator:!
										ConditionalExpression:pl->os_multilib ? skip_multi_os_dir : skip_multi_dir
											Condition:pl->os_multilib
												PtrMemberAccess:pl->os_multilib
													Identifier:pl
													Identifier:os_multilib
											Identifier:skip_multi_os_dir
											Identifier:skip_multi_dir
							CompoundStatement:
								IdentifierDeclStatement:const char *this_multi;
									IdentifierDecl:*this_multi
										IdentifierDeclType:const char *
										Identifier:this_multi
								IdentifierDeclStatement:size_t this_multi_len;
									IdentifierDecl:this_multi_len
										IdentifierDeclType:size_t
										Identifier:this_multi_len
								IfStatement:if (pl->os_multilib)
									Condition:pl->os_multilib
										PtrMemberAccess:pl->os_multilib
											Identifier:pl
											Identifier:os_multilib
									CompoundStatement:
										ExpressionStatement:this_multi = multi_os_dir
											AssignmentExpression:this_multi = multi_os_dir
												Identifier:this_multi
												Identifier:multi_os_dir
										ExpressionStatement:this_multi_len = multi_os_dir_len
											AssignmentExpression:this_multi_len = multi_os_dir_len
												Identifier:this_multi_len
												Identifier:multi_os_dir_len
								IfStatement:if (this_multi_len)
									Condition:this_multi_len
										Identifier:this_multi_len
									ExpressionStatement:memcpy (path + len, this_multi, this_multi_len + 1)
										CallExpression:memcpy (path + len, this_multi, this_multi_len + 1)
											Callee:memcpy
												Identifier:memcpy
											ArgumentList:path + len
												Argument:path + len
													AdditiveExpression:path + len
														Identifier:path
														Identifier:len
												Argument:this_multi
													Identifier:this_multi
												Argument:this_multi_len + 1
													AdditiveExpression:this_multi_len + 1
														Identifier:this_multi_len
														Constant:1
								ExpressionStatement:ret = callback (path, callback_info)
									AssignmentExpression:ret = callback (path, callback_info)
										Identifier:ret
										CallExpression:callback (path, callback_info)
											Callee:callback
												Identifier:callback
											ArgumentList:path
												Argument:path
													Identifier:path
												Argument:callback_info
													Identifier:callback_info
								IfStatement:if (ret)
									Condition:ret
										Identifier:ret
									BreakStatement:break;
				IfStatement:if (pl)
					Condition:pl
						Identifier:pl
					BreakStatement:break;
				IfStatement:if (multi_dir == NULL && multi_os_dir == NULL)
					Condition:multi_dir == NULL && multi_os_dir == NULL
						AndExpression:multi_dir == NULL && multi_os_dir == NULL
							EqualityExpression:multi_dir == NULL
								Identifier:multi_dir
								Identifier:NULL
							EqualityExpression:multi_os_dir == NULL
								Identifier:multi_os_dir
								Identifier:NULL
					BreakStatement:break;
				Statement:/* Run through the paths again, this time without multilibs.\t Don't repeat any we have already seen.  */
				IfStatement:if (multi_dir)
					Condition:multi_dir
						Identifier:multi_dir
					CompoundStatement:
						Statement:free
						Statement:(
						Statement:CONST_CAST
						Statement:(
						Statement:char
						Statement:*
						Statement:,
						Statement:multi_dir
						Statement:)
						Statement:)
						ExpressionStatement:
						ExpressionStatement:multi_dir = NULL
							AssignmentExpression:multi_dir = NULL
								Identifier:multi_dir
								Identifier:NULL
						Statement:free
						Statement:(
						Statement:CONST_CAST
						Statement:(
						Statement:char
						Statement:*
						Statement:,
						Statement:multi_suffix
						Statement:)
						Statement:)
						ExpressionStatement:
						ExpressionStatement:multi_suffix = machine_suffix
							AssignmentExpression:multi_suffix = machine_suffix
								Identifier:multi_suffix
								Identifier:machine_suffix
						Statement:free
						Statement:(
						Statement:CONST_CAST
						Statement:(
						Statement:char
						Statement:*
						Statement:,
						Statement:just_multi_suffix
						Statement:)
						Statement:)
						ExpressionStatement:
						ExpressionStatement:just_multi_suffix = just_machine_suffix
							AssignmentExpression:just_multi_suffix = just_machine_suffix
								Identifier:just_multi_suffix
								Identifier:just_machine_suffix
				IfStatement:if (multi_os_dir)
					Condition:multi_os_dir
						Identifier:multi_os_dir
					CompoundStatement:
						Statement:free
						Statement:(
						Statement:CONST_CAST
						Statement:(
						Statement:char
						Statement:*
						Statement:,
						Statement:multi_os_dir
						Statement:)
						Statement:)
						ExpressionStatement:
						ExpressionStatement:multi_os_dir = NULL
							AssignmentExpression:multi_os_dir = NULL
								Identifier:multi_os_dir
								Identifier:NULL
		IfStatement:if (multi_dir)
			Condition:multi_dir
				Identifier:multi_dir
			CompoundStatement:
				Statement:free
				Statement:(
				Statement:CONST_CAST
				Statement:(
				Statement:char
				Statement:*
				Statement:,
				Statement:multi_dir
				Statement:)
				Statement:)
				ExpressionStatement:
				Statement:free
				Statement:(
				Statement:CONST_CAST
				Statement:(
				Statement:char
				Statement:*
				Statement:,
				Statement:multi_suffix
				Statement:)
				Statement:)
				ExpressionStatement:
				Statement:free
				Statement:(
				Statement:CONST_CAST
				Statement:(
				Statement:char
				Statement:*
				Statement:,
				Statement:just_multi_suffix
				Statement:)
				Statement:)
				ExpressionStatement:
		IfStatement:if (multi_os_dir)
			Condition:multi_os_dir
				Identifier:multi_os_dir
			Statement:free
		Statement:(
		Statement:CONST_CAST
		Statement:(
		Statement:char
		Statement:*
		Statement:,
		Statement:multi_os_dir
		Statement:)
		Statement:)
		ExpressionStatement:
		IfStatement:if (ret != path)
			Condition:ret != path
				EqualityExpression:ret != path
					Identifier:ret
					Identifier:path
			ExpressionStatement:free (path)
				CallExpression:free (path)
					Callee:free
						Identifier:free
					ArgumentList:path
						Argument:path
							Identifier:path
		ReturnStatement:return ret;
			Identifier:ret
	ReturnType:static void *
	Identifier:for_each_path
	ParameterList:const struct path_prefix *paths , bool do_multi , size_t extra_space , void *(*callback) (char *, void *) , void *callback_info
		Parameter:const struct path_prefix *paths
			ParameterType:const struct path_prefix *
			Identifier:paths
		Parameter:bool do_multi
			ParameterType:bool
			Identifier:do_multi
		Parameter:size_t extra_space
			ParameterType:size_t
			Identifier:extra_space
		Parameter:void *(*callback) (char *, void *)
			ParameterType:(* ( char * , void * ) void) *
			Identifier:callback
		Parameter:void *callback_info
			ParameterType:void *
			Identifier:callback_info
ClassDef:add_to_obstack_info
	CompoundStatement:
		IdentifierDeclStatement:null
			IdentifierDecl:*ob
				IdentifierDeclType:struct obstack *
				Identifier:ob
		IdentifierDeclStatement:null
			IdentifierDecl:check_dir
				IdentifierDeclType:bool
				Identifier:check_dir
		IdentifierDeclStatement:null
			IdentifierDecl:first_time
				IdentifierDeclType:bool
				Identifier:first_time
FunctionDef:add_to_obstack (char *path , void *data)
	CompoundStatement:
		IdentifierDeclStatement:struct add_to_obstack_info *info = (struct add_to_obstack_info *) data;
			IdentifierDecl:*info = (struct add_to_obstack_info *) data
				IdentifierDeclType:struct add_to_obstack_info *
				Identifier:info
				AssignmentExpression:*info = (struct add_to_obstack_info *) data
					Identifier:info
					CastExpression:(struct add_to_obstack_info *) data
						CastTarget:struct add_to_obstack_info *
						Identifier:data
		IfStatement:if (info->check_dir && !is_directory (path, false))
			Condition:info->check_dir && !is_directory (path, false)
				AndExpression:info->check_dir && !is_directory (path, false)
					PtrMemberAccess:info->check_dir
						Identifier:info
						Identifier:check_dir
					UnaryOperationExpression:!is_directory (path, false)
						UnaryOperator:!
						CallExpression:is_directory (path, false)
							Callee:is_directory
								Identifier:is_directory
							ArgumentList:path
								Argument:path
									Identifier:path
								Argument:false
									Identifier:false
			ReturnStatement:return NULL;
				Identifier:NULL
		IfStatement:if (!info->first_time)
			Condition:!info->first_time
				UnaryOperationExpression:!info->first_time
					UnaryOperator:!
					PtrMemberAccess:info->first_time
						Identifier:info
						Identifier:first_time
			ExpressionStatement:obstack_1grow (info->ob, PATH_SEPARATOR)
				CallExpression:obstack_1grow (info->ob, PATH_SEPARATOR)
					Callee:obstack_1grow
						Identifier:obstack_1grow
					ArgumentList:info->ob
						Argument:info->ob
							PtrMemberAccess:info->ob
								Identifier:info
								Identifier:ob
						Argument:PATH_SEPARATOR
							Identifier:PATH_SEPARATOR
		ExpressionStatement:obstack_grow (info->ob, path, strlen (path))
			CallExpression:obstack_grow (info->ob, path, strlen (path))
				Callee:obstack_grow
					Identifier:obstack_grow
				ArgumentList:info->ob
					Argument:info->ob
						PtrMemberAccess:info->ob
							Identifier:info
							Identifier:ob
					Argument:path
						Identifier:path
					Argument:strlen (path)
						CallExpression:strlen (path)
							Callee:strlen
								Identifier:strlen
							ArgumentList:path
								Argument:path
									Identifier:path
		ExpressionStatement:info->first_time = false
			AssignmentExpression:info->first_time = false
				PtrMemberAccess:info->first_time
					Identifier:info
					Identifier:first_time
				Identifier:false
		ReturnStatement:return NULL;
			Identifier:NULL
	ReturnType:static void *
	Identifier:add_to_obstack
	ParameterList:char *path , void *data
		Parameter:char *path
			ParameterType:char *
			Identifier:path
		Parameter:void *data
			ParameterType:void *
			Identifier:data
FunctionDef:voidxputenv (const char *string)
	CompoundStatement:
		ExpressionStatement:env.xput (string)
			CallExpression:env.xput (string)
				Callee:env.xput
					MemberAccess:env.xput
						Identifier:env
						Identifier:xput
				ArgumentList:string
					Argument:string
						Identifier:string
	Identifier:voidxputenv
	ParameterList:const char *string
		Parameter:const char *string
			ParameterType:const char *
			Identifier:string
FunctionDef:build_search_list (const struct path_prefix *paths , const char *prefix , bool check_dir , bool do_multi)
	CompoundStatement:
		IdentifierDeclStatement:struct add_to_obstack_info info;
			IdentifierDecl:info
				IdentifierDeclType:struct add_to_obstack_info
				Identifier:info
		ExpressionStatement:info.ob = &collect_obstack
			AssignmentExpression:info.ob = &collect_obstack
				MemberAccess:info.ob
					Identifier:info
					Identifier:ob
				UnaryOperationExpression:&collect_obstack
					UnaryOperator:&
					Identifier:collect_obstack
		ExpressionStatement:info.check_dir = check_dir
			AssignmentExpression:info.check_dir = check_dir
				MemberAccess:info.check_dir
					Identifier:info
					Identifier:check_dir
				Identifier:check_dir
		ExpressionStatement:info.first_time = true
			AssignmentExpression:info.first_time = true
				MemberAccess:info.first_time
					Identifier:info
					Identifier:first_time
				Identifier:true
		ExpressionStatement:obstack_grow (&collect_obstack, prefix, strlen (prefix))
			CallExpression:obstack_grow (&collect_obstack, prefix, strlen (prefix))
				Callee:obstack_grow
					Identifier:obstack_grow
				ArgumentList:&collect_obstack
					Argument:&collect_obstack
						UnaryOperationExpression:&collect_obstack
							UnaryOperator:&
							Identifier:collect_obstack
					Argument:prefix
						Identifier:prefix
					Argument:strlen (prefix)
						CallExpression:strlen (prefix)
							Callee:strlen
								Identifier:strlen
							ArgumentList:prefix
								Argument:prefix
									Identifier:prefix
		ExpressionStatement:obstack_1grow (&collect_obstack, '=')
			CallExpression:obstack_1grow (&collect_obstack, '=')
				Callee:obstack_1grow
					Identifier:obstack_1grow
				ArgumentList:&collect_obstack
					Argument:&collect_obstack
						UnaryOperationExpression:&collect_obstack
							UnaryOperator:&
							Identifier:collect_obstack
					Argument:'='
						Constant:'='
		ExpressionStatement:for_each_path (paths, do_multi, 0, add_to_obstack, &info)
			CallExpression:for_each_path (paths, do_multi, 0, add_to_obstack, &info)
				Callee:for_each_path
					Identifier:for_each_path
				ArgumentList:paths
					Argument:paths
						Identifier:paths
					Argument:do_multi
						Identifier:do_multi
					Argument:0
						Constant:0
					Argument:add_to_obstack
						Identifier:add_to_obstack
					Argument:&info
						UnaryOperationExpression:&info
							UnaryOperator:&
							Identifier:info
		ExpressionStatement:obstack_1grow (&collect_obstack, '\0')
			CallExpression:obstack_1grow (&collect_obstack, '\0')
				Callee:obstack_1grow
					Identifier:obstack_1grow
				ArgumentList:&collect_obstack
					Argument:&collect_obstack
						UnaryOperationExpression:&collect_obstack
							UnaryOperator:&
							Identifier:collect_obstack
					Argument:'\0'
						Constant:'\0'
		Statement:return
		Statement:XOBFINISH
		Statement:(
		Statement:&
		Statement:collect_obstack
		Statement:,
		Statement:char
		Statement:*
		Statement:)
		ExpressionStatement:
	ReturnType:static char *
	Identifier:build_search_list
	ParameterList:const struct path_prefix *paths , const char *prefix , bool check_dir , bool do_multi
		Parameter:const struct path_prefix *paths
			ParameterType:const struct path_prefix *
			Identifier:paths
		Parameter:const char *prefix
			ParameterType:const char *
			Identifier:prefix
		Parameter:bool check_dir
			ParameterType:bool
			Identifier:check_dir
		Parameter:bool do_multi
			ParameterType:bool
			Identifier:do_multi
FunctionDef:voidputenv_from_prefixes (const struct path_prefix *paths , const char *env_var , bool do_multi)
	CompoundStatement:
		ExpressionStatement:xputenv (build_search_list (paths, env_var, true, do_multi))
			CallExpression:xputenv (build_search_list (paths, env_var, true, do_multi))
				Callee:xputenv
					Identifier:xputenv
				ArgumentList:build_search_list (paths, env_var, true, do_multi)
					Argument:build_search_list (paths, env_var, true, do_multi)
						CallExpression:build_search_list (paths, env_var, true, do_multi)
							Callee:build_search_list
								Identifier:build_search_list
							ArgumentList:paths
								Argument:paths
									Identifier:paths
								Argument:env_var
									Identifier:env_var
								Argument:true
									Identifier:true
								Argument:do_multi
									Identifier:do_multi
	Identifier:voidputenv_from_prefixes
	ParameterList:const struct path_prefix *paths , const char *env_var , bool do_multi
		Parameter:const struct path_prefix *paths
			ParameterType:const struct path_prefix *
			Identifier:paths
		Parameter:const char *env_var
			ParameterType:const char *
			Identifier:env_var
		Parameter:bool do_multi
			ParameterType:bool
			Identifier:do_multi
FunctionDef:intaccess_check (const char *name , int mode)
	CompoundStatement:
		IfStatement:if (mode == X_OK)
			Condition:mode == X_OK
				EqualityExpression:mode == X_OK
					Identifier:mode
					Identifier:X_OK
			CompoundStatement:
				IdentifierDeclStatement:struct stat st;
					IdentifierDecl:st
						IdentifierDeclType:struct stat
						Identifier:st
				IfStatement:if (stat (name, &st) < 0\t  || S_ISDIR (st.st_mode))
					Condition:stat (name, &st) < 0\t  || S_ISDIR (st.st_mode)
						OrExpression:stat (name, &st) < 0\t  || S_ISDIR (st.st_mode)
							RelationalExpression:stat (name, &st) < 0
								CallExpression:stat (name, &st)
									Callee:stat
										Identifier:stat
									ArgumentList:name
										Argument:name
											Identifier:name
										Argument:&st
											UnaryOperationExpression:&st
												UnaryOperator:&
												Identifier:st
								Constant:0
							CallExpression:S_ISDIR (st.st_mode)
								Callee:S_ISDIR
									Identifier:S_ISDIR
								ArgumentList:st.st_mode
									Argument:st.st_mode
										MemberAccess:st.st_mode
											Identifier:st
											Identifier:st_mode
					ReturnStatement:return -1;
						UnaryOperationExpression:-1
							UnaryOperator:-
							Constant:1
		ReturnStatement:return access (name, mode);
			CallExpression:access (name, mode)
				Callee:access
					Identifier:access
				ArgumentList:name
					Argument:name
						Identifier:name
					Argument:mode
						Identifier:mode
	Identifier:intaccess_check
	ParameterList:const char *name , int mode
		Parameter:const char *name
			ParameterType:const char *
			Identifier:name
		Parameter:int mode
			ParameterType:int
			Identifier:mode
ClassDef:file_at_path_info
	CompoundStatement:
		IdentifierDeclStatement:null
			IdentifierDecl:*name
				IdentifierDeclType:const char *
				Identifier:name
		IdentifierDeclStatement:null
			IdentifierDecl:*suffix
				IdentifierDeclType:const char *
				Identifier:suffix
		IdentifierDeclStatement:null
			IdentifierDecl:name_len
				IdentifierDeclType:int
				Identifier:name_len
		IdentifierDeclStatement:null
			IdentifierDecl:suffix_len
				IdentifierDeclType:int
				Identifier:suffix_len
		IdentifierDeclStatement:null
			IdentifierDecl:mode
				IdentifierDeclType:int
				Identifier:mode
FunctionDef:file_at_path (char *path , void *data)
	CompoundStatement:
		IdentifierDeclStatement:struct file_at_path_info *info = (struct file_at_path_info *) data;
			IdentifierDecl:*info = (struct file_at_path_info *) data
				IdentifierDeclType:struct file_at_path_info *
				Identifier:info
				AssignmentExpression:*info = (struct file_at_path_info *) data
					Identifier:info
					CastExpression:(struct file_at_path_info *) data
						CastTarget:struct file_at_path_info *
						Identifier:data
		IdentifierDeclStatement:size_t len = strlen (path);
			IdentifierDecl:len = strlen (path)
				IdentifierDeclType:size_t
				Identifier:len
				AssignmentExpression:len = strlen (path)
					Identifier:len
					CallExpression:strlen (path)
						Callee:strlen
							Identifier:strlen
						ArgumentList:path
							Argument:path
								Identifier:path
		ExpressionStatement:memcpy (path + len, info->name, info->name_len)
			CallExpression:memcpy (path + len, info->name, info->name_len)
				Callee:memcpy
					Identifier:memcpy
				ArgumentList:path + len
					Argument:path + len
						AdditiveExpression:path + len
							Identifier:path
							Identifier:len
					Argument:info->name
						PtrMemberAccess:info->name
							Identifier:info
							Identifier:name
					Argument:info->name_len
						PtrMemberAccess:info->name_len
							Identifier:info
							Identifier:name_len
		ExpressionStatement:len += info->name_len
			AssignmentExpression:len += info->name_len
				Identifier:len
				PtrMemberAccess:info->name_len
					Identifier:info
					Identifier:name_len
		Statement:/* Some systems have a suffix for executable files.     So try appending that first.  */
		IfStatement:if (info->suffix_len)
			Condition:info->suffix_len
				PtrMemberAccess:info->suffix_len
					Identifier:info
					Identifier:suffix_len
			CompoundStatement:
				ExpressionStatement:memcpy (path + len, info->suffix, info->suffix_len + 1)
					CallExpression:memcpy (path + len, info->suffix, info->suffix_len + 1)
						Callee:memcpy
							Identifier:memcpy
						ArgumentList:path + len
							Argument:path + len
								AdditiveExpression:path + len
									Identifier:path
									Identifier:len
							Argument:info->suffix
								PtrMemberAccess:info->suffix
									Identifier:info
									Identifier:suffix
							Argument:info->suffix_len + 1
								AdditiveExpression:info->suffix_len + 1
									PtrMemberAccess:info->suffix_len
										Identifier:info
										Identifier:suffix_len
									Constant:1
				IfStatement:if (access_check (path, info->mode) == 0)
					Condition:access_check (path, info->mode) == 0
						EqualityExpression:access_check (path, info->mode) == 0
							CallExpression:access_check (path, info->mode)
								Callee:access_check
									Identifier:access_check
								ArgumentList:path
									Argument:path
										Identifier:path
									Argument:info->mode
										PtrMemberAccess:info->mode
											Identifier:info
											Identifier:mode
							Constant:0
					ReturnStatement:return path;
						Identifier:path
		ExpressionStatement:path[len] = '\0'
			AssignmentExpression:path[len] = '\0'
				ArrayIndexing:path[len]
					Identifier:path
					Identifier:len
				Constant:'\0'
		IfStatement:if (access_check (path, info->mode) == 0)
			Condition:access_check (path, info->mode) == 0
				EqualityExpression:access_check (path, info->mode) == 0
					CallExpression:access_check (path, info->mode)
						Callee:access_check
							Identifier:access_check
						ArgumentList:path
							Argument:path
								Identifier:path
							Argument:info->mode
								PtrMemberAccess:info->mode
									Identifier:info
									Identifier:mode
					Constant:0
			ReturnStatement:return path;
				Identifier:path
		ReturnStatement:return NULL;
			Identifier:NULL
	ReturnType:static void *
	Identifier:file_at_path
	ParameterList:char *path , void *data
		Parameter:char *path
			ParameterType:char *
			Identifier:path
		Parameter:void *data
			ParameterType:void *
			Identifier:data
FunctionDef:find_a_file (const struct path_prefix *pprefix , const char *name , int mode , bool do_multi)
	CompoundStatement:
		IdentifierDeclStatement:struct file_at_path_info info;
			IdentifierDecl:info
				IdentifierDeclType:struct file_at_path_info
				Identifier:info
		Statement:ifdef
		Statement:DEFAULT_ASSEMBLER
		IfStatement:if (! strcmp (name, "as") && access (DEFAULT_ASSEMBLER, mode) == 0)
			Condition:! strcmp (name, "as") && access (DEFAULT_ASSEMBLER, mode) == 0
				AndExpression:! strcmp (name, "as") && access (DEFAULT_ASSEMBLER, mode) == 0
					UnaryOperationExpression:! strcmp (name, "as")
						UnaryOperator:!
						CallExpression:strcmp (name, "as")
							Callee:strcmp
								Identifier:strcmp
							ArgumentList:name
								Argument:name
									Identifier:name
								Argument:"as"
									Constant:"as"
					EqualityExpression:access (DEFAULT_ASSEMBLER, mode) == 0
						CallExpression:access (DEFAULT_ASSEMBLER, mode)
							Callee:access
								Identifier:access
							ArgumentList:DEFAULT_ASSEMBLER
								Argument:DEFAULT_ASSEMBLER
									Identifier:DEFAULT_ASSEMBLER
								Argument:mode
									Identifier:mode
						Constant:0
			ReturnStatement:return xstrdup (DEFAULT_ASSEMBLER);
				CallExpression:xstrdup (DEFAULT_ASSEMBLER)
					Callee:xstrdup
						Identifier:xstrdup
					ArgumentList:DEFAULT_ASSEMBLER
						Argument:DEFAULT_ASSEMBLER
							Identifier:DEFAULT_ASSEMBLER
		Statement:endif
		Statement:ifdef
		Statement:DEFAULT_LINKER
		IfStatement:if (! strcmp (name, "ld") && access (DEFAULT_LINKER, mode) == 0)
			Condition:! strcmp (name, "ld") && access (DEFAULT_LINKER, mode) == 0
				AndExpression:! strcmp (name, "ld") && access (DEFAULT_LINKER, mode) == 0
					UnaryOperationExpression:! strcmp (name, "ld")
						UnaryOperator:!
						CallExpression:strcmp (name, "ld")
							Callee:strcmp
								Identifier:strcmp
							ArgumentList:name
								Argument:name
									Identifier:name
								Argument:"ld"
									Constant:"ld"
					EqualityExpression:access (DEFAULT_LINKER, mode) == 0
						CallExpression:access (DEFAULT_LINKER, mode)
							Callee:access
								Identifier:access
							ArgumentList:DEFAULT_LINKER
								Argument:DEFAULT_LINKER
									Identifier:DEFAULT_LINKER
								Argument:mode
									Identifier:mode
						Constant:0
			ReturnStatement:return xstrdup (DEFAULT_LINKER);
				CallExpression:xstrdup (DEFAULT_LINKER)
					Callee:xstrdup
						Identifier:xstrdup
					ArgumentList:DEFAULT_LINKER
						Argument:DEFAULT_LINKER
							Identifier:DEFAULT_LINKER
		Statement:endif
		Statement:/* Determine the filename to execute (special case for absolute paths).  */
		IfStatement:if (IS_ABSOLUTE_PATH (name))
			Condition:IS_ABSOLUTE_PATH (name)
				CallExpression:IS_ABSOLUTE_PATH (name)
					Callee:IS_ABSOLUTE_PATH
						Identifier:IS_ABSOLUTE_PATH
					ArgumentList:name
						Argument:name
							Identifier:name
			CompoundStatement:
				IfStatement:if (access (name, mode) == 0)
					Condition:access (name, mode) == 0
						EqualityExpression:access (name, mode) == 0
							CallExpression:access (name, mode)
								Callee:access
									Identifier:access
								ArgumentList:name
									Argument:name
										Identifier:name
									Argument:mode
										Identifier:mode
							Constant:0
					ReturnStatement:return xstrdup (name);
						CallExpression:xstrdup (name)
							Callee:xstrdup
								Identifier:xstrdup
							ArgumentList:name
								Argument:name
									Identifier:name
				ReturnStatement:return NULL;
					Identifier:NULL
		ExpressionStatement:info.name = name
			AssignmentExpression:info.name = name
				MemberAccess:info.name
					Identifier:info
					Identifier:name
				Identifier:name
		ExpressionStatement:info.suffix = (mode & X_OK) != 0 ? HOST_EXECUTABLE_SUFFIX : ""
			AssignmentExpression:info.suffix = (mode & X_OK) != 0 ? HOST_EXECUTABLE_SUFFIX : ""
				MemberAccess:info.suffix
					Identifier:info
					Identifier:suffix
				ConditionalExpression:(mode & X_OK) != 0 ? HOST_EXECUTABLE_SUFFIX : ""
					Condition:(mode & X_OK) != 0
						EqualityExpression:(mode & X_OK) != 0
							BitAndExpression:mode & X_OK
								Identifier:mode
								Identifier:X_OK
							Constant:0
					Identifier:HOST_EXECUTABLE_SUFFIX
					Constant:""
		ExpressionStatement:info.name_len = strlen (info.name)
			AssignmentExpression:info.name_len = strlen (info.name)
				MemberAccess:info.name_len
					Identifier:info
					Identifier:name_len
				CallExpression:strlen (info.name)
					Callee:strlen
						Identifier:strlen
					ArgumentList:info.name
						Argument:info.name
							MemberAccess:info.name
								Identifier:info
								Identifier:name
		ExpressionStatement:info.suffix_len = strlen (info.suffix)
			AssignmentExpression:info.suffix_len = strlen (info.suffix)
				MemberAccess:info.suffix_len
					Identifier:info
					Identifier:suffix_len
				CallExpression:strlen (info.suffix)
					Callee:strlen
						Identifier:strlen
					ArgumentList:info.suffix
						Argument:info.suffix
							MemberAccess:info.suffix
								Identifier:info
								Identifier:suffix
		ExpressionStatement:info.mode = mode
			AssignmentExpression:info.mode = mode
				MemberAccess:info.mode
					Identifier:info
					Identifier:mode
				Identifier:mode
		ReturnStatement:return (char*) for_each_path (pprefix, do_multi,\t\t\t\tinfo.name_len + info.suffix_len,\t\t\t\tfile_at_path, &info);
			CastExpression:(char*) for_each_path (pprefix, do_multi,\t\t\t\tinfo.name_len + info.suffix_len,\t\t\t\tfile_at_path, &info)
				CastTarget:char*
				CallExpression:for_each_path (pprefix, do_multi,\t\t\t\tinfo.name_len + info.suffix_len,\t\t\t\tfile_at_path, &info)
					Callee:for_each_path
						Identifier:for_each_path
					ArgumentList:pprefix
						Argument:pprefix
							Identifier:pprefix
						Argument:do_multi
							Identifier:do_multi
						Argument:info.name_len + info.suffix_len
							AdditiveExpression:info.name_len + info.suffix_len
								MemberAccess:info.name_len
									Identifier:info
									Identifier:name_len
								MemberAccess:info.suffix_len
									Identifier:info
									Identifier:suffix_len
						Argument:file_at_path
							Identifier:file_at_path
						Argument:&info
							UnaryOperationExpression:&info
								UnaryOperator:&
								Identifier:info
	ReturnType:static char *
	Identifier:find_a_file
	ParameterList:const struct path_prefix *pprefix , const char *name , int mode , bool do_multi
		Parameter:const struct path_prefix *pprefix
			ParameterType:const struct path_prefix *
			Identifier:pprefix
		Parameter:const char *name
			ParameterType:const char *
			Identifier:name
		Parameter:int mode
			ParameterType:int
			Identifier:mode
		Parameter:bool do_multi
			ParameterType:bool
			Identifier:do_multi
ClassDef:path_prefix_priority
	CompoundStatement:
IdentifierDeclStatement:null
	IdentifierDecl:*pl
		IdentifierDeclType:struct prefix_list *
		Identifier:pl
	IdentifierDecl:**prev
		IdentifierDeclType:struct prefix_list * *
		Identifier:prev
IdentifierDeclStatement:null
	IdentifierDecl:len
		IdentifierDeclType:int
		Identifier:len
IdentifierDeclStatement:null
	IdentifierDecl:*sysroot_no_trailing_dir_separator
		IdentifierDeclType:char *
		Identifier:sysroot_no_trailing_dir_separator
IdentifierDeclStatement:null
	IdentifierDecl:sysroot_len
		IdentifierDeclType:size_t
		Identifier:sysroot_len
FunctionDef:intexecute ()
	CompoundStatement:
		IdentifierDeclStatement:int i;
			IdentifierDecl:i
				IdentifierDeclType:int
				Identifier:i
		IdentifierDeclStatement:int n_commands;
			IdentifierDecl:n_commands
				IdentifierDeclType:int
				Identifier:n_commands
		Statement:/* # of command.  */
		IdentifierDeclStatement:char *string;
			IdentifierDecl:*string
				IdentifierDeclType:char *
				Identifier:string
		IdentifierDeclStatement:struct pex_obj *pex;
			IdentifierDecl:*pex
				IdentifierDeclType:struct pex_obj *
				Identifier:pex
		ClassDef:command
			CompoundStatement:
		ExpressionStatement:
		IdentifierDeclStatement:const char *arg;
			IdentifierDecl:*arg
				IdentifierDeclType:const char *
				Identifier:arg
		IdentifierDeclStatement:struct command *commands;
			IdentifierDecl:*commands
				IdentifierDeclType:struct command *
				Identifier:commands
		Statement:/* each command buffer with above info.  */
		ExpressionStatement:gcc_assert (!processing_spec_function)
			CallExpression:gcc_assert (!processing_spec_function)
				Callee:gcc_assert
					Identifier:gcc_assert
				ArgumentList:!processing_spec_function
					Argument:!processing_spec_function
						UnaryOperationExpression:!processing_spec_function
							UnaryOperator:!
							Identifier:processing_spec_function
		IfStatement:if (wrapper_string)
			Condition:wrapper_string
				Identifier:wrapper_string
			CompoundStatement:
				ExpressionStatement:string = find_a_file (&exec_prefixes,\t\t\t    argbuf[0], X_OK, false)
					AssignmentExpression:string = find_a_file (&exec_prefixes,\t\t\t    argbuf[0], X_OK, false)
						Identifier:string
						CallExpression:find_a_file (&exec_prefixes,\t\t\t    argbuf[0], X_OK, false)
							Callee:find_a_file
								Identifier:find_a_file
							ArgumentList:&exec_prefixes
								Argument:&exec_prefixes
									UnaryOperationExpression:&exec_prefixes
										UnaryOperator:&
										Identifier:exec_prefixes
								Argument:argbuf[0]
									ArrayIndexing:argbuf[0]
										Identifier:argbuf
										Constant:0
								Argument:X_OK
									Identifier:X_OK
								Argument:false
									Identifier:false
				IfStatement:if (string)
					Condition:string
						Identifier:string
					ExpressionStatement:argbuf[0] = string
						AssignmentExpression:argbuf[0] = string
							ArrayIndexing:argbuf[0]
								Identifier:argbuf
								Constant:0
							Identifier:string
				ExpressionStatement:insert_wrapper (wrapper_string)
					CallExpression:insert_wrapper (wrapper_string)
						Callee:insert_wrapper
							Identifier:insert_wrapper
						ArgumentList:wrapper_string
							Argument:wrapper_string
								Identifier:wrapper_string
		Statement:/* Count # of piped commands.  */
		ForStatement:for (n_commands = 1, i = 0; argbuf.iterate (i, &arg); i++)
			ForInit:n_commands = 1, i = 0;
				Expression:n_commands = 1, i = 0
					AssignmentExpression:n_commands = 1
						Identifier:n_commands
						Constant:1
					AssignmentExpression:i = 0
						Identifier:i
						Constant:0
			Condition:argbuf.iterate (i, &arg)
				CallExpression:argbuf.iterate (i, &arg)
					Callee:argbuf.iterate
						MemberAccess:argbuf.iterate
							Identifier:argbuf
							Identifier:iterate
					ArgumentList:i
						Argument:i
							Identifier:i
						Argument:&arg
							UnaryOperationExpression:&arg
								UnaryOperator:&
								Identifier:arg
			PostIncDecOperationExpression:i++
				Identifier:i
				IncDec:++
			IfStatement:if (strcmp (arg, "|") == 0)
				Condition:strcmp (arg, "|") == 0
					EqualityExpression:strcmp (arg, "|") == 0
						CallExpression:strcmp (arg, "|")
							Callee:strcmp
								Identifier:strcmp
							ArgumentList:arg
								Argument:arg
									Identifier:arg
								Argument:"|"
									Constant:"|"
						Constant:0
				ExpressionStatement:n_commands++
					PostIncDecOperationExpression:n_commands++
						Identifier:n_commands
						IncDec:++
		Statement:/* Get storage for each command.  */
		ExpressionStatement:commands = (struct command *) alloca (n_commands * sizeof (struct command))
			AssignmentExpression:commands = (struct command *) alloca (n_commands * sizeof (struct command))
				Identifier:commands
				CastExpression:(struct command *) alloca (n_commands * sizeof (struct command))
					CastTarget:struct command *
					CallExpression:alloca (n_commands * sizeof (struct command))
						Callee:alloca
							Identifier:alloca
						ArgumentList:n_commands * sizeof (struct command)
							Argument:n_commands * sizeof (struct command)
								MultiplicativeExpression:n_commands * sizeof (struct command)
									Identifier:n_commands
									SizeofExpression:sizeof (struct command)
										Sizeof:sizeof
										SizeofOperand:struct command
		Statement:/* Split argbuf into its separate piped processes,     and record info about each one.     Also search for the programs that are to be run.  */
		ExpressionStatement:argbuf.safe_push (0)
			CallExpression:argbuf.safe_push (0)
				Callee:argbuf.safe_push
					MemberAccess:argbuf.safe_push
						Identifier:argbuf
						Identifier:safe_push
				ArgumentList:0
					Argument:0
						Constant:0
		ExpressionStatement:commands[0].prog = argbuf[0]
			AssignmentExpression:commands[0].prog = argbuf[0]
				MemberAccess:commands[0].prog
					ArrayIndexing:commands[0]
						Identifier:commands
						Constant:0
					Identifier:prog
				ArrayIndexing:argbuf[0]
					Identifier:argbuf
					Constant:0
		Statement:/* first command.  */
		ExpressionStatement:commands[0].argv = argbuf.address ()
			AssignmentExpression:commands[0].argv = argbuf.address ()
				MemberAccess:commands[0].argv
					ArrayIndexing:commands[0]
						Identifier:commands
						Constant:0
					Identifier:argv
				CallExpression:argbuf.address ()
					Callee:argbuf.address
						MemberAccess:argbuf.address
							Identifier:argbuf
							Identifier:address
					ArgumentList:
		IfStatement:if (!wrapper_string)
			Condition:!wrapper_string
				UnaryOperationExpression:!wrapper_string
					UnaryOperator:!
					Identifier:wrapper_string
			CompoundStatement:
				ExpressionStatement:string = find_a_file (&exec_prefixes, commands[0].prog, X_OK, false)
					AssignmentExpression:string = find_a_file (&exec_prefixes, commands[0].prog, X_OK, false)
						Identifier:string
						CallExpression:find_a_file (&exec_prefixes, commands[0].prog, X_OK, false)
							Callee:find_a_file
								Identifier:find_a_file
							ArgumentList:&exec_prefixes
								Argument:&exec_prefixes
									UnaryOperationExpression:&exec_prefixes
										UnaryOperator:&
										Identifier:exec_prefixes
								Argument:commands[0].prog
									MemberAccess:commands[0].prog
										ArrayIndexing:commands[0]
											Identifier:commands
											Constant:0
										Identifier:prog
								Argument:X_OK
									Identifier:X_OK
								Argument:false
									Identifier:false
				ExpressionStatement:commands[0].argv[0] = (string) ? string : commands[0].argv[0]
					AssignmentExpression:commands[0].argv[0] = (string) ? string : commands[0].argv[0]
						ArrayIndexing:commands[0].argv[0]
							MemberAccess:commands[0].argv
								ArrayIndexing:commands[0]
									Identifier:commands
									Constant:0
								Identifier:argv
							Constant:0
						ConditionalExpression:(string) ? string : commands[0].argv[0]
							Condition:string
								Identifier:string
							Identifier:string
							ArrayIndexing:commands[0].argv[0]
								MemberAccess:commands[0].argv
									ArrayIndexing:commands[0]
										Identifier:commands
										Constant:0
									Identifier:argv
								Constant:0
		ForStatement:for (n_commands = 1, i = 0; argbuf.iterate (i, &arg); i++)
			ForInit:n_commands = 1, i = 0;
				Expression:n_commands = 1, i = 0
					AssignmentExpression:n_commands = 1
						Identifier:n_commands
						Constant:1
					AssignmentExpression:i = 0
						Identifier:i
						Constant:0
			Condition:argbuf.iterate (i, &arg)
				CallExpression:argbuf.iterate (i, &arg)
					Callee:argbuf.iterate
						MemberAccess:argbuf.iterate
							Identifier:argbuf
							Identifier:iterate
					ArgumentList:i
						Argument:i
							Identifier:i
						Argument:&arg
							UnaryOperationExpression:&arg
								UnaryOperator:&
								Identifier:arg
			PostIncDecOperationExpression:i++
				Identifier:i
				IncDec:++
			IfStatement:if (arg && strcmp (arg, "|") == 0)
				Condition:arg && strcmp (arg, "|") == 0
					AndExpression:arg && strcmp (arg, "|") == 0
						Identifier:arg
						EqualityExpression:strcmp (arg, "|") == 0
							CallExpression:strcmp (arg, "|")
								Callee:strcmp
									Identifier:strcmp
								ArgumentList:arg
									Argument:arg
										Identifier:arg
									Argument:"|"
										Constant:"|"
							Constant:0
				CompoundStatement:
					Statement:/* each command.  */
					Statement:if
					Statement:defined
					Statement:(
					Statement:__MSDOS__
					Statement:)
					Statement:||
					Statement:defined
					Statement:(
					Statement:OS2
					Statement:)
					Statement:||
					Statement:defined
					ExpressionStatement:(VMS)\tfatal_error (input_location, "-pipe not supported")
						CastExpression:(VMS)\tfatal_error (input_location, "-pipe not supported")
							CastTarget:VMS
							CallExpression:fatal_error (input_location, "-pipe not supported")
								Callee:fatal_error
									Identifier:fatal_error
								ArgumentList:input_location
									Argument:input_location
										Identifier:input_location
									Argument:"-pipe not supported"
										Constant:"-pipe not supported"
					IdentifierDeclStatement:endif\targbuf[i] = 0;
						IdentifierDecl:argbuf[i] = 0
							IdentifierDeclType:endif [ i ]
							Identifier:argbuf
							Identifier:i
							AssignmentExpression:argbuf[i] = 0
								Identifier:argbuf
								Constant:0
					Statement:/* Termination of\t\t\t\t\t\t     command args.  */
					ExpressionStatement:commands[n_commands].prog = argbuf[i + 1]
						AssignmentExpression:commands[n_commands].prog = argbuf[i + 1]
							MemberAccess:commands[n_commands].prog
								ArrayIndexing:commands[n_commands]
									Identifier:commands
									Identifier:n_commands
								Identifier:prog
							ArrayIndexing:argbuf[i + 1]
								Identifier:argbuf
								AdditiveExpression:i + 1
									Identifier:i
									Constant:1
					ExpressionStatement:commands[n_commands].argv\t  = &(argbuf.address ())[i + 1]
						AssignmentExpression:commands[n_commands].argv\t  = &(argbuf.address ())[i + 1]
							MemberAccess:commands[n_commands].argv
								ArrayIndexing:commands[n_commands]
									Identifier:commands
									Identifier:n_commands
								Identifier:argv
							UnaryOperationExpression:&(argbuf.address ())[i + 1]
								UnaryOperator:&
								ArrayIndexing:(argbuf.address ())[i + 1]
									CallExpression:argbuf.address ()
										Callee:argbuf.address
											MemberAccess:argbuf.address
												Identifier:argbuf
												Identifier:address
										ArgumentList:
									AdditiveExpression:i + 1
										Identifier:i
										Constant:1
					ExpressionStatement:string = find_a_file (&exec_prefixes, commands[n_commands].prog,\t\t\t      X_OK, false)
						AssignmentExpression:string = find_a_file (&exec_prefixes, commands[n_commands].prog,\t\t\t      X_OK, false)
							Identifier:string
							CallExpression:find_a_file (&exec_prefixes, commands[n_commands].prog,\t\t\t      X_OK, false)
								Callee:find_a_file
									Identifier:find_a_file
								ArgumentList:&exec_prefixes
									Argument:&exec_prefixes
										UnaryOperationExpression:&exec_prefixes
											UnaryOperator:&
											Identifier:exec_prefixes
									Argument:commands[n_commands].prog
										MemberAccess:commands[n_commands].prog
											ArrayIndexing:commands[n_commands]
												Identifier:commands
												Identifier:n_commands
											Identifier:prog
									Argument:X_OK
										Identifier:X_OK
									Argument:false
										Identifier:false
					IfStatement:if (string)
						Condition:string
							Identifier:string
						ExpressionStatement:commands[n_commands].argv[0] = string
							AssignmentExpression:commands[n_commands].argv[0] = string
								ArrayIndexing:commands[n_commands].argv[0]
									MemberAccess:commands[n_commands].argv
										ArrayIndexing:commands[n_commands]
											Identifier:commands
											Identifier:n_commands
										Identifier:argv
									Constant:0
								Identifier:string
					ExpressionStatement:n_commands++
						PostIncDecOperationExpression:n_commands++
							Identifier:n_commands
							IncDec:++
		Statement:/* If -v, print what we are about to do, and maybe query.  */
		IfStatement:if (verbose_flag)
			Condition:verbose_flag
				Identifier:verbose_flag
			CompoundStatement:
				Statement:/* For help listings, put a blank line between sub-processes.  */
				IfStatement:if (print_help_list)
					Condition:print_help_list
						Identifier:print_help_list
					ExpressionStatement:fputc ('\n', stderr)
						CallExpression:fputc ('\n', stderr)
							Callee:fputc
								Identifier:fputc
							ArgumentList:'\n'
								Argument:'\n'
									Constant:'\n'
								Argument:stderr
									Identifier:stderr
				Statement:/* Print each piped command as a separate line.  */
				ForStatement:for (i = 0; i < n_commands; i++)
					ForInit:i = 0;
						AssignmentExpression:i = 0
							Identifier:i
							Constant:0
					Condition:i < n_commands
						RelationalExpression:i < n_commands
							Identifier:i
							Identifier:n_commands
					PostIncDecOperationExpression:i++
						Identifier:i
						IncDec:++
					CompoundStatement:
						IdentifierDeclStatement:const char *const *j;
							IdentifierDecl:*const *j
								IdentifierDeclType:const char * const *
								Identifier:j
						IfStatement:if (verbose_only_flag)
							Condition:verbose_only_flag
								Identifier:verbose_only_flag
							CompoundStatement:
								ForStatement:for (j = commands[i].argv; *j; j++)
									ForInit:j = commands[i].argv;
										AssignmentExpression:j = commands[i].argv
											Identifier:j
											MemberAccess:commands[i].argv
												ArrayIndexing:commands[i]
													Identifier:commands
													Identifier:i
												Identifier:argv
									Condition:*j
										UnaryOperationExpression:*j
											UnaryOperator:*
											Identifier:j
									PostIncDecOperationExpression:j++
										Identifier:j
										IncDec:++
									CompoundStatement:
										IdentifierDeclStatement:const char *p;
											IdentifierDecl:*p
												IdentifierDeclType:const char *
												Identifier:p
										ForStatement:for (p = *j; *p; ++p)
											ForInit:p = *j;
												AssignmentExpression:p = *j
													Identifier:p
													UnaryOperationExpression:*j
														UnaryOperator:*
														Identifier:j
											Condition:*p
												UnaryOperationExpression:*p
													UnaryOperator:*
													Identifier:p
											UnaryExpression:++p
												IncDec:++
												Identifier:p
											IfStatement:if (!ISALNUM ((unsigned char) *p)\t\t\t&& *p != '_' && *p != '/' && *p != '-' && *p != '.')
												Condition:!ISALNUM ((unsigned char) *p)\t\t\t&& *p != '_' && *p != '/' && *p != '-' && *p != '.'
													AndExpression:!ISALNUM ((unsigned char) *p)\t\t\t&& *p != '_' && *p != '/' && *p != '-' && *p != '.'
														UnaryOperationExpression:!ISALNUM ((unsigned char) *p)
															UnaryOperator:!
															CallExpression:ISALNUM ((unsigned char) *p)
																Callee:ISALNUM
																	Identifier:ISALNUM
																ArgumentList:(unsigned char) *p
																	Argument:(unsigned char) *p
																		CastExpression:(unsigned char) *p
																			CastTarget:unsigned char
																			UnaryOperationExpression:*p
																				UnaryOperator:*
																				Identifier:p
														AndExpression:*p != '_' && *p != '/' && *p != '-' && *p != '.'
															EqualityExpression:*p != '_'
																UnaryOperationExpression:*p
																	UnaryOperator:*
																	Identifier:p
																Constant:'_'
															AndExpression:*p != '/' && *p != '-' && *p != '.'
																EqualityExpression:*p != '/'
																	UnaryOperationExpression:*p
																		UnaryOperator:*
																		Identifier:p
																	Constant:'/'
																AndExpression:*p != '-' && *p != '.'
																	EqualityExpression:*p != '-'
																		UnaryOperationExpression:*p
																			UnaryOperator:*
																			Identifier:p
																		Constant:'-'
																	EqualityExpression:*p != '.'
																		UnaryOperationExpression:*p
																			UnaryOperator:*
																			Identifier:p
																		Constant:'.'
												BreakStatement:break;
										IfStatement:if (*p || !*j)
											Condition:*p || !*j
												OrExpression:*p || !*j
													UnaryOperationExpression:*p
														UnaryOperator:*
														Identifier:p
													UnaryOperationExpression:!*j
														UnaryOperator:!
														UnaryOperationExpression:*j
															UnaryOperator:*
															Identifier:j
											CompoundStatement:
												ExpressionStatement:fprintf (stderr, " \"")
													CallExpression:fprintf (stderr, " \"")
														Callee:fprintf
															Identifier:fprintf
														ArgumentList:stderr
															Argument:stderr
																Identifier:stderr
															Argument:" \""
																Constant:" \""
												ForStatement:for (p = *j; *p; ++p)
													ForInit:p = *j;
														AssignmentExpression:p = *j
															Identifier:p
															UnaryOperationExpression:*j
																UnaryOperator:*
																Identifier:j
													Condition:*p
														UnaryOperationExpression:*p
															UnaryOperator:*
															Identifier:p
													UnaryExpression:++p
														IncDec:++
														Identifier:p
													CompoundStatement:
														IfStatement:if (*p == '"' || *p == '\\' || *p == '$')
															Condition:*p == '"' || *p == '\\' || *p == '$'
																OrExpression:*p == '"' || *p == '\\' || *p == '$'
																	EqualityExpression:*p == '"'
																		UnaryOperationExpression:*p
																			UnaryOperator:*
																			Identifier:p
																		Constant:'"'
																	OrExpression:*p == '\\' || *p == '$'
																		EqualityExpression:*p == '\\'
																			UnaryOperationExpression:*p
																				UnaryOperator:*
																				Identifier:p
																			Constant:'\\'
																		EqualityExpression:*p == '$'
																			UnaryOperationExpression:*p
																				UnaryOperator:*
																				Identifier:p
																			Constant:'$'
															ExpressionStatement:fputc ('\\', stderr)
																CallExpression:fputc ('\\', stderr)
																	Callee:fputc
																		Identifier:fputc
																	ArgumentList:'\\'
																		Argument:'\\'
																			Constant:'\\'
																		Argument:stderr
																			Identifier:stderr
														ExpressionStatement:fputc (*p, stderr)
															CallExpression:fputc (*p, stderr)
																Callee:fputc
																	Identifier:fputc
																ArgumentList:*p
																	Argument:*p
																		UnaryOperationExpression:*p
																			UnaryOperator:*
																			Identifier:p
																	Argument:stderr
																		Identifier:stderr
												ExpressionStatement:fputc ('"', stderr)
													CallExpression:fputc ('"', stderr)
														Callee:fputc
															Identifier:fputc
														ArgumentList:'"'
															Argument:'"'
																Constant:'"'
															Argument:stderr
																Identifier:stderr
										Statement:/* If it's empty, print "".  */
						IfStatement:if (!**j)
							Condition:!**j
								UnaryOperationExpression:!**j
									UnaryOperator:!
									UnaryOperationExpression:**j
										UnaryOperator:*
										UnaryOperationExpression:*j
											UnaryOperator:*
											Identifier:j
							ExpressionStatement:fprintf (stderr, " \"\"")
								CallExpression:fprintf (stderr, " \"\"")
									Callee:fprintf
										Identifier:fprintf
									ArgumentList:stderr
										Argument:stderr
											Identifier:stderr
										Argument:" \"\""
											Constant:" \"\""
						Statement:/* Print a pipe symbol after all but the last command.  */
						IfStatement:if (i + 1 != n_commands)
							Condition:i + 1 != n_commands
								EqualityExpression:i + 1 != n_commands
									AdditiveExpression:i + 1
										Identifier:i
										Constant:1
									Identifier:n_commands
							ExpressionStatement:fprintf (stderr, " |")
								CallExpression:fprintf (stderr, " |")
									Callee:fprintf
										Identifier:fprintf
									ArgumentList:stderr
										Argument:stderr
											Identifier:stderr
										Argument:" |"
											Constant:" |"
						ExpressionStatement:fprintf (stderr, "\n")
							CallExpression:fprintf (stderr, "\n")
								Callee:fprintf
									Identifier:fprintf
								ArgumentList:stderr
									Argument:stderr
										Identifier:stderr
									Argument:"\n"
										Constant:"\n"
				ExpressionStatement:fflush (stderr)
					CallExpression:fflush (stderr)
						Callee:fflush
							Identifier:fflush
						ArgumentList:stderr
							Argument:stderr
								Identifier:stderr
				IfStatement:if (verbose_only_flag != 0)
					Condition:verbose_only_flag != 0
						EqualityExpression:verbose_only_flag != 0
							Identifier:verbose_only_flag
							Constant:0
					CompoundStatement:
						Statement:/* verbose_only_flag should act as if the spec was\t     executed, so increment execution_count before\t     returning.  This prevents spurious warnings about\t     unused linker input files, etc.  */
						ExpressionStatement:execution_count++
							PostIncDecOperationExpression:execution_count++
								Identifier:execution_count
								IncDec:++
						ReturnStatement:return 0;
							Constant:0
				IdentifierDeclStatement:ifdef DEBUG      fnotice (stderr, "\nGo ahead? (y or n) ");
					IdentifierDecl:fnotice (stderr, "\nGo ahead? (y or n) ")
						IdentifierDeclType:ifdef DEBUG
						Identifier:fnotice
						Expression:stderr, "\nGo ahead? (y or n) "
							Identifier:stderr
							Constant:"\nGo ahead? (y or n) "
				ExpressionStatement:fflush (stderr)
					CallExpression:fflush (stderr)
						Callee:fflush
							Identifier:fflush
						ArgumentList:stderr
							Argument:stderr
								Identifier:stderr
				ExpressionStatement:i = getchar ()
					AssignmentExpression:i = getchar ()
						Identifier:i
						CallExpression:getchar ()
							Callee:getchar
								Identifier:getchar
							ArgumentList:
				IfStatement:if (i != '\n')
					Condition:i != '\n'
						EqualityExpression:i != '\n'
							Identifier:i
							Constant:'\n'
					WhileStatement:while (getchar () != '\n')
						Condition:getchar () != '\n'
							EqualityExpression:getchar () != '\n'
								CallExpression:getchar ()
									Callee:getchar
										Identifier:getchar
									ArgumentList:
								Constant:'\n'
						ExpressionStatement:
				IfStatement:if (i != 'y' && i != 'Y')
					Condition:i != 'y' && i != 'Y'
						AndExpression:i != 'y' && i != 'Y'
							EqualityExpression:i != 'y'
								Identifier:i
								Constant:'y'
							EqualityExpression:i != 'Y'
								Identifier:i
								Constant:'Y'
					ReturnStatement:return 0;
						Constant:0
				Statement:endif
				Statement:/* DEBUG */
		Statement:ifdef
		Statement:ENABLE_VALGRIND_CHECKING
		Statement:/* Run the each command through valgrind.  To simplify prepending the     path to valgrind and the option "-q" (for quiet operation unless     something triggers), we allocate a separate argv array.  */
		ForStatement:for (i = 0; i < n_commands; i++)
			ForInit:i = 0;
				AssignmentExpression:i = 0
					Identifier:i
					Constant:0
			Condition:i < n_commands
				RelationalExpression:i < n_commands
					Identifier:i
					Identifier:n_commands
			PostIncDecOperationExpression:i++
				Identifier:i
				IncDec:++
			CompoundStatement:
				IdentifierDeclStatement:const char **argv;
					IdentifierDecl:**argv
						IdentifierDeclType:const char * *
						Identifier:argv
				IdentifierDeclStatement:int argc;
					IdentifierDecl:argc
						IdentifierDeclType:int
						Identifier:argc
				IdentifierDeclStatement:int j;
					IdentifierDecl:j
						IdentifierDeclType:int
						Identifier:j
				ForStatement:for (argc = 0; commands[i].argv[argc] != NULL; argc++)
					ForInit:argc = 0;
						AssignmentExpression:argc = 0
							Identifier:argc
							Constant:0
					Condition:commands[i].argv[argc] != NULL
						EqualityExpression:commands[i].argv[argc] != NULL
							ArrayIndexing:commands[i].argv[argc]
								MemberAccess:commands[i].argv
									ArrayIndexing:commands[i]
										Identifier:commands
										Identifier:i
									Identifier:argv
								Identifier:argc
							Identifier:NULL
					PostIncDecOperationExpression:argc++
						Identifier:argc
						IncDec:++
					ExpressionStatement:
				Statement:argv
				Statement:=
				Statement:XALLOCAVEC
				Statement:(
				Statement:const
				Statement:char
				Statement:*
				Statement:,
				Statement:argc
				Statement:+
				Statement:3
				Statement:)
				ExpressionStatement:
				ExpressionStatement:argv[0] = VALGRIND_PATH
					AssignmentExpression:argv[0] = VALGRIND_PATH
						ArrayIndexing:argv[0]
							Identifier:argv
							Constant:0
						Identifier:VALGRIND_PATH
				ExpressionStatement:argv[1] = "-q"
					AssignmentExpression:argv[1] = "-q"
						ArrayIndexing:argv[1]
							Identifier:argv
							Constant:1
						Constant:"-q"
				ForStatement:for (j = 2; j < argc + 2; j++)
					ForInit:j = 2;
						AssignmentExpression:j = 2
							Identifier:j
							Constant:2
					Condition:j < argc + 2
						RelationalExpression:j < argc + 2
							Identifier:j
							AdditiveExpression:argc + 2
								Identifier:argc
								Constant:2
					PostIncDecOperationExpression:j++
						Identifier:j
						IncDec:++
					ExpressionStatement:argv[j] = commands[i].argv[j - 2]
						AssignmentExpression:argv[j] = commands[i].argv[j - 2]
							ArrayIndexing:argv[j]
								Identifier:argv
								Identifier:j
							ArrayIndexing:commands[i].argv[j - 2]
								MemberAccess:commands[i].argv
									ArrayIndexing:commands[i]
										Identifier:commands
										Identifier:i
									Identifier:argv
								AdditiveExpression:j - 2
									Identifier:j
									Constant:2
				ExpressionStatement:argv[j] = NULL
					AssignmentExpression:argv[j] = NULL
						ArrayIndexing:argv[j]
							Identifier:argv
							Identifier:j
						Identifier:NULL
				ExpressionStatement:commands[i].argv = argv
					AssignmentExpression:commands[i].argv = argv
						MemberAccess:commands[i].argv
							ArrayIndexing:commands[i]
								Identifier:commands
								Identifier:i
							Identifier:argv
						Identifier:argv
				ExpressionStatement:commands[i].prog = argv[0]
					AssignmentExpression:commands[i].prog = argv[0]
						MemberAccess:commands[i].prog
							ArrayIndexing:commands[i]
								Identifier:commands
								Identifier:i
							Identifier:prog
						ArrayIndexing:argv[0]
							Identifier:argv
							Constant:0
		Statement:endif
		Statement:/* Run each piped subprocess.  */
		ExpressionStatement:pex = pex_init (PEX_USE_PIPES | ((report_times || report_times_to_file)\t\t\t\t   ? PEX_RECORD_TIMES : 0),\t\t  progname, temp_filename)
			AssignmentExpression:pex = pex_init (PEX_USE_PIPES | ((report_times || report_times_to_file)\t\t\t\t   ? PEX_RECORD_TIMES : 0),\t\t  progname, temp_filename)
				Identifier:pex
				CallExpression:pex_init (PEX_USE_PIPES | ((report_times || report_times_to_file)\t\t\t\t   ? PEX_RECORD_TIMES : 0),\t\t  progname, temp_filename)
					Callee:pex_init
						Identifier:pex_init
					ArgumentList:PEX_USE_PIPES | ((report_times || report_times_to_file)\t\t\t\t   ? PEX_RECORD_TIMES : 0)
						Argument:PEX_USE_PIPES | ((report_times || report_times_to_file)\t\t\t\t   ? PEX_RECORD_TIMES : 0)
							InclusiveOrExpression:PEX_USE_PIPES | ((report_times || report_times_to_file)\t\t\t\t   ? PEX_RECORD_TIMES : 0)
								Identifier:PEX_USE_PIPES
								ConditionalExpression:(report_times || report_times_to_file)\t\t\t\t   ? PEX_RECORD_TIMES : 0
									Condition:report_times || report_times_to_file
										OrExpression:report_times || report_times_to_file
											Identifier:report_times
											Identifier:report_times_to_file
									Identifier:PEX_RECORD_TIMES
									Constant:0
						Argument:progname
							Identifier:progname
						Argument:temp_filename
							Identifier:temp_filename
		IfStatement:if (pex == NULL)
			Condition:pex == NULL
				EqualityExpression:pex == NULL
					Identifier:pex
					Identifier:NULL
			ExpressionStatement:fatal_error (input_location, "pex_init failed: %m")
				CallExpression:fatal_error (input_location, "pex_init failed: %m")
					Callee:fatal_error
						Identifier:fatal_error
					ArgumentList:input_location
						Argument:input_location
							Identifier:input_location
						Argument:"pex_init failed: %m"
							Constant:"pex_init failed: %m"
		ForStatement:for (i = 0; i < n_commands; i++)
			ForInit:i = 0;
				AssignmentExpression:i = 0
					Identifier:i
					Constant:0
			Condition:i < n_commands
				RelationalExpression:i < n_commands
					Identifier:i
					Identifier:n_commands
			PostIncDecOperationExpression:i++
				Identifier:i
				IncDec:++
			CompoundStatement:
				IdentifierDeclStatement:const char *errmsg;
					IdentifierDecl:*errmsg
						IdentifierDeclType:const char *
						Identifier:errmsg
				IdentifierDeclStatement:int err;
					IdentifierDecl:err
						IdentifierDeclType:int
						Identifier:err
				IdentifierDeclStatement:const char *string = commands[i].argv[0];
					IdentifierDecl:*string = commands[i].argv[0]
						IdentifierDeclType:const char *
						Identifier:string
						AssignmentExpression:*string = commands[i].argv[0]
							Identifier:string
							ArrayIndexing:commands[i].argv[0]
								MemberAccess:commands[i].argv
									ArrayIndexing:commands[i]
										Identifier:commands
										Identifier:i
									Identifier:argv
								Constant:0
				Statement:errmsg
				Statement:=
				Statement:pex_run
				Statement:(
				Statement:pex
				Statement:,
				Statement:(
				Statement:(
				Statement:i
				Statement:+
				Statement:1
				Statement:==
				Statement:n_commands
				Statement:?
				Label:PEX_LAST :
					Identifier:PEX_LAST
				Statement:0
				Statement:)
				Statement:|
				Statement:(
				Statement:string
				Statement:==
				Statement:commands
				Statement:[
				Statement:i
				Statement:]
				Statement:.
				Statement:prog
				Statement:?
				Label:PEX_SEARCH :
					Identifier:PEX_SEARCH
				Statement:0
				Statement:)
				Statement:)
				Statement:,
				Statement:string
				Statement:,
				Statement:CONST_CAST
				Statement:(
				Statement:char
				Statement:*
				Statement:*
				Statement:,
				Statement:commands
				Statement:[
				Statement:i
				Statement:]
				Statement:.
				Statement:argv
				Statement:)
				Statement:,
				Statement:NULL
				Statement:,
				Statement:NULL
				Statement:,
				Statement:&
				Statement:err
				Statement:)
				ExpressionStatement:
				IfStatement:if (errmsg != NULL)
					Condition:errmsg != NULL
						EqualityExpression:errmsg != NULL
							Identifier:errmsg
							Identifier:NULL
					CompoundStatement:
						IfStatement:if (err == 0)
							Condition:err == 0
								EqualityExpression:err == 0
									Identifier:err
									Constant:0
							ExpressionStatement:fatal_error (input_location, errmsg)
								CallExpression:fatal_error (input_location, errmsg)
									Callee:fatal_error
										Identifier:fatal_error
									ArgumentList:input_location
										Argument:input_location
											Identifier:input_location
										Argument:errmsg
											Identifier:errmsg
				IfStatement:if (i && string != commands[i].prog)
					Condition:i && string != commands[i].prog
						AndExpression:i && string != commands[i].prog
							Identifier:i
							EqualityExpression:string != commands[i].prog
								Identifier:string
								MemberAccess:commands[i].prog
									ArrayIndexing:commands[i]
										Identifier:commands
										Identifier:i
									Identifier:prog
					Statement:free
				Statement:(
				Statement:CONST_CAST
				Statement:(
				Statement:char
				Statement:*
				Statement:,
				Statement:string
				Statement:)
				Statement:)
				ExpressionStatement:
		ExpressionStatement:execution_count++
			PostIncDecOperationExpression:execution_count++
				Identifier:execution_count
				IncDec:++
		Statement:/* Wait for all the subprocesses to finish.  */
		CompoundStatement:
			IdentifierDeclStatement:int *statuses;
				IdentifierDecl:*statuses
					IdentifierDeclType:int *
					Identifier:statuses
			IdentifierDeclStatement:struct pex_time *times = NULL;
				IdentifierDecl:*times = NULL
					IdentifierDeclType:struct pex_time *
					Identifier:times
					AssignmentExpression:*times = NULL
						Identifier:times
						Identifier:NULL
			IdentifierDeclStatement:int ret_code = 0;
				IdentifierDecl:ret_code = 0
					IdentifierDeclType:int
					Identifier:ret_code
					AssignmentExpression:ret_code = 0
						Identifier:ret_code
						Constant:0
			ExpressionStatement:statuses = (int *) alloca (n_commands * sizeof (int))
				AssignmentExpression:statuses = (int *) alloca (n_commands * sizeof (int))
					Identifier:statuses
					CastExpression:(int *) alloca (n_commands * sizeof (int))
						CastTarget:int *
						CallExpression:alloca (n_commands * sizeof (int))
							Callee:alloca
								Identifier:alloca
							ArgumentList:n_commands * sizeof (int)
								Argument:n_commands * sizeof (int)
									MultiplicativeExpression:n_commands * sizeof (int)
										Identifier:n_commands
										SizeofExpression:sizeof (int)
											Sizeof:sizeof
											Identifier:int
			IfStatement:if (!pex_get_status (pex, n_commands, statuses))
				Condition:!pex_get_status (pex, n_commands, statuses)
					UnaryOperationExpression:!pex_get_status (pex, n_commands, statuses)
						UnaryOperator:!
						CallExpression:pex_get_status (pex, n_commands, statuses)
							Callee:pex_get_status
								Identifier:pex_get_status
							ArgumentList:pex
								Argument:pex
									Identifier:pex
								Argument:n_commands
									Identifier:n_commands
								Argument:statuses
									Identifier:statuses
				ExpressionStatement:fatal_error (input_location, "failed to get exit status: %m")
					CallExpression:fatal_error (input_location, "failed to get exit status: %m")
						Callee:fatal_error
							Identifier:fatal_error
						ArgumentList:input_location
							Argument:input_location
								Identifier:input_location
							Argument:"failed to get exit status: %m"
								Constant:"failed to get exit status: %m"
			IfStatement:if (report_times || report_times_to_file)
				Condition:report_times || report_times_to_file
					OrExpression:report_times || report_times_to_file
						Identifier:report_times
						Identifier:report_times_to_file
				CompoundStatement:
					ExpressionStatement:times = (struct pex_time *) alloca (n_commands * sizeof (struct pex_time))
						AssignmentExpression:times = (struct pex_time *) alloca (n_commands * sizeof (struct pex_time))
							Identifier:times
							CastExpression:(struct pex_time *) alloca (n_commands * sizeof (struct pex_time))
								CastTarget:struct pex_time *
								CallExpression:alloca (n_commands * sizeof (struct pex_time))
									Callee:alloca
										Identifier:alloca
									ArgumentList:n_commands * sizeof (struct pex_time)
										Argument:n_commands * sizeof (struct pex_time)
											MultiplicativeExpression:n_commands * sizeof (struct pex_time)
												Identifier:n_commands
												SizeofExpression:sizeof (struct pex_time)
													Sizeof:sizeof
													SizeofOperand:struct pex_time
					IfStatement:if (!pex_get_times (pex, n_commands, times))
						Condition:!pex_get_times (pex, n_commands, times)
							UnaryOperationExpression:!pex_get_times (pex, n_commands, times)
								UnaryOperator:!
								CallExpression:pex_get_times (pex, n_commands, times)
									Callee:pex_get_times
										Identifier:pex_get_times
									ArgumentList:pex
										Argument:pex
											Identifier:pex
										Argument:n_commands
											Identifier:n_commands
										Argument:times
											Identifier:times
						ExpressionStatement:fatal_error (input_location, "failed to get process times: %m")
							CallExpression:fatal_error (input_location, "failed to get process times: %m")
								Callee:fatal_error
									Identifier:fatal_error
								ArgumentList:input_location
									Argument:input_location
										Identifier:input_location
									Argument:"failed to get process times: %m"
										Constant:"failed to get process times: %m"
			ExpressionStatement:pex_free (pex)
				CallExpression:pex_free (pex)
					Callee:pex_free
						Identifier:pex_free
					ArgumentList:pex
						Argument:pex
							Identifier:pex
			ForStatement:for (i = 0; i < n_commands; ++i)
				ForInit:i = 0;
					AssignmentExpression:i = 0
						Identifier:i
						Constant:0
				Condition:i < n_commands
					RelationalExpression:i < n_commands
						Identifier:i
						Identifier:n_commands
				UnaryExpression:++i
					IncDec:++
					Identifier:i
				CompoundStatement:
					IdentifierDeclStatement:int status = statuses[i];
						IdentifierDecl:status = statuses[i]
							IdentifierDeclType:int
							Identifier:status
							AssignmentExpression:status = statuses[i]
								Identifier:status
								ArrayIndexing:statuses[i]
									Identifier:statuses
									Identifier:i
					IfStatement:if (WIFSIGNALED (status))
						Condition:WIFSIGNALED (status)
							CallExpression:WIFSIGNALED (status)
								Callee:WIFSIGNALED
									Identifier:WIFSIGNALED
								ArgumentList:status
									Argument:status
										Identifier:status
						SwitchStatement:switch (WTERMSIG (status))
							Condition:WTERMSIG (status)
								CallExpression:WTERMSIG (status)
									Callee:WTERMSIG
										Identifier:WTERMSIG
									ArgumentList:status
										Argument:status
											Identifier:status
							CompoundStatement:
								Label:case SIGINT:
									Identifier:SIGINT
								Label:case SIGTERM:
									Identifier:SIGTERM
								Statement:/* SIGQUIT and SIGKILL are not available on MinGW.  */
								Statement:ifdef
								Statement:SIGQUIT
								Label:case SIGQUIT:
									Identifier:SIGQUIT
								Statement:endif
								Statement:ifdef
								Statement:SIGKILL
								Label:case SIGKILL:
									Identifier:SIGKILL
								Statement:endif
								Statement:/* The user (or environment) did something to the\t\t inferior.  Making this an ICE confuses the user into\t\t thinking there's a compiler bug.  Much more likely is\t\t the user or OOM killer nuked it.  */
								ExpressionStatement:fatal_error (input_location,\t\t\t   "%s signal terminated program %s",\t\t\t   strsignal (WTERMSIG (status)),\t\t\t   commands[i].prog)
									CallExpression:fatal_error (input_location,\t\t\t   "%s signal terminated program %s",\t\t\t   strsignal (WTERMSIG (status)),\t\t\t   commands[i].prog)
										Callee:fatal_error
											Identifier:fatal_error
										ArgumentList:input_location
											Argument:input_location
												Identifier:input_location
											Argument:"%s signal terminated program %s"
												Constant:"%s signal terminated program %s"
											Argument:strsignal (WTERMSIG (status))
												CallExpression:strsignal (WTERMSIG (status))
													Callee:strsignal
														Identifier:strsignal
													ArgumentList:WTERMSIG (status)
														Argument:WTERMSIG (status)
															CallExpression:WTERMSIG (status)
																Callee:WTERMSIG
																	Identifier:WTERMSIG
																ArgumentList:status
																	Argument:status
																		Identifier:status
											Argument:commands[i].prog
												MemberAccess:commands[i].prog
													ArrayIndexing:commands[i]
														Identifier:commands
														Identifier:i
													Identifier:prog
								BreakStatement:break;
								Statement:ifdef
								Statement:SIGPIPE
								Label:case SIGPIPE:
									Identifier:SIGPIPE
								Statement:/* SIGPIPE is a special case.  It happens in -pipe mode\t\t when the compiler dies before the preprocessor is\t\t done, or the assembler dies before the compiler is\t\t done.  There's generally been an error already, and\t\t this is just fallout.  So don't generate another\t\t error unless we would otherwise have succeeded.  */
								IfStatement:if (signal_count || greatest_status >= MIN_FATAL_STATUS)
									Condition:signal_count || greatest_status >= MIN_FATAL_STATUS
										OrExpression:signal_count || greatest_status >= MIN_FATAL_STATUS
											Identifier:signal_count
											RelationalExpression:greatest_status >= MIN_FATAL_STATUS
												Identifier:greatest_status
												Identifier:MIN_FATAL_STATUS
									CompoundStatement:
										ExpressionStatement:signal_count++
											PostIncDecOperationExpression:signal_count++
												Identifier:signal_count
												IncDec:++
										ExpressionStatement:ret_code = -1
											AssignmentExpression:ret_code = -1
												Identifier:ret_code
												UnaryOperationExpression:-1
													UnaryOperator:-
													Constant:1
										BreakStatement:break;
								Statement:endif
								Statement:/* FALLTHROUGH */
								Label:default:
									Identifier:default
								Statement:/* The inferior failed to catch the signal.  */
								ExpressionStatement:internal_error_no_backtrace ("%s signal terminated program %s",\t\t\t\t\t   strsignal (WTERMSIG (status)),\t\t\t\t\t   commands[i].prog)
									CallExpression:internal_error_no_backtrace ("%s signal terminated program %s",\t\t\t\t\t   strsignal (WTERMSIG (status)),\t\t\t\t\t   commands[i].prog)
										Callee:internal_error_no_backtrace
											Identifier:internal_error_no_backtrace
										ArgumentList:"%s signal terminated program %s"
											Argument:"%s signal terminated program %s"
												Constant:"%s signal terminated program %s"
											Argument:strsignal (WTERMSIG (status))
												CallExpression:strsignal (WTERMSIG (status))
													Callee:strsignal
														Identifier:strsignal
													ArgumentList:WTERMSIG (status)
														Argument:WTERMSIG (status)
															CallExpression:WTERMSIG (status)
																Callee:WTERMSIG
																	Identifier:WTERMSIG
																ArgumentList:status
																	Argument:status
																		Identifier:status
											Argument:commands[i].prog
												MemberAccess:commands[i].prog
													ArrayIndexing:commands[i]
														Identifier:commands
														Identifier:i
													Identifier:prog
					IfStatement:if (report_times || report_times_to_file)
						Condition:report_times || report_times_to_file
							OrExpression:report_times || report_times_to_file
								Identifier:report_times
								Identifier:report_times_to_file
						CompoundStatement:
							IdentifierDeclStatement:struct pex_time *pt = &times[i];
								IdentifierDecl:*pt = &times[i]
									IdentifierDeclType:struct pex_time *
									Identifier:pt
									AssignmentExpression:*pt = &times[i]
										Identifier:pt
										UnaryOperationExpression:&times[i]
											UnaryOperator:&
											ArrayIndexing:times[i]
												Identifier:times
												Identifier:i
							IdentifierDeclStatement:double ut, st;
								IdentifierDecl:ut
									IdentifierDeclType:double
									Identifier:ut
								IdentifierDecl:st
									IdentifierDeclType:double
									Identifier:st
							ExpressionStatement:ut = ((double) pt->user_seconds\t\t  + (double) pt->user_microseconds / 1.0e6)
								AssignmentExpression:ut = ((double) pt->user_seconds\t\t  + (double) pt->user_microseconds / 1.0e6)
									Identifier:ut
									AdditiveExpression:(double) pt->user_seconds\t\t  + (double) pt->user_microseconds / 1.0e6
										CastExpression:(double) pt->user_seconds
											CastTarget:double
											PtrMemberAccess:pt->user_seconds
												Identifier:pt
												Identifier:user_seconds
										MultiplicativeExpression:(double) pt->user_microseconds / 1.0e6
											CastExpression:(double) pt->user_microseconds
												CastTarget:double
												PtrMemberAccess:pt->user_microseconds
													Identifier:pt
													Identifier:user_microseconds
											Constant:1.0e6
							ExpressionStatement:st = ((double) pt->system_seconds\t\t  + (double) pt->system_microseconds / 1.0e6)
								AssignmentExpression:st = ((double) pt->system_seconds\t\t  + (double) pt->system_microseconds / 1.0e6)
									Identifier:st
									AdditiveExpression:(double) pt->system_seconds\t\t  + (double) pt->system_microseconds / 1.0e6
										CastExpression:(double) pt->system_seconds
											CastTarget:double
											PtrMemberAccess:pt->system_seconds
												Identifier:pt
												Identifier:system_seconds
										MultiplicativeExpression:(double) pt->system_microseconds / 1.0e6
											CastExpression:(double) pt->system_microseconds
												CastTarget:double
												PtrMemberAccess:pt->system_microseconds
													Identifier:pt
													Identifier:system_microseconds
											Constant:1.0e6
							IfStatement:if (ut + st != 0)
								Condition:ut + st != 0
									EqualityExpression:ut + st != 0
										AdditiveExpression:ut + st
											Identifier:ut
											Identifier:st
										Constant:0
								CompoundStatement:
									IfStatement:if (report_times)
										Condition:report_times
											Identifier:report_times
										ExpressionStatement:fnotice (stderr, "# %s %.2f %.2f\n",\t\t\t   commands[i].prog, ut, st)
											CallExpression:fnotice (stderr, "# %s %.2f %.2f\n",\t\t\t   commands[i].prog, ut, st)
												Callee:fnotice
													Identifier:fnotice
												ArgumentList:stderr
													Argument:stderr
														Identifier:stderr
													Argument:"# %s %.2f %.2f\n"
														Constant:"# %s %.2f %.2f\n"
													Argument:commands[i].prog
														MemberAccess:commands[i].prog
															ArrayIndexing:commands[i]
																Identifier:commands
																Identifier:i
															Identifier:prog
													Argument:ut
														Identifier:ut
													Argument:st
														Identifier:st
									IfStatement:if (report_times_to_file)
										Condition:report_times_to_file
											Identifier:report_times_to_file
										CompoundStatement:
											IdentifierDeclStatement:int c = 0;
												IdentifierDecl:c = 0
													IdentifierDeclType:int
													Identifier:c
													AssignmentExpression:c = 0
														Identifier:c
														Constant:0
											IdentifierDeclStatement:const char *const *j;
												IdentifierDecl:*const *j
													IdentifierDeclType:const char * const *
													Identifier:j
											ExpressionStatement:fprintf (report_times_to_file, "%g %g", ut, st)
												CallExpression:fprintf (report_times_to_file, "%g %g", ut, st)
													Callee:fprintf
														Identifier:fprintf
													ArgumentList:report_times_to_file
														Argument:report_times_to_file
															Identifier:report_times_to_file
														Argument:"%g %g"
															Constant:"%g %g"
														Argument:ut
															Identifier:ut
														Argument:st
															Identifier:st
											ForStatement:for (j = &commands[i].prog; *j; j = &commands[i].argv[++c])
												ForInit:j = &commands[i].prog;
													AssignmentExpression:j = &commands[i].prog
														Identifier:j
														UnaryOperationExpression:&commands[i].prog
															UnaryOperator:&
															MemberAccess:commands[i].prog
																ArrayIndexing:commands[i]
																	Identifier:commands
																	Identifier:i
																Identifier:prog
												Condition:*j
													UnaryOperationExpression:*j
														UnaryOperator:*
														Identifier:j
												AssignmentExpression:j = &commands[i].argv[++c]
													Identifier:j
													UnaryOperationExpression:&commands[i].argv[++c]
														UnaryOperator:&
														ArrayIndexing:commands[i].argv[++c]
															MemberAccess:commands[i].argv
																ArrayIndexing:commands[i]
																	Identifier:commands
																	Identifier:i
																Identifier:argv
															UnaryExpression:++c
																IncDec:++
																Identifier:c
												CompoundStatement:
													IdentifierDeclStatement:const char *p;
														IdentifierDecl:*p
															IdentifierDeclType:const char *
															Identifier:p
													ForStatement:for (p = *j; *p; ++p)
														ForInit:p = *j;
															AssignmentExpression:p = *j
																Identifier:p
																UnaryOperationExpression:*j
																	UnaryOperator:*
																	Identifier:j
														Condition:*p
															UnaryOperationExpression:*p
																UnaryOperator:*
																Identifier:p
														UnaryExpression:++p
															IncDec:++
															Identifier:p
														IfStatement:if (*p == '"' || *p == '\\' || *p == '$'\t\t\t      || ISSPACE (*p))
															Condition:*p == '"' || *p == '\\' || *p == '$'\t\t\t      || ISSPACE (*p)
																OrExpression:*p == '"' || *p == '\\' || *p == '$'\t\t\t      || ISSPACE (*p)
																	EqualityExpression:*p == '"'
																		UnaryOperationExpression:*p
																			UnaryOperator:*
																			Identifier:p
																		Constant:'"'
																	OrExpression:*p == '\\' || *p == '$'\t\t\t      || ISSPACE (*p)
																		EqualityExpression:*p == '\\'
																			UnaryOperationExpression:*p
																				UnaryOperator:*
																				Identifier:p
																			Constant:'\\'
																		OrExpression:*p == '$'\t\t\t      || ISSPACE (*p)
																			EqualityExpression:*p == '$'
																				UnaryOperationExpression:*p
																					UnaryOperator:*
																					Identifier:p
																				Constant:'$'
																			CallExpression:ISSPACE (*p)
																				Callee:ISSPACE
																					Identifier:ISSPACE
																				ArgumentList:*p
																					Argument:*p
																						UnaryOperationExpression:*p
																							UnaryOperator:*
																							Identifier:p
															BreakStatement:break;
													IfStatement:if (*p)
														Condition:*p
															UnaryOperationExpression:*p
																UnaryOperator:*
																Identifier:p
														CompoundStatement:
															ExpressionStatement:fprintf (report_times_to_file, " \"")
																CallExpression:fprintf (report_times_to_file, " \"")
																	Callee:fprintf
																		Identifier:fprintf
																	ArgumentList:report_times_to_file
																		Argument:report_times_to_file
																			Identifier:report_times_to_file
																		Argument:" \""
																			Constant:" \""
															ForStatement:for (p = *j; *p; ++p)
																ForInit:p = *j;
																	AssignmentExpression:p = *j
																		Identifier:p
																		UnaryOperationExpression:*j
																			UnaryOperator:*
																			Identifier:j
																Condition:*p
																	UnaryOperationExpression:*p
																		UnaryOperator:*
																		Identifier:p
																UnaryExpression:++p
																	IncDec:++
																	Identifier:p
																CompoundStatement:
																	IfStatement:if (*p == '"' || *p == '\\' || *p == '$')
																		Condition:*p == '"' || *p == '\\' || *p == '$'
																			OrExpression:*p == '"' || *p == '\\' || *p == '$'
																				EqualityExpression:*p == '"'
																					UnaryOperationExpression:*p
																						UnaryOperator:*
																						Identifier:p
																					Constant:'"'
																				OrExpression:*p == '\\' || *p == '$'
																					EqualityExpression:*p == '\\'
																						UnaryOperationExpression:*p
																							UnaryOperator:*
																							Identifier:p
																						Constant:'\\'
																					EqualityExpression:*p == '$'
																						UnaryOperationExpression:*p
																							UnaryOperator:*
																							Identifier:p
																						Constant:'$'
																		ExpressionStatement:fputc ('\\', report_times_to_file)
																			CallExpression:fputc ('\\', report_times_to_file)
																				Callee:fputc
																					Identifier:fputc
																				ArgumentList:'\\'
																					Argument:'\\'
																						Constant:'\\'
																					Argument:report_times_to_file
																						Identifier:report_times_to_file
																	ExpressionStatement:fputc (*p, report_times_to_file)
																		CallExpression:fputc (*p, report_times_to_file)
																			Callee:fputc
																				Identifier:fputc
																			ArgumentList:*p
																				Argument:*p
																					UnaryOperationExpression:*p
																						UnaryOperator:*
																						Identifier:p
																				Argument:report_times_to_file
																					Identifier:report_times_to_file
															ExpressionStatement:fputc ('"', report_times_to_file)
																CallExpression:fputc ('"', report_times_to_file)
																	Callee:fputc
																		Identifier:fputc
																	ArgumentList:'"'
																		Argument:'"'
																			Constant:'"'
																		Argument:report_times_to_file
																			Identifier:report_times_to_file
											ExpressionStatement:fputc ('\n', report_times_to_file)
												CallExpression:fputc ('\n', report_times_to_file)
													Callee:fputc
														Identifier:fputc
													ArgumentList:'\n'
														Argument:'\n'
															Constant:'\n'
														Argument:report_times_to_file
															Identifier:report_times_to_file
			IfStatement:if (commands[0].argv[0] != commands[0].prog)
				Condition:commands[0].argv[0] != commands[0].prog
					EqualityExpression:commands[0].argv[0] != commands[0].prog
						ArrayIndexing:commands[0].argv[0]
							MemberAccess:commands[0].argv
								ArrayIndexing:commands[0]
									Identifier:commands
									Constant:0
								Identifier:argv
							Constant:0
						MemberAccess:commands[0].prog
							ArrayIndexing:commands[0]
								Identifier:commands
								Constant:0
							Identifier:prog
				Statement:free
			Statement:(
			Statement:CONST_CAST
			Statement:(
			Statement:char
			Statement:*
			Statement:,
			Statement:commands
			Statement:[
			Statement:0
			Statement:]
			Statement:.
			Statement:argv
			Statement:[
			Statement:0
			Statement:]
			Statement:)
			Statement:)
			ExpressionStatement:
			ReturnStatement:return ret_code;
				Identifier:ret_code
	Identifier:intexecute
	ParameterList:
ClassDef:switchstr
	CompoundStatement:
		IdentifierDeclStatement:null
			IdentifierDecl:*part1
				IdentifierDeclType:const char *
				Identifier:part1
		IdentifierDeclStatement:null
			IdentifierDecl:**args
				IdentifierDeclType:const char * *
				Identifier:args
		IdentifierDeclStatement:null
			IdentifierDecl:live_cond
				IdentifierDeclType:unsigned int
				Identifier:live_cond
		IdentifierDeclStatement:null
			IdentifierDecl:known
				IdentifierDeclType:bool
				Identifier:known
		IdentifierDeclStatement:null
			IdentifierDecl:validated
				IdentifierDeclType:bool
				Identifier:validated
		IdentifierDeclStatement:null
			IdentifierDecl:ordering
				IdentifierDeclType:bool
				Identifier:ordering
IdentifierDeclStatement:null
	IdentifierDecl:*switches
		IdentifierDeclType:struct switchstr *
		Identifier:switches
IdentifierDeclStatement:null
	IdentifierDecl:n_switches
		IdentifierDeclType:int
		Identifier:n_switches
IdentifierDeclStatement:null
	IdentifierDecl:n_switches_alloc
		IdentifierDeclType:int
		Identifier:n_switches_alloc
IdentifierDeclStatement:null
	IdentifierDecl:compare_debug
		IdentifierDeclType:int
		Identifier:compare_debug
IdentifierDeclStatement:null
	IdentifierDecl:compare_debug_second
		IdentifierDeclType:int
		Identifier:compare_debug_second
IdentifierDeclStatement:null
	IdentifierDecl:*compare_debug_opt
		IdentifierDeclType:const char *
		Identifier:compare_debug_opt
IdentifierDeclStatement:null
	IdentifierDecl:*switches_debug_check[2]
		IdentifierDeclType:struct switchstr * [ 2 ]
		Identifier:switches_debug_check
IdentifierDeclStatement:null
	IdentifierDecl:n_switches_debug_check[2]
		IdentifierDeclType:int [ 2 ]
		Identifier:n_switches_debug_check
IdentifierDeclStatement:null
	IdentifierDecl:n_switches_alloc_debug_check[2]
		IdentifierDeclType:int [ 2 ]
		Identifier:n_switches_alloc_debug_check
IdentifierDeclStatement:null
	IdentifierDecl:*debug_check_temp_file[2]
		IdentifierDeclType:char * [ 2 ]
		Identifier:debug_check_temp_file
ClassDef:infile
	CompoundStatement:
		IdentifierDeclStatement:null
			IdentifierDecl:*name
				IdentifierDeclType:const char *
				Identifier:name
		IdentifierDeclStatement:null
			IdentifierDecl:*language
				IdentifierDeclType:const char *
				Identifier:language
		IdentifierDeclStatement:null
			IdentifierDecl:*incompiler
				IdentifierDeclType:struct compiler *
				Identifier:incompiler
		IdentifierDeclStatement:null
			IdentifierDecl:compiled
				IdentifierDeclType:bool
				Identifier:compiled
		IdentifierDeclStatement:null
			IdentifierDecl:preprocessed
				IdentifierDeclType:bool
				Identifier:preprocessed
IdentifierDeclStatement:null
	IdentifierDecl:*infiles
		IdentifierDeclType:struct infile *
		Identifier:infiles
IdentifierDeclStatement:null
	IdentifierDecl:n_infiles
		IdentifierDeclType:int
		Identifier:n_infiles
IdentifierDeclStatement:null
	IdentifierDecl:n_infiles_alloc
		IdentifierDeclType:int
		Identifier:n_infiles_alloc
IdentifierDeclStatement:null
	IdentifierDecl:spec_undefvar_allowed
		IdentifierDeclType:bool
		Identifier:spec_undefvar_allowed
IdentifierDeclStatement:null
	IdentifierDecl:combine_inputs
		IdentifierDeclType:bool
		Identifier:combine_inputs
IdentifierDeclStatement:null
	IdentifierDecl:added_libraries
		IdentifierDeclType:int
		Identifier:added_libraries
IdentifierDeclStatement:null
	IdentifierDecl:**outfiles
		IdentifierDeclType:const char * *
		Identifier:outfiles
FunctionDef:convert_filename (const char *name , int do_exe ATTRIBUTE_UNUSED , int do_obj ATTRIBUTE_UNUSED)
	CompoundStatement:
		Statement:if
		Statement:defined
		Statement:(
		Statement:HAVE_TARGET_EXECUTABLE_SUFFIX
		Statement:)
		IdentifierDeclStatement:int i;
			IdentifierDecl:i
				IdentifierDeclType:int
				Identifier:i
		IdentifierDeclStatement:endif  int len;
			IdentifierDecl:len
				IdentifierDeclType:endif int
				Identifier:len
		IfStatement:if (name == NULL)
			Condition:name == NULL
				EqualityExpression:name == NULL
					Identifier:name
					Identifier:NULL
			ReturnStatement:return NULL;
				Identifier:NULL
		ExpressionStatement:len = strlen (name)
			AssignmentExpression:len = strlen (name)
				Identifier:len
				CallExpression:strlen (name)
					Callee:strlen
						Identifier:strlen
					ArgumentList:name
						Argument:name
							Identifier:name
		Statement:ifdef
		Statement:HAVE_TARGET_OBJECT_SUFFIX
		Statement:/* Convert x.o to x.obj if TARGET_OBJECT_SUFFIX is ".obj".  */
		IfStatement:if (do_obj && len > 2      && name[len - 2] == '.'      && name[len - 1] == 'o')
			Condition:do_obj && len > 2      && name[len - 2] == '.'      && name[len - 1] == 'o'
				AndExpression:do_obj && len > 2      && name[len - 2] == '.'      && name[len - 1] == 'o'
					Identifier:do_obj
					AndExpression:len > 2      && name[len - 2] == '.'      && name[len - 1] == 'o'
						RelationalExpression:len > 2
							Identifier:len
							Constant:2
						AndExpression:name[len - 2] == '.'      && name[len - 1] == 'o'
							EqualityExpression:name[len - 2] == '.'
								ArrayIndexing:name[len - 2]
									Identifier:name
									AdditiveExpression:len - 2
										Identifier:len
										Constant:2
								Constant:'.'
							EqualityExpression:name[len - 1] == 'o'
								ArrayIndexing:name[len - 1]
									Identifier:name
									AdditiveExpression:len - 1
										Identifier:len
										Constant:1
								Constant:'o'
			CompoundStatement:
				ExpressionStatement:obstack_grow (&obstack, name, len - 2)
					CallExpression:obstack_grow (&obstack, name, len - 2)
						Callee:obstack_grow
							Identifier:obstack_grow
						ArgumentList:&obstack
							Argument:&obstack
								UnaryOperationExpression:&obstack
									UnaryOperator:&
									Identifier:obstack
							Argument:name
								Identifier:name
							Argument:len - 2
								AdditiveExpression:len - 2
									Identifier:len
									Constant:2
				ExpressionStatement:obstack_grow0 (&obstack, TARGET_OBJECT_SUFFIX, strlen (TARGET_OBJECT_SUFFIX))
					CallExpression:obstack_grow0 (&obstack, TARGET_OBJECT_SUFFIX, strlen (TARGET_OBJECT_SUFFIX))
						Callee:obstack_grow0
							Identifier:obstack_grow0
						ArgumentList:&obstack
							Argument:&obstack
								UnaryOperationExpression:&obstack
									UnaryOperator:&
									Identifier:obstack
							Argument:TARGET_OBJECT_SUFFIX
								Identifier:TARGET_OBJECT_SUFFIX
							Argument:strlen (TARGET_OBJECT_SUFFIX)
								CallExpression:strlen (TARGET_OBJECT_SUFFIX)
									Callee:strlen
										Identifier:strlen
									ArgumentList:TARGET_OBJECT_SUFFIX
										Argument:TARGET_OBJECT_SUFFIX
											Identifier:TARGET_OBJECT_SUFFIX
				Statement:name
				Statement:=
				Statement:XOBFINISH
				Statement:(
				Statement:&
				Statement:obstack
				Statement:,
				Statement:const
				Statement:char
				Statement:*
				Statement:)
				ExpressionStatement:
		Statement:endif
		Statement:if
		Statement:defined
		Statement:(
		Statement:HAVE_TARGET_EXECUTABLE_SUFFIX
		Statement:)
		Statement:/* If there is no filetype, make it the executable suffix (which includes     the ".").  But don't get confused if we have just "-o".  */
		IfStatement:if (! do_exe || TARGET_EXECUTABLE_SUFFIX[0] == 0 || (len == 2 && name[0] == '-'))
			Condition:! do_exe || TARGET_EXECUTABLE_SUFFIX[0] == 0 || (len == 2 && name[0] == '-')
				OrExpression:! do_exe || TARGET_EXECUTABLE_SUFFIX[0] == 0 || (len == 2 && name[0] == '-')
					UnaryOperationExpression:! do_exe
						UnaryOperator:!
						Identifier:do_exe
					OrExpression:TARGET_EXECUTABLE_SUFFIX[0] == 0 || (len == 2 && name[0] == '-')
						EqualityExpression:TARGET_EXECUTABLE_SUFFIX[0] == 0
							ArrayIndexing:TARGET_EXECUTABLE_SUFFIX[0]
								Identifier:TARGET_EXECUTABLE_SUFFIX
								Constant:0
							Constant:0
						AndExpression:len == 2 && name[0] == '-'
							EqualityExpression:len == 2
								Identifier:len
								Constant:2
							EqualityExpression:name[0] == '-'
								ArrayIndexing:name[0]
									Identifier:name
									Constant:0
								Constant:'-'
			ReturnStatement:return name;
				Identifier:name
		ForStatement:for (i = len - 1; i >= 0; i--)
			ForInit:i = len - 1;
				AssignmentExpression:i = len - 1
					Identifier:i
					AdditiveExpression:len - 1
						Identifier:len
						Constant:1
			Condition:i >= 0
				RelationalExpression:i >= 0
					Identifier:i
					Constant:0
			PostIncDecOperationExpression:i--
				Identifier:i
				IncDec:--
			IfStatement:if (IS_DIR_SEPARATOR (name[i]))
				Condition:IS_DIR_SEPARATOR (name[i])
					CallExpression:IS_DIR_SEPARATOR (name[i])
						Callee:IS_DIR_SEPARATOR
							Identifier:IS_DIR_SEPARATOR
						ArgumentList:name[i]
							Argument:name[i]
								ArrayIndexing:name[i]
									Identifier:name
									Identifier:i
				BreakStatement:break;
		ForStatement:for (i++; i < len; i++)
			ForInit:i++;
				PostIncDecOperationExpression:i++
					Identifier:i
					IncDec:++
			Condition:i < len
				RelationalExpression:i < len
					Identifier:i
					Identifier:len
			PostIncDecOperationExpression:i++
				Identifier:i
				IncDec:++
			IfStatement:if (name[i] == '.')
				Condition:name[i] == '.'
					EqualityExpression:name[i] == '.'
						ArrayIndexing:name[i]
							Identifier:name
							Identifier:i
						Constant:'.'
				ReturnStatement:return name;
					Identifier:name
		ExpressionStatement:obstack_grow (&obstack, name, len)
			CallExpression:obstack_grow (&obstack, name, len)
				Callee:obstack_grow
					Identifier:obstack_grow
				ArgumentList:&obstack
					Argument:&obstack
						UnaryOperationExpression:&obstack
							UnaryOperator:&
							Identifier:obstack
					Argument:name
						Identifier:name
					Argument:len
						Identifier:len
		ExpressionStatement:obstack_grow0 (&obstack, TARGET_EXECUTABLE_SUFFIX,\t\t strlen (TARGET_EXECUTABLE_SUFFIX))
			CallExpression:obstack_grow0 (&obstack, TARGET_EXECUTABLE_SUFFIX,\t\t strlen (TARGET_EXECUTABLE_SUFFIX))
				Callee:obstack_grow0
					Identifier:obstack_grow0
				ArgumentList:&obstack
					Argument:&obstack
						UnaryOperationExpression:&obstack
							UnaryOperator:&
							Identifier:obstack
					Argument:TARGET_EXECUTABLE_SUFFIX
						Identifier:TARGET_EXECUTABLE_SUFFIX
					Argument:strlen (TARGET_EXECUTABLE_SUFFIX)
						CallExpression:strlen (TARGET_EXECUTABLE_SUFFIX)
							Callee:strlen
								Identifier:strlen
							ArgumentList:TARGET_EXECUTABLE_SUFFIX
								Argument:TARGET_EXECUTABLE_SUFFIX
									Identifier:TARGET_EXECUTABLE_SUFFIX
		Statement:name
		Statement:=
		Statement:XOBFINISH
		Statement:(
		Statement:&
		Statement:obstack
		Statement:,
		Statement:const
		Statement:char
		Statement:*
		Statement:)
		ExpressionStatement:
		Statement:endif
		ReturnStatement:return name;
			Identifier:name
	ReturnType:static const char *
	Identifier:convert_filename
	ParameterList:const char *name , int do_exe ATTRIBUTE_UNUSED , int do_obj ATTRIBUTE_UNUSED
		Parameter:const char *name
			ParameterType:const char *
			Identifier:name
		Parameter:int do_exe ATTRIBUTE_UNUSED
			ParameterType:int do_exe
			Identifier:ATTRIBUTE_UNUSED
		Parameter:int do_obj ATTRIBUTE_UNUSED
			ParameterType:int do_obj
			Identifier:ATTRIBUTE_UNUSED
FunctionDef:voiddisplay_help ()
	CompoundStatement:
		ExpressionStatement:printf (_("Usage: %s [options] file...\n"), progname)
			CallExpression:printf (_("Usage: %s [options] file...\n"), progname)
				Callee:printf
					Identifier:printf
				ArgumentList:_("Usage: %s [options] file...\n")
					Argument:_("Usage: %s [options] file...\n")
						CallExpression:_("Usage: %s [options] file...\n")
							Callee:_
								Identifier:_
							ArgumentList:"Usage: %s [options] file...\n"
								Argument:"Usage: %s [options] file...\n"
									Constant:"Usage: %s [options] file...\n"
					Argument:progname
						Identifier:progname
		ExpressionStatement:fputs (_("Options:\n"), stdout)
			CallExpression:fputs (_("Options:\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("Options:\n")
					Argument:_("Options:\n")
						CallExpression:_("Options:\n")
							Callee:_
								Identifier:_
							ArgumentList:"Options:\n"
								Argument:"Options:\n"
									Constant:"Options:\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -pass-exit-codes         Exit with highest error code from a phase.\n"), stdout)
			CallExpression:fputs (_("  -pass-exit-codes         Exit with highest error code from a phase.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -pass-exit-codes         Exit with highest error code from a phase.\n")
					Argument:_("  -pass-exit-codes         Exit with highest error code from a phase.\n")
						CallExpression:_("  -pass-exit-codes         Exit with highest error code from a phase.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -pass-exit-codes         Exit with highest error code from a phase.\n"
								Argument:"  -pass-exit-codes         Exit with highest error code from a phase.\n"
									Constant:"  -pass-exit-codes         Exit with highest error code from a phase.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  --help                   Display this information.\n"), stdout)
			CallExpression:fputs (_("  --help                   Display this information.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  --help                   Display this information.\n")
					Argument:_("  --help                   Display this information.\n")
						CallExpression:_("  --help                   Display this information.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  --help                   Display this information.\n"
								Argument:"  --help                   Display this information.\n"
									Constant:"  --help                   Display this information.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  --target-help            Display target specific command line options.\n"), stdout)
			CallExpression:fputs (_("  --target-help            Display target specific command line options.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  --target-help            Display target specific command line options.\n")
					Argument:_("  --target-help            Display target specific command line options.\n")
						CallExpression:_("  --target-help            Display target specific command line options.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  --target-help            Display target specific command line options.\n"
								Argument:"  --target-help            Display target specific command line options.\n"
									Constant:"  --target-help            Display target specific command line options.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  --help={common|optimizers|params|target|warnings|[^]{joined|separate|undocumented}}[,...].\n"), stdout)
			CallExpression:fputs (_("  --help={common|optimizers|params|target|warnings|[^]{joined|separate|undocumented}}[,...].\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  --help={common|optimizers|params|target|warnings|[^]{joined|separate|undocumented}}[,...].\n")
					Argument:_("  --help={common|optimizers|params|target|warnings|[^]{joined|separate|undocumented}}[,...].\n")
						CallExpression:_("  --help={common|optimizers|params|target|warnings|[^]{joined|separate|undocumented}}[,...].\n")
							Callee:_
								Identifier:_
							ArgumentList:"  --help={common|optimizers|params|target|warnings|[^]{joined|separate|undocumented}}[,...].\n"
								Argument:"  --help={common|optimizers|params|target|warnings|[^]{joined|separate|undocumented}}[,...].\n"
									Constant:"  --help={common|optimizers|params|target|warnings|[^]{joined|separate|undocumented}}[,...].\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("                           Display specific types of command line options.\n"), stdout)
			CallExpression:fputs (_("                           Display specific types of command line options.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("                           Display specific types of command line options.\n")
					Argument:_("                           Display specific types of command line options.\n")
						CallExpression:_("                           Display specific types of command line options.\n")
							Callee:_
								Identifier:_
							ArgumentList:"                           Display specific types of command line options.\n"
								Argument:"                           Display specific types of command line options.\n"
									Constant:"                           Display specific types of command line options.\n"
					Argument:stdout
						Identifier:stdout
		IfStatement:if (! verbose_flag)
			Condition:! verbose_flag
				UnaryOperationExpression:! verbose_flag
					UnaryOperator:!
					Identifier:verbose_flag
			ExpressionStatement:fputs (_("  (Use '-v --help' to display command line options of sub-processes).\n"), stdout)
				CallExpression:fputs (_("  (Use '-v --help' to display command line options of sub-processes).\n"), stdout)
					Callee:fputs
						Identifier:fputs
					ArgumentList:_("  (Use '-v --help' to display command line options of sub-processes).\n")
						Argument:_("  (Use '-v --help' to display command line options of sub-processes).\n")
							CallExpression:_("  (Use '-v --help' to display command line options of sub-processes).\n")
								Callee:_
									Identifier:_
								ArgumentList:"  (Use '-v --help' to display command line options of sub-processes).\n"
									Argument:"  (Use '-v --help' to display command line options of sub-processes).\n"
										Constant:"  (Use '-v --help' to display command line options of sub-processes).\n"
						Argument:stdout
							Identifier:stdout
		ExpressionStatement:fputs (_("  --version                Display compiler version information.\n"), stdout)
			CallExpression:fputs (_("  --version                Display compiler version information.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  --version                Display compiler version information.\n")
					Argument:_("  --version                Display compiler version information.\n")
						CallExpression:_("  --version                Display compiler version information.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  --version                Display compiler version information.\n"
								Argument:"  --version                Display compiler version information.\n"
									Constant:"  --version                Display compiler version information.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -dumpspecs               Display all of the built in spec strings.\n"), stdout)
			CallExpression:fputs (_("  -dumpspecs               Display all of the built in spec strings.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -dumpspecs               Display all of the built in spec strings.\n")
					Argument:_("  -dumpspecs               Display all of the built in spec strings.\n")
						CallExpression:_("  -dumpspecs               Display all of the built in spec strings.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -dumpspecs               Display all of the built in spec strings.\n"
								Argument:"  -dumpspecs               Display all of the built in spec strings.\n"
									Constant:"  -dumpspecs               Display all of the built in spec strings.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -dumpversion             Display the version of the compiler.\n"), stdout)
			CallExpression:fputs (_("  -dumpversion             Display the version of the compiler.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -dumpversion             Display the version of the compiler.\n")
					Argument:_("  -dumpversion             Display the version of the compiler.\n")
						CallExpression:_("  -dumpversion             Display the version of the compiler.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -dumpversion             Display the version of the compiler.\n"
								Argument:"  -dumpversion             Display the version of the compiler.\n"
									Constant:"  -dumpversion             Display the version of the compiler.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -dumpmachine             Display the compiler's target processor.\n"), stdout)
			CallExpression:fputs (_("  -dumpmachine             Display the compiler's target processor.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -dumpmachine             Display the compiler's target processor.\n")
					Argument:_("  -dumpmachine             Display the compiler's target processor.\n")
						CallExpression:_("  -dumpmachine             Display the compiler's target processor.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -dumpmachine             Display the compiler's target processor.\n"
								Argument:"  -dumpmachine             Display the compiler's target processor.\n"
									Constant:"  -dumpmachine             Display the compiler's target processor.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -print-search-dirs       Display the directories in the compiler's search path.\n"), stdout)
			CallExpression:fputs (_("  -print-search-dirs       Display the directories in the compiler's search path.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -print-search-dirs       Display the directories in the compiler's search path.\n")
					Argument:_("  -print-search-dirs       Display the directories in the compiler's search path.\n")
						CallExpression:_("  -print-search-dirs       Display the directories in the compiler's search path.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -print-search-dirs       Display the directories in the compiler's search path.\n"
								Argument:"  -print-search-dirs       Display the directories in the compiler's search path.\n"
									Constant:"  -print-search-dirs       Display the directories in the compiler's search path.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -print-libgcc-file-name  Display the name of the compiler's companion library.\n"), stdout)
			CallExpression:fputs (_("  -print-libgcc-file-name  Display the name of the compiler's companion library.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -print-libgcc-file-name  Display the name of the compiler's companion library.\n")
					Argument:_("  -print-libgcc-file-name  Display the name of the compiler's companion library.\n")
						CallExpression:_("  -print-libgcc-file-name  Display the name of the compiler's companion library.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -print-libgcc-file-name  Display the name of the compiler's companion library.\n"
								Argument:"  -print-libgcc-file-name  Display the name of the compiler's companion library.\n"
									Constant:"  -print-libgcc-file-name  Display the name of the compiler's companion library.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -print-file-name=<lib>   Display the full path to library <lib>.\n"), stdout)
			CallExpression:fputs (_("  -print-file-name=<lib>   Display the full path to library <lib>.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -print-file-name=<lib>   Display the full path to library <lib>.\n")
					Argument:_("  -print-file-name=<lib>   Display the full path to library <lib>.\n")
						CallExpression:_("  -print-file-name=<lib>   Display the full path to library <lib>.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -print-file-name=<lib>   Display the full path to library <lib>.\n"
								Argument:"  -print-file-name=<lib>   Display the full path to library <lib>.\n"
									Constant:"  -print-file-name=<lib>   Display the full path to library <lib>.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -print-prog-name=<prog>  Display the full path to compiler component <prog>.\n"), stdout)
			CallExpression:fputs (_("  -print-prog-name=<prog>  Display the full path to compiler component <prog>.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -print-prog-name=<prog>  Display the full path to compiler component <prog>.\n")
					Argument:_("  -print-prog-name=<prog>  Display the full path to compiler component <prog>.\n")
						CallExpression:_("  -print-prog-name=<prog>  Display the full path to compiler component <prog>.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -print-prog-name=<prog>  Display the full path to compiler component <prog>.\n"
								Argument:"  -print-prog-name=<prog>  Display the full path to compiler component <prog>.\n"
									Constant:"  -print-prog-name=<prog>  Display the full path to compiler component <prog>.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("\  -print-multiarch         Display the target's normalized GNU triplet, used as\n\                           a component in the library path.\n"), stdout)
			CallExpression:fputs (_("\  -print-multiarch         Display the target's normalized GNU triplet, used as\n\                           a component in the library path.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("\  -print-multiarch         Display the target's normalized GNU triplet, used as\n\                           a component in the library path.\n")
					Argument:_("\  -print-multiarch         Display the target's normalized GNU triplet, used as\n\                           a component in the library path.\n")
						CallExpression:_("\  -print-multiarch         Display the target's normalized GNU triplet, used as\n\                           a component in the library path.\n")
							Callee:_
								Identifier:_
							ArgumentList:"\  -print-multiarch         Display the target's normalized GNU triplet, used as\n\                           a component in the library path.\n"
								Argument:"\  -print-multiarch         Display the target's normalized GNU triplet, used as\n\                           a component in the library path.\n"
									Constant:"\  -print-multiarch         Display the target's normalized GNU triplet, used as\n\                           a component in the library path.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -print-multi-directory   Display the root directory for versions of libgcc.\n"), stdout)
			CallExpression:fputs (_("  -print-multi-directory   Display the root directory for versions of libgcc.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -print-multi-directory   Display the root directory for versions of libgcc.\n")
					Argument:_("  -print-multi-directory   Display the root directory for versions of libgcc.\n")
						CallExpression:_("  -print-multi-directory   Display the root directory for versions of libgcc.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -print-multi-directory   Display the root directory for versions of libgcc.\n"
								Argument:"  -print-multi-directory   Display the root directory for versions of libgcc.\n"
									Constant:"  -print-multi-directory   Display the root directory for versions of libgcc.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("\  -print-multi-lib         Display the mapping between command line options and\n\                           multiple library search directories.\n"), stdout)
			CallExpression:fputs (_("\  -print-multi-lib         Display the mapping between command line options and\n\                           multiple library search directories.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("\  -print-multi-lib         Display the mapping between command line options and\n\                           multiple library search directories.\n")
					Argument:_("\  -print-multi-lib         Display the mapping between command line options and\n\                           multiple library search directories.\n")
						CallExpression:_("\  -print-multi-lib         Display the mapping between command line options and\n\                           multiple library search directories.\n")
							Callee:_
								Identifier:_
							ArgumentList:"\  -print-multi-lib         Display the mapping between command line options and\n\                           multiple library search directories.\n"
								Argument:"\  -print-multi-lib         Display the mapping between command line options and\n\                           multiple library search directories.\n"
									Constant:"\  -print-multi-lib         Display the mapping between command line options and\n\                           multiple library search directories.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -print-multi-os-directory Display the relative path to OS libraries.\n"), stdout)
			CallExpression:fputs (_("  -print-multi-os-directory Display the relative path to OS libraries.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -print-multi-os-directory Display the relative path to OS libraries.\n")
					Argument:_("  -print-multi-os-directory Display the relative path to OS libraries.\n")
						CallExpression:_("  -print-multi-os-directory Display the relative path to OS libraries.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -print-multi-os-directory Display the relative path to OS libraries.\n"
								Argument:"  -print-multi-os-directory Display the relative path to OS libraries.\n"
									Constant:"  -print-multi-os-directory Display the relative path to OS libraries.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -print-sysroot           Display the target libraries directory.\n"), stdout)
			CallExpression:fputs (_("  -print-sysroot           Display the target libraries directory.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -print-sysroot           Display the target libraries directory.\n")
					Argument:_("  -print-sysroot           Display the target libraries directory.\n")
						CallExpression:_("  -print-sysroot           Display the target libraries directory.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -print-sysroot           Display the target libraries directory.\n"
								Argument:"  -print-sysroot           Display the target libraries directory.\n"
									Constant:"  -print-sysroot           Display the target libraries directory.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -print-sysroot-headers-suffix Display the sysroot suffix used to find headers.\n"), stdout)
			CallExpression:fputs (_("  -print-sysroot-headers-suffix Display the sysroot suffix used to find headers.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -print-sysroot-headers-suffix Display the sysroot suffix used to find headers.\n")
					Argument:_("  -print-sysroot-headers-suffix Display the sysroot suffix used to find headers.\n")
						CallExpression:_("  -print-sysroot-headers-suffix Display the sysroot suffix used to find headers.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -print-sysroot-headers-suffix Display the sysroot suffix used to find headers.\n"
								Argument:"  -print-sysroot-headers-suffix Display the sysroot suffix used to find headers.\n"
									Constant:"  -print-sysroot-headers-suffix Display the sysroot suffix used to find headers.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -Wa,<options>            Pass comma-separated <options> on to the assembler.\n"), stdout)
			CallExpression:fputs (_("  -Wa,<options>            Pass comma-separated <options> on to the assembler.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -Wa,<options>            Pass comma-separated <options> on to the assembler.\n")
					Argument:_("  -Wa,<options>            Pass comma-separated <options> on to the assembler.\n")
						CallExpression:_("  -Wa,<options>            Pass comma-separated <options> on to the assembler.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -Wa,<options>            Pass comma-separated <options> on to the assembler.\n"
								Argument:"  -Wa,<options>            Pass comma-separated <options> on to the assembler.\n"
									Constant:"  -Wa,<options>            Pass comma-separated <options> on to the assembler.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -Wp,<options>            Pass comma-separated <options> on to the preprocessor.\n"), stdout)
			CallExpression:fputs (_("  -Wp,<options>            Pass comma-separated <options> on to the preprocessor.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -Wp,<options>            Pass comma-separated <options> on to the preprocessor.\n")
					Argument:_("  -Wp,<options>            Pass comma-separated <options> on to the preprocessor.\n")
						CallExpression:_("  -Wp,<options>            Pass comma-separated <options> on to the preprocessor.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -Wp,<options>            Pass comma-separated <options> on to the preprocessor.\n"
								Argument:"  -Wp,<options>            Pass comma-separated <options> on to the preprocessor.\n"
									Constant:"  -Wp,<options>            Pass comma-separated <options> on to the preprocessor.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -Wl,<options>            Pass comma-separated <options> on to the linker.\n"), stdout)
			CallExpression:fputs (_("  -Wl,<options>            Pass comma-separated <options> on to the linker.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -Wl,<options>            Pass comma-separated <options> on to the linker.\n")
					Argument:_("  -Wl,<options>            Pass comma-separated <options> on to the linker.\n")
						CallExpression:_("  -Wl,<options>            Pass comma-separated <options> on to the linker.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -Wl,<options>            Pass comma-separated <options> on to the linker.\n"
								Argument:"  -Wl,<options>            Pass comma-separated <options> on to the linker.\n"
									Constant:"  -Wl,<options>            Pass comma-separated <options> on to the linker.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -Xassembler <arg>        Pass <arg> on to the assembler.\n"), stdout)
			CallExpression:fputs (_("  -Xassembler <arg>        Pass <arg> on to the assembler.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -Xassembler <arg>        Pass <arg> on to the assembler.\n")
					Argument:_("  -Xassembler <arg>        Pass <arg> on to the assembler.\n")
						CallExpression:_("  -Xassembler <arg>        Pass <arg> on to the assembler.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -Xassembler <arg>        Pass <arg> on to the assembler.\n"
								Argument:"  -Xassembler <arg>        Pass <arg> on to the assembler.\n"
									Constant:"  -Xassembler <arg>        Pass <arg> on to the assembler.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -Xpreprocessor <arg>     Pass <arg> on to the preprocessor.\n"), stdout)
			CallExpression:fputs (_("  -Xpreprocessor <arg>     Pass <arg> on to the preprocessor.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -Xpreprocessor <arg>     Pass <arg> on to the preprocessor.\n")
					Argument:_("  -Xpreprocessor <arg>     Pass <arg> on to the preprocessor.\n")
						CallExpression:_("  -Xpreprocessor <arg>     Pass <arg> on to the preprocessor.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -Xpreprocessor <arg>     Pass <arg> on to the preprocessor.\n"
								Argument:"  -Xpreprocessor <arg>     Pass <arg> on to the preprocessor.\n"
									Constant:"  -Xpreprocessor <arg>     Pass <arg> on to the preprocessor.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -Xlinker <arg>           Pass <arg> on to the linker.\n"), stdout)
			CallExpression:fputs (_("  -Xlinker <arg>           Pass <arg> on to the linker.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -Xlinker <arg>           Pass <arg> on to the linker.\n")
					Argument:_("  -Xlinker <arg>           Pass <arg> on to the linker.\n")
						CallExpression:_("  -Xlinker <arg>           Pass <arg> on to the linker.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -Xlinker <arg>           Pass <arg> on to the linker.\n"
								Argument:"  -Xlinker <arg>           Pass <arg> on to the linker.\n"
									Constant:"  -Xlinker <arg>           Pass <arg> on to the linker.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -save-temps              Do not delete intermediate files.\n"), stdout)
			CallExpression:fputs (_("  -save-temps              Do not delete intermediate files.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -save-temps              Do not delete intermediate files.\n")
					Argument:_("  -save-temps              Do not delete intermediate files.\n")
						CallExpression:_("  -save-temps              Do not delete intermediate files.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -save-temps              Do not delete intermediate files.\n"
								Argument:"  -save-temps              Do not delete intermediate files.\n"
									Constant:"  -save-temps              Do not delete intermediate files.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -save-temps=<arg>        Do not delete intermediate files.\n"), stdout)
			CallExpression:fputs (_("  -save-temps=<arg>        Do not delete intermediate files.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -save-temps=<arg>        Do not delete intermediate files.\n")
					Argument:_("  -save-temps=<arg>        Do not delete intermediate files.\n")
						CallExpression:_("  -save-temps=<arg>        Do not delete intermediate files.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -save-temps=<arg>        Do not delete intermediate files.\n"
								Argument:"  -save-temps=<arg>        Do not delete intermediate files.\n"
									Constant:"  -save-temps=<arg>        Do not delete intermediate files.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("\  -no-canonical-prefixes   Do not canonicalize paths when building relative\n\                           prefixes to other gcc components.\n"), stdout)
			CallExpression:fputs (_("\  -no-canonical-prefixes   Do not canonicalize paths when building relative\n\                           prefixes to other gcc components.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("\  -no-canonical-prefixes   Do not canonicalize paths when building relative\n\                           prefixes to other gcc components.\n")
					Argument:_("\  -no-canonical-prefixes   Do not canonicalize paths when building relative\n\                           prefixes to other gcc components.\n")
						CallExpression:_("\  -no-canonical-prefixes   Do not canonicalize paths when building relative\n\                           prefixes to other gcc components.\n")
							Callee:_
								Identifier:_
							ArgumentList:"\  -no-canonical-prefixes   Do not canonicalize paths when building relative\n\                           prefixes to other gcc components.\n"
								Argument:"\  -no-canonical-prefixes   Do not canonicalize paths when building relative\n\                           prefixes to other gcc components.\n"
									Constant:"\  -no-canonical-prefixes   Do not canonicalize paths when building relative\n\                           prefixes to other gcc components.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -pipe                    Use pipes rather than intermediate files.\n"), stdout)
			CallExpression:fputs (_("  -pipe                    Use pipes rather than intermediate files.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -pipe                    Use pipes rather than intermediate files.\n")
					Argument:_("  -pipe                    Use pipes rather than intermediate files.\n")
						CallExpression:_("  -pipe                    Use pipes rather than intermediate files.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -pipe                    Use pipes rather than intermediate files.\n"
								Argument:"  -pipe                    Use pipes rather than intermediate files.\n"
									Constant:"  -pipe                    Use pipes rather than intermediate files.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -time                    Time the execution of each subprocess.\n"), stdout)
			CallExpression:fputs (_("  -time                    Time the execution of each subprocess.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -time                    Time the execution of each subprocess.\n")
					Argument:_("  -time                    Time the execution of each subprocess.\n")
						CallExpression:_("  -time                    Time the execution of each subprocess.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -time                    Time the execution of each subprocess.\n"
								Argument:"  -time                    Time the execution of each subprocess.\n"
									Constant:"  -time                    Time the execution of each subprocess.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -specs=<file>            Override built-in specs with the contents of <file>.\n"), stdout)
			CallExpression:fputs (_("  -specs=<file>            Override built-in specs with the contents of <file>.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -specs=<file>            Override built-in specs with the contents of <file>.\n")
					Argument:_("  -specs=<file>            Override built-in specs with the contents of <file>.\n")
						CallExpression:_("  -specs=<file>            Override built-in specs with the contents of <file>.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -specs=<file>            Override built-in specs with the contents of <file>.\n"
								Argument:"  -specs=<file>            Override built-in specs with the contents of <file>.\n"
									Constant:"  -specs=<file>            Override built-in specs with the contents of <file>.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -std=<standard>          Assume that the input sources are for <standard>.\n"), stdout)
			CallExpression:fputs (_("  -std=<standard>          Assume that the input sources are for <standard>.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -std=<standard>          Assume that the input sources are for <standard>.\n")
					Argument:_("  -std=<standard>          Assume that the input sources are for <standard>.\n")
						CallExpression:_("  -std=<standard>          Assume that the input sources are for <standard>.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -std=<standard>          Assume that the input sources are for <standard>.\n"
								Argument:"  -std=<standard>          Assume that the input sources are for <standard>.\n"
									Constant:"  -std=<standard>          Assume that the input sources are for <standard>.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("\  --sysroot=<directory>    Use <directory> as the root directory for headers\n\                           and libraries.\n"), stdout)
			CallExpression:fputs (_("\  --sysroot=<directory>    Use <directory> as the root directory for headers\n\                           and libraries.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("\  --sysroot=<directory>    Use <directory> as the root directory for headers\n\                           and libraries.\n")
					Argument:_("\  --sysroot=<directory>    Use <directory> as the root directory for headers\n\                           and libraries.\n")
						CallExpression:_("\  --sysroot=<directory>    Use <directory> as the root directory for headers\n\                           and libraries.\n")
							Callee:_
								Identifier:_
							ArgumentList:"\  --sysroot=<directory>    Use <directory> as the root directory for headers\n\                           and libraries.\n"
								Argument:"\  --sysroot=<directory>    Use <directory> as the root directory for headers\n\                           and libraries.\n"
									Constant:"\  --sysroot=<directory>    Use <directory> as the root directory for headers\n\                           and libraries.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -B <directory>           Add <directory> to the compiler's search paths.\n"), stdout)
			CallExpression:fputs (_("  -B <directory>           Add <directory> to the compiler's search paths.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -B <directory>           Add <directory> to the compiler's search paths.\n")
					Argument:_("  -B <directory>           Add <directory> to the compiler's search paths.\n")
						CallExpression:_("  -B <directory>           Add <directory> to the compiler's search paths.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -B <directory>           Add <directory> to the compiler's search paths.\n"
								Argument:"  -B <directory>           Add <directory> to the compiler's search paths.\n"
									Constant:"  -B <directory>           Add <directory> to the compiler's search paths.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -v                       Display the programs invoked by the compiler.\n"), stdout)
			CallExpression:fputs (_("  -v                       Display the programs invoked by the compiler.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -v                       Display the programs invoked by the compiler.\n")
					Argument:_("  -v                       Display the programs invoked by the compiler.\n")
						CallExpression:_("  -v                       Display the programs invoked by the compiler.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -v                       Display the programs invoked by the compiler.\n"
								Argument:"  -v                       Display the programs invoked by the compiler.\n"
									Constant:"  -v                       Display the programs invoked by the compiler.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -###                     Like -v but options quoted and commands not executed.\n"), stdout)
			CallExpression:fputs (_("  -###                     Like -v but options quoted and commands not executed.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -###                     Like -v but options quoted and commands not executed.\n")
					Argument:_("  -###                     Like -v but options quoted and commands not executed.\n")
						CallExpression:_("  -###                     Like -v but options quoted and commands not executed.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -###                     Like -v but options quoted and commands not executed.\n"
								Argument:"  -###                     Like -v but options quoted and commands not executed.\n"
									Constant:"  -###                     Like -v but options quoted and commands not executed.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -E                       Preprocess only; do not compile, assemble or link.\n"), stdout)
			CallExpression:fputs (_("  -E                       Preprocess only; do not compile, assemble or link.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -E                       Preprocess only; do not compile, assemble or link.\n")
					Argument:_("  -E                       Preprocess only; do not compile, assemble or link.\n")
						CallExpression:_("  -E                       Preprocess only; do not compile, assemble or link.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -E                       Preprocess only; do not compile, assemble or link.\n"
								Argument:"  -E                       Preprocess only; do not compile, assemble or link.\n"
									Constant:"  -E                       Preprocess only; do not compile, assemble or link.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -S                       Compile only; do not assemble or link.\n"), stdout)
			CallExpression:fputs (_("  -S                       Compile only; do not assemble or link.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -S                       Compile only; do not assemble or link.\n")
					Argument:_("  -S                       Compile only; do not assemble or link.\n")
						CallExpression:_("  -S                       Compile only; do not assemble or link.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -S                       Compile only; do not assemble or link.\n"
								Argument:"  -S                       Compile only; do not assemble or link.\n"
									Constant:"  -S                       Compile only; do not assemble or link.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -c                       Compile and assemble, but do not link.\n"), stdout)
			CallExpression:fputs (_("  -c                       Compile and assemble, but do not link.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -c                       Compile and assemble, but do not link.\n")
					Argument:_("  -c                       Compile and assemble, but do not link.\n")
						CallExpression:_("  -c                       Compile and assemble, but do not link.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -c                       Compile and assemble, but do not link.\n"
								Argument:"  -c                       Compile and assemble, but do not link.\n"
									Constant:"  -c                       Compile and assemble, but do not link.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -o <file>                Place the output into <file>.\n"), stdout)
			CallExpression:fputs (_("  -o <file>                Place the output into <file>.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -o <file>                Place the output into <file>.\n")
					Argument:_("  -o <file>                Place the output into <file>.\n")
						CallExpression:_("  -o <file>                Place the output into <file>.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -o <file>                Place the output into <file>.\n"
								Argument:"  -o <file>                Place the output into <file>.\n"
									Constant:"  -o <file>                Place the output into <file>.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -pie                     Create a dynamically linked position independent\n\                           executable.\n"), stdout)
			CallExpression:fputs (_("  -pie                     Create a dynamically linked position independent\n\                           executable.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -pie                     Create a dynamically linked position independent\n\                           executable.\n")
					Argument:_("  -pie                     Create a dynamically linked position independent\n\                           executable.\n")
						CallExpression:_("  -pie                     Create a dynamically linked position independent\n\                           executable.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -pie                     Create a dynamically linked position independent\n\                           executable.\n"
								Argument:"  -pie                     Create a dynamically linked position independent\n\                           executable.\n"
									Constant:"  -pie                     Create a dynamically linked position independent\n\                           executable.\n"
					Argument:stdout
						Identifier:stdout
		ExpressionStatement:fputs (_("  -shared                  Create a shared library.\n"), stdout)
			CallExpression:fputs (_("  -shared                  Create a shared library.\n"), stdout)
				Callee:fputs
					Identifier:fputs
				ArgumentList:_("  -shared                  Create a shared library.\n")
					Argument:_("  -shared                  Create a shared library.\n")
						CallExpression:_("  -shared                  Create a shared library.\n")
							Callee:_
								Identifier:_
							ArgumentList:"  -shared                  Create a shared library.\n"
								Argument:"  -shared                  Create a shared library.\n"
									Constant:"  -shared                  Create a shared library.\n"
					Argument:stdout
						Identifier:stdout
		Statement:fputs
		Statement:(
		Statement:_
		Statement:(
		Statement:"\  -x <language>            Specify the language of the following input files.\n\                           Permissible languages include: c c++ assembler none\n\                           'none' means revert to the default behavior of\n\                           guessing the language based on the file's extension.\n\"), stdout);  printf (_("
		Statement:nOptions
		Statement:starting
		Statement:with
		Statement:-
		Statement:g
		Statement:,
		Statement:-
		Statement:f
		Statement:,
		Statement:-
		Statement:m
		Statement:,
		Statement:-
		Statement:O
		Statement:,
		Statement:-
		Statement:W
		Statement:,
		Statement:or
		Statement:--
		Statement:param
		Statement:are
		Statement:automatically
		Statement:n
		Statement:passed
		Statement:on
		Statement:to
		Statement:the
		Statement:various
		Statement:sub
		Statement:-
		Statement:processes
		Statement:invoked
		Statement:by
		Statement:%
		Statement:s
		Statement:.
		Statement:In
		Statement:order
		Statement:to
		Statement:pass
		Statement:n
		Statement:other
		Statement:options
		Statement:on
		Statement:to
		Statement:these
		Statement:processes
		Statement:the
		Statement:-
		Statement:W
		Statement:<
		Statement:letter
		Statement:>
		Statement:options
		Statement:must
		Statement:be
		Statement:used
		Statement:.
		Statement:n
		Statement:"), progname);  /* The rest of the options are displayed by invocations of the various     sub-processes.  */}static voidadd_preprocessor_option (const char *option, int len){  preprocessor_options.safe_push (save_string (option, len));}static voidadd_assembler_option (const char *option, int len){  assembler_options.safe_push (save_string (option, len));}static voidadd_linker_option (const char *option, int len){  linker_options.safe_push (save_string (option, len));}/* Allocate space for an input file in infiles.  */static voidalloc_infile (void){  if (n_infiles_alloc == 0)    {      n_infiles_alloc = 16;      infiles = XNEWVEC (struct infile, n_infiles_alloc);    }  else if (n_infiles_alloc == n_infiles)    {      n_infiles_alloc *= 2;      infiles = XRESIZEVEC (struct infile, infiles, n_infiles_alloc);    }}/* Store an input file with the given NAME and LANGUAGE in   infiles.  */static voidadd_infile (const char *name, const char *language){  alloc_infile ();  infiles[n_infiles].name = name;  infiles[n_infiles++].language = language;}/* Allocate space for a switch in switches.  */static voidalloc_switch (void){  if (n_switches_alloc == 0)    {      n_switches_alloc = 16;      switches = XNEWVEC (struct switchstr, n_switches_alloc);    }  else if (n_switches_alloc == n_switches)    {      n_switches_alloc *= 2;      switches = XRESIZEVEC (struct switchstr, switches, n_switches_alloc);    }}/* Save an option OPT with N_ARGS arguments in array ARGS, marking it   as validated if VALIDATED and KNOWN if it is an internal switch.  */static voidsave_switch (const char *opt, size_t n_args, const char *const *args,\t     bool validated, bool known){  alloc_switch ();  switches[n_switches].part1 = opt + 1;  if (n_args == 0)    switches[n_switches].args = 0;  else    {      switches[n_switches].args = XNEWVEC (const char *, n_args + 1);      memcpy (switches[n_switches].args, args, n_args * sizeof (const char *));      switches[n_switches].args[n_args] = NULL;    }  switches[n_switches].live_cond = 0;  switches[n_switches].validated = validated;  switches[n_switches].known = known;  switches[n_switches].ordering = 0;  n_switches++;}/* Set the SOURCE_DATE_EPOCH environment variable to the current time if it is   not set already.  */static voidset_source_date_epoch_envvar (){  /* Array size is 21 = ceil(log_10(2^64)) + 1 to hold string representations     of 64 bit integers.  */  char source_date_epoch[21];  time_t tt;  errno = 0;  tt = time (NULL);  if (tt < (time_t) 0 || errno != 0)    tt = (time_t) 0;  snprintf (source_date_epoch, 21, "
		Statement:%
		Statement:llu
		Statement:", (unsigned long long) tt);  /* Using setenv instead of xputenv because we want the variable to remain     after finalizing so that it's still set in the second run when using     -fcompare-debug.  */  setenv ("
		Statement:SOURCE_DATE_EPOCH
		Statement:", source_date_epoch, 0);}/* Handle an option DECODED that is unknown to the option-processing   machinery.  */static booldriver_unknown_option_callback (const struct cl_decoded_option *decoded){  const char *opt = decoded->arg;  if (opt[1] == 'W' && opt[2] == 'n' && opt[3] == 'o' && opt[4] == '-'      && !(decoded->errors & CL_ERR_NEGATIVE))    {      /* Leave unknown -Wno-* options for the compiler proper, to be\t diagnosed only if there are warnings.  */      save_switch (decoded->canonical_option[0],\t\t   decoded->canonical_option_num_elements - 1,\t\t   &decoded->canonical_option[1], false, true);      return false;    }  if (decoded->opt_index == OPT_SPECIAL_unknown)    {      /* Give it a chance to define it a spec file.  */      save_switch (decoded->canonical_option[0],\t\t   decoded->canonical_option_num_elements - 1,\t\t   &decoded->canonical_option[1], false, false);      return false;    }  else    return true;}/* Handle an option DECODED that is not marked as CL_DRIVER.   LANG_MASK will always be CL_DRIVER.  */static voiddriver_wrong_lang_callback (const struct cl_decoded_option *decoded,\t\t\t    unsigned int lang_mask ATTRIBUTE_UNUSED){  /* At this point, non-driver options are accepted (and expected to     be passed down by specs) unless marked to be rejected by the     driver.  Options to be rejected by the driver but accepted by the     compilers proper are treated just like completely unknown     options.  */  const struct cl_option *option = &cl_options[decoded->opt_index];  if (option->cl_reject_driver)    error ("
		Statement:unrecognized
		Statement:command
		Statement:line
		Statement:option
		Statement:%
		Statement:qs
		Statement:",\t   decoded->orig_option_with_args_text);  else    save_switch (decoded->canonical_option[0],\t\t decoded->canonical_option_num_elements - 1,\t\t &decoded->canonical_option[1], false, true);}static const char *spec_lang = 0;static int last_language_n_infiles;/* Parse -foffload option argument.  */static voidhandle_foffload_option (const char *arg){  const char *c, *cur, *n, *next, *end;  char *target;  /* If option argument starts with '-' then no target is specified and we     do not need to parse it.  */  if (arg[0] == '-')    return;  end = strchr (arg, '=');  if (end == NULL)    end = strchr (arg, '\0');  cur = arg;  while (cur < end)    {      next = strchr (cur, ',');      if (next == NULL)\tnext = end;      next = (next > end) ? end : next;      target = XNEWVEC (char, next - cur + 1);      memcpy (target, cur, next - cur);      target[next - cur] = '\0';      /* If 'disable' is passed to the option, stop parsing the option and clean         the list of offload targets.  */      if (strcmp (target, "
		Statement:disable
		Statement:") == 0)\t{\t  free (offload_targets);\t  offload_targets = xstrdup ("
		Statement:");\t  break;\t}      /* Check that GCC is configured to support the offload target.  */      c = OFFLOAD_TARGETS;      while (c)\t{\t  n = strchr (c, ',');\t  if (n == NULL)\t    n = strchr (c, '\0');\t  if (next - cur == n - c && strncmp (target, c, n - c) == 0)\t    break;\t  c = *n ? n + 1 : NULL;\t}      if (!c)\tfatal_error (input_location,\t\t     "
		Statement:GCC
		Statement:is
		Statement:not
		Statement:configured
		Statement:to
		Statement:support
		Statement:%
		Statement:s
		Statement:as
		Statement:offload
		Statement:target
		Statement:",\t\t     target);      if (!offload_targets)\t{\t  offload_targets = target;\t  target = NULL;\t}      else\t{\t  /* Check that the target hasn't already presented in the list.  */\t  c = offload_targets;\t  do\t    {\t      n = strchr (c, ':');\t      if (n == NULL)\t\tn = strchr (c, '\0');\t      if (next - cur == n - c && strncmp (c, target, n - c) == 0)\t\tbreak;\t      c = n + 1;\t    }\t  while (*n);\t  /* If duplicate is not found, append the target to the list.  */\t  if (c > n)\t    {\t      size_t offload_targets_len = strlen (offload_targets);\t      offload_targets\t\t= XRESIZEVEC (char, offload_targets,\t\t\t      offload_targets_len + 1 + next - cur + 1);\t      offload_targets[offload_targets_len++] = ':';\t      memcpy (offload_targets + offload_targets_len, target, next - cur + 1);\t    }\t}      cur = next + 1;      XDELETEVEC (target);    }}/* Handle a driver option; arguments and return value as for   handle_option.  */static booldriver_handle_option (struct gcc_options *opts,\t\t      struct gcc_options *opts_set,\t\t      const struct cl_decoded_option *decoded,\t\t      unsigned int lang_mask ATTRIBUTE_UNUSED, int kind,\t\t      location_t loc,\t\t      const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED,\t\t      diagnostic_context *dc,\t\t      void (*) (void)){  size_t opt_index = decoded->opt_index;  const char *arg = decoded->arg;  const char *compare_debug_replacement_opt;  int value = decoded->value;  bool validated = false;  bool do_save = true;  gcc_assert (opts == &global_options);  gcc_assert (opts_set == &global_options_set);  gcc_assert (kind == DK_UNSPECIFIED);  gcc_assert (loc == UNKNOWN_LOCATION);  gcc_assert (dc == global_dc);  switch (opt_index)    {    case OPT_dumpspecs:      {\tstruct spec_list *sl;\tinit_spec ();\tfor (sl = specs; sl; sl = sl->next)\t  printf ("
		Statement:*
		Statement:%
		Label:s:
			Identifier:s
		Statement:n
		Statement:%
		Statement:s
		Statement:n
		Statement:n
		Statement:", sl->name, *(sl->ptr_spec));\tif (link_command_spec)\t  printf ("
		Statement:*
		Label:link_command:
			Identifier:link_command
		Statement:n
		Statement:%
		Statement:s
		Statement:n
		Statement:n
		Statement:", link_command_spec);\texit (0);      }    case OPT_dumpversion:      printf ("
		Statement:%
		Statement:s
		Statement:n
		Statement:", spec_version);      exit (0);    case OPT_dumpmachine:      printf ("
		Statement:%
		Statement:s
		Statement:n
		Statement:", spec_machine);      exit (0);    case OPT_dumpfullversion:      printf ("
		Statement:%
		Statement:s
		Statement:n
		Statement:", BASEVER);      exit (0);    case OPT__version:      print_version = 1;      /* CPP driver cannot obtain switch from cc1_options.  */      if (is_cpp_driver)\tadd_preprocessor_option ("
		Statement:--
		Statement:version
		Statement:", strlen ("
		Statement:--
		Statement:version
		Statement:"));      add_assembler_option ("
		Statement:--
		Statement:version
		Statement:", strlen ("
		Statement:--
		Statement:version
		Statement:"));      add_linker_option ("
		Statement:--
		Statement:version
		Statement:", strlen ("
		Statement:--
		Statement:version
		Statement:"));      break;    case OPT__help:      print_help_list = 1;      /* CPP driver cannot obtain switch from cc1_options.  */      if (is_cpp_driver)\tadd_preprocessor_option ("
		Statement:--
		Statement:help
		Statement:", 6);      add_assembler_option ("
		Statement:--
		Statement:help
		Statement:", 6);      add_linker_option ("
		Statement:--
		Statement:help
		Statement:", 6);      break;    case OPT__help_:      print_subprocess_help = 2;      break;    case OPT__target_help:      print_subprocess_help = 1;      /* CPP driver cannot obtain switch from cc1_options.  */      if (is_cpp_driver)\tadd_preprocessor_option ("
		Statement:--
		Statement:target
		Statement:-
		Statement:help
		Statement:", 13);      add_assembler_option ("
		Statement:--
		Statement:target
		Statement:-
		Statement:help
		Statement:", 13);      add_linker_option ("
		Statement:--
		Statement:target
		Statement:-
		Statement:help
		Statement:", 13);      break;    case OPT__no_sysroot_suffix:    case OPT_pass_exit_codes:    case OPT_print_search_dirs:    case OPT_print_file_name_:    case OPT_print_prog_name_:    case OPT_print_multi_lib:    case OPT_print_multi_directory:    case OPT_print_sysroot:    case OPT_print_multi_os_directory:    case OPT_print_multiarch:    case OPT_print_sysroot_headers_suffix:    case OPT_time:    case OPT_wrapper:      /* These options set the variables specified in common.opt\t automatically, and do not need to be saved for spec\t processing.  */      do_save = false;      break;    case OPT_print_libgcc_file_name:      print_file_name = "
		Statement:libgcc
		Statement:.
		Statement:a
		Statement:";      do_save = false;      break;    case OPT_fuse_ld_bfd:       use_ld = "
		Statement:.
		Statement:bfd
		Statement:";       break;    case OPT_fuse_ld_gold:       use_ld = "
		Statement:.
		Statement:gold
		Statement:";       break;    case OPT_fcompare_debug_second:      compare_debug_second = 1;      break;    case OPT_fcompare_debug:      switch (value)\t{\tcase 0:\t  compare_debug_replacement_opt = "
		Statement:-
		Statement:fcompare
		Statement:-
		Statement:debug
		Statement:=
		Statement:";\t  arg = "
		Statement:";\t  goto compare_debug_with_arg;\tcase 1:\t  compare_debug_replacement_opt = "
		Statement:-
		Statement:fcompare
		Statement:-
		Statement:debug
		Statement:=
		Statement:-
		Statement:gtoggle
		Statement:";\t  arg = "
		Statement:-
		Statement:gtoggle
		Statement:";\t  goto compare_debug_with_arg;\tdefault:\t  gcc_unreachable ();\t}      break;    case OPT_fcompare_debug_:      compare_debug_replacement_opt = decoded->canonical_option[0];    compare_debug_with_arg:      gcc_assert (decoded->canonical_option_num_elements == 1);      gcc_assert (arg != NULL);      if (*arg)\tcompare_debug = 1;      else\tcompare_debug = -1;      if (compare_debug < 0)\tcompare_debug_opt = NULL;      else\tcompare_debug_opt = arg;      save_switch (compare_debug_replacement_opt, 0, NULL, validated, true);      set_source_date_epoch_envvar ();      return true;    case OPT_fdiagnostics_color_:      diagnostic_color_init (dc, value);      break;    case OPT_Wa_:      {\tint prev, j;\t/* Pass the rest of this option to the assembler.  */\t/* Split the argument at commas.  */\tprev = 0;\tfor (j = 0; arg[j]; j++)\t  if (arg[j] == ',')\t    {\t      add_assembler_option (arg + prev, j - prev);\t      prev = j + 1;\t    }\t/* Record the part after the last comma.  */\tadd_assembler_option (arg + prev, j - prev);      }      do_save = false;      break;    case OPT_Wp_:      {\tint prev, j;\t/* Pass the rest of this option to the preprocessor.  */\t/* Split the argument at commas.  */\tprev = 0;\tfor (j = 0; arg[j]; j++)\t  if (arg[j] == ',')\t    {\t      add_preprocessor_option (arg + prev, j - prev);\t      prev = j + 1;\t    }\t/* Record the part after the last comma.  */\tadd_preprocessor_option (arg + prev, j - prev);      }      do_save = false;      break;    case OPT_Wl_:      {\tint prev, j;\t/* Split the argument at commas.  */\tprev = 0;\tfor (j = 0; arg[j]; j++)\t  if (arg[j] == ',')\t    {\t      add_infile (save_string (arg + prev, j - prev), "
		Statement:*
		Statement:");\t      prev = j + 1;\t    }\t/* Record the part after the last comma.  */\tadd_infile (arg + prev, "
		Statement:*
		Statement:");      }      do_save = false;      break;    case OPT_Xlinker:      add_infile (arg, "
		Statement:*
		Statement:");      do_save = false;      break;    case OPT_Xpreprocessor:      add_preprocessor_option (arg, strlen (arg));      do_save = false;      break;    case OPT_Xassembler:      add_assembler_option (arg, strlen (arg));      do_save = false;      break;    case OPT_l:      /* POSIX allows separation of -l and the lib arg; canonicalize\t by concatenating -l with its arg */      add_infile (concat ("
		Statement:-
		Statement:l
		Statement:", arg, NULL), "
		Statement:*
		Statement:");      do_save = false;      break;    case OPT_L:      /* Similarly, canonicalize -L for linkers that may not accept\t separate arguments.  */      save_switch (concat ("
		Statement:-
		Statement:L
		Statement:", arg, NULL), 0, NULL, validated, true);      return true;    case OPT_F:      /* Likewise -F.  */      save_switch (concat ("
		Statement:-
		Statement:F
		Statement:", arg, NULL), 0, NULL, validated, true);      return true;    case OPT_save_temps:      save_temps_flag = SAVE_TEMPS_CWD;      validated = true;      break;    case OPT_save_temps_:      if (strcmp (arg, "
		Statement:cwd
		Statement:") == 0)\tsave_temps_flag = SAVE_TEMPS_CWD;      else if (strcmp (arg, "
		Statement:obj
		Statement:") == 0\t       || strcmp (arg, "
		Statement:object
		Statement:") == 0)\tsave_temps_flag = SAVE_TEMPS_OBJ;      else\tfatal_error (input_location, "
		Statement:%
		Statement:qs
		Statement:is
		Statement:an
		Statement:unknown
		Statement:-
		Statement:save
		Statement:-
		Statement:temps
		Statement:option
		Statement:",\t\t     decoded->orig_option_with_args_text);      break;    case OPT_no_canonical_prefixes:      /* Already handled as a special case, so ignored here.  */      do_save = false;      break;    case OPT_pipe:      validated = true;      /* These options set the variables specified in common.opt\t automatically, but do need to be saved for spec\t processing.  */      break;    case OPT_specs_:      {\tstruct user_specs *user = XNEW (struct user_specs);\tuser->next = (struct user_specs *) 0;\tuser->filename = arg;\tif (user_specs_tail)\t  user_specs_tail->next = user;\telse\t  user_specs_head = user;\tuser_specs_tail = user;      }      validated = true;      break;    case OPT__sysroot_:      target_system_root = arg;      target_system_root_changed = 1;      do_save = false;      break;    case OPT_time_:      if (report_times_to_file)\tfclose (report_times_to_file);      report_times_to_file = fopen (arg, "
		Statement:a
		Statement:");      do_save = false;      break;    case OPT____:      /* "
		Statement:-
		Statement:"\t This is similar to -v except that there is no execution\t of the commands and the echoed arguments are quoted.  It\t is intended for use in shell scripts to capture the\t driver-generated command line.  */      verbose_only_flag++;      verbose_flag = 1;      do_save = false;      break;    case OPT_B:      {\tsize_t len = strlen (arg);\t/* Catch the case where the user has forgotten to append a\t   directory separator to the path.  Note, they may be using\t   -B to add an executable name prefix, eg "
		Statement:i386
		Statement:-
		Statement:elf
		Statement:-
		Statement:", in\t   order to distinguish between multiple installations of\t   GCC in the same directory.  Hence we must check to see\t   if appending a directory separator actually makes a\t   valid directory name.  */\tif (!IS_DIR_SEPARATOR (arg[len - 1])\t    && is_directory (arg, false))\t  {\t    char *tmp = XNEWVEC (char, len + 2);\t    strcpy (tmp, arg);\t    tmp[len] = DIR_SEPARATOR;\t    tmp[++len] = 0;\t    arg = tmp;\t  }\tadd_prefix (&exec_prefixes, arg, NULL,\t\t    PREFIX_PRIORITY_B_OPT, 0, 0);\tadd_prefix (&startfile_prefixes, arg, NULL,\t\t    PREFIX_PRIORITY_B_OPT, 0, 0);\tadd_prefix (&include_prefixes, arg, NULL,\t\t    PREFIX_PRIORITY_B_OPT, 0, 0);      }      validated = true;      break;    case OPT_E:      have_E = true;      break;    case OPT_x:      spec_lang = arg;      if (!strcmp (spec_lang, "
		Statement:none
		Statement:"))\t/* Suppress the warning if -xnone comes after the last input\t   file, because alternate command interfaces like g++ might\t   find it useful to place -xnone after each input file.  */\tspec_lang = 0;      else\tlast_language_n_infiles = n_infiles;      do_save = false;      break;    case OPT_o:      have_o = 1;#if defined(HAVE_TARGET_EXECUTABLE_SUFFIX) || defined(HAVE_TARGET_OBJECT_SUFFIX)      arg = convert_filename (arg, ! have_c, 0);#endif      output_file = arg;      /* Save the output name in case -save-temps=obj was used.  */      save_temps_prefix = xstrdup (arg);      /* On some systems, ld cannot handle "
		Statement:-
		Statement:o
		Statement:" without a space.  So\t split the option from its argument.  */      save_switch ("
		Statement:-
		Statement:o
		Statement:", 1, &arg, validated, true);      return true;#ifdef ENABLE_DEFAULT_PIE    case OPT_pie:      /* -pie is turned on by default.  */#endif    case OPT_static_libgcc:    case OPT_shared_libgcc:    case OPT_static_libgfortran:    case OPT_static_libstdc__:      /* These are always valid, since gcc.c itself understands the\t first two, gfortranspec.c understands -static-libgfortran and\t g++spec.c understands -static-libstdc++ */      validated = true;      break;    case OPT_fwpa:      flag_wpa = "
		Statement:";      break;    case OPT_foffload_:      handle_foffload_option (arg);      break;    default:      /* Various driver options need no special processing at this\t point, having been handled in a prescan above or being\t handled by specs.  */      break;    }  if (do_save)    save_switch (decoded->canonical_option[0],\t\t decoded->canonical_option_num_elements - 1,\t\t &decoded->canonical_option[1], validated, true);  return true;}/* Put the driver's standard set of option handlers in *HANDLERS.  */static voidset_option_handlers (struct cl_option_handlers *handlers){  handlers->unknown_option_callback = driver_unknown_option_callback;  handlers->wrong_lang_callback = driver_wrong_lang_callback;  handlers->num_handlers = 3;  handlers->handlers[0].handler = driver_handle_option;  handlers->handlers[0].mask = CL_DRIVER;  handlers->handlers[1].handler = common_handle_option;  handlers->handlers[1].mask = CL_COMMON;  handlers->handlers[2].handler = target_handle_option;  handlers->handlers[2].mask = CL_TARGET;}/* Create the vector `switches' and its contents.   Store its length in `n_switches'.  */static voidprocess_command (unsigned int decoded_options_count,\t\t struct cl_decoded_option *decoded_options){  const char *temp;  char *temp1;  char *tooldir_prefix, *tooldir_prefix2;  char *(*get_relative_prefix) (const char *, const char *,\t\t\t\tconst char *) = NULL;  struct cl_option_handlers handlers;  unsigned int j;  gcc_exec_prefix = env.get ("
		Statement:GCC_EXEC_PREFIX
		Statement:");  n_switches = 0;  n_infiles = 0;  added_libraries = 0;  /* Figure compiler version from version string.  */  compiler_version = temp1 = xstrdup (version_string);  for (; *temp1; ++temp1)    {      if (*temp1 == ' ')\t{\t  *temp1 = '\0';\t  break;\t}    }  /* Handle any -no-canonical-prefixes flag early, to assign the function     that builds relative prefixes.  This function creates default search     paths that are needed later in normal option handling.  */  for (j = 1; j < decoded_options_count; j++)    {      if (decoded_options[j].opt_index == OPT_no_canonical_prefixes)\t{\t  get_relative_prefix = make_relative_prefix_ignore_links;\t  break;\t}    }  if (! get_relative_prefix)    get_relative_prefix = make_relative_prefix;  /* Set up the default search paths.  If there is no GCC_EXEC_PREFIX,     see if we can create it from the pathname specified in     decoded_options[0].arg.  */  gcc_libexec_prefix = standard_libexec_prefix;#ifndef VMS  /* FIXME: make_relative_prefix doesn't yet work for VMS.  */  if (!gcc_exec_prefix)    {      gcc_exec_prefix = get_relative_prefix (decoded_options[0].arg,\t\t\t\t\t     standard_bindir_prefix,\t\t\t\t\t     standard_exec_prefix);      gcc_libexec_prefix = get_relative_prefix (decoded_options[0].arg,\t\t\t\t\t     standard_bindir_prefix,\t\t\t\t\t     standard_libexec_prefix);      if (gcc_exec_prefix)\txputenv (concat ("
		Statement:GCC_EXEC_PREFIX
		Statement:=
		Statement:", gcc_exec_prefix, NULL));    }  else    {      /* make_relative_prefix requires a program name, but\t GCC_EXEC_PREFIX is typically a directory name with a trailing\t / (which is ignored by make_relative_prefix), so append a\t program name.  */      char *tmp_prefix = concat (gcc_exec_prefix, "
		Statement:gcc
		Statement:", NULL);      gcc_libexec_prefix = get_relative_prefix (tmp_prefix,\t\t\t\t\t\tstandard_exec_prefix,\t\t\t\t\t\tstandard_libexec_prefix);      /* The path is unrelocated, so fallback to the original setting.  */      if (!gcc_libexec_prefix)\tgcc_libexec_prefix = standard_libexec_prefix;      free (tmp_prefix);    }#else#endif  /* From this point onward, gcc_exec_prefix is non-null if the toolchain     is relocated. The toolchain was either relocated using GCC_EXEC_PREFIX     or an automatically created GCC_EXEC_PREFIX from     decoded_options[0].arg.  */  /* Do language-specific adjustment/addition of flags.  */  lang_specific_driver (&decoded_options, &decoded_options_count,\t\t\t&added_libraries);  if (gcc_exec_prefix)    {      int len = strlen (gcc_exec_prefix);      if (len > (int) sizeof ("
		Statement:/
		Statement:lib
		Statement:/
		Statement:gcc
		Statement:/
		Statement:") - 1\t  && (IS_DIR_SEPARATOR (gcc_exec_prefix[len-1])))\t{\t  temp = gcc_exec_prefix + len - sizeof ("
		Statement:/
		Statement:lib
		Statement:/
		Statement:gcc
		Statement:/
		Statement:") + 1;\t  if (IS_DIR_SEPARATOR (*temp)\t      && filename_ncmp (temp + 1, "
		Statement:lib
		Statement:", 3) == 0\t      && IS_DIR_SEPARATOR (temp[4])\t      && filename_ncmp (temp + 5, "
		Statement:gcc
		Statement:", 3) == 0)\t    len -= sizeof ("
		Statement:/
		Statement:lib
		Statement:/
		Statement:gcc
		Statement:/
		Statement:") - 1;\t}      set_std_prefix (gcc_exec_prefix, len);      add_prefix (&exec_prefixes, gcc_libexec_prefix, "
		Statement:GCC
		Statement:",\t\t  PREFIX_PRIORITY_LAST, 0, 0);      add_prefix (&startfile_prefixes, gcc_exec_prefix, "
		Statement:GCC
		Statement:",\t\t  PREFIX_PRIORITY_LAST, 0, 0);    }  /* COMPILER_PATH and LIBRARY_PATH have values     that are lists of directory names with colons.  */  temp = env.get ("
		Statement:COMPILER_PATH
		Statement:");  if (temp)    {      const char *startp, *endp;      char *nstore = (char *) alloca (strlen (temp) + 3);      startp = endp = temp;      while (1)\t{\t  if (*endp == PATH_SEPARATOR || *endp == 0)\t    {\t      strncpy (nstore, startp, endp - startp);\t      if (endp == startp)\t\tstrcpy (nstore, concat ("
		Statement:.
		Statement:", dir_separator_str, NULL));\t      else if (!IS_DIR_SEPARATOR (endp[-1]))\t\t{\t\t  nstore[endp - startp] = DIR_SEPARATOR;\t\t  nstore[endp - startp + 1] = 0;\t\t}\t      else\t\tnstore[endp - startp] = 0;\t      add_prefix (&exec_prefixes, nstore, 0,\t\t\t  PREFIX_PRIORITY_LAST, 0, 0);\t      add_prefix (&include_prefixes, nstore, 0,\t\t\t  PREFIX_PRIORITY_LAST, 0, 0);\t      if (*endp == 0)\t\tbreak;\t      endp = startp = endp + 1;\t    }\t  else\t    endp++;\t}    }  temp = env.get (LIBRARY_PATH_ENV);  if (temp && *cross_compile == '0')    {      const char *startp, *endp;      char *nstore = (char *) alloca (strlen (temp) + 3);      startp = endp = temp;      while (1)\t{\t  if (*endp == PATH_SEPARATOR || *endp == 0)\t    {\t      strncpy (nstore, startp, endp - startp);\t      if (endp == startp)\t\tstrcpy (nstore, concat ("
		Statement:.
		Statement:", dir_separator_str, NULL));\t      else if (!IS_DIR_SEPARATOR (endp[-1]))\t\t{\t\t  nstore[endp - startp] = DIR_SEPARATOR;\t\t  nstore[endp - startp + 1] = 0;\t\t}\t      else\t\tnstore[endp - startp] = 0;\t      add_prefix (&startfile_prefixes, nstore, NULL,\t\t\t  PREFIX_PRIORITY_LAST, 0, 1);\t      if (*endp == 0)\t\tbreak;\t      endp = startp = endp + 1;\t    }\t  else\t    endp++;\t}    }  /* Use LPATH like LIBRARY_PATH (for the CMU build program).  */  temp = env.get ("
		Statement:LPATH
		Statement:");  if (temp && *cross_compile == '0')    {      const char *startp, *endp;      char *nstore = (char *) alloca (strlen (temp) + 3);      startp = endp = temp;      while (1)\t{\t  if (*endp == PATH_SEPARATOR || *endp == 0)\t    {\t      strncpy (nstore, startp, endp - startp);\t      if (endp == startp)\t\tstrcpy (nstore, concat ("
		Statement:.
		Statement:", dir_separator_str, NULL));\t      else if (!IS_DIR_SEPARATOR (endp[-1]))\t\t{\t\t  nstore[endp - startp] = DIR_SEPARATOR;\t\t  nstore[endp - startp + 1] = 0;\t\t}\t      else\t\tnstore[endp - startp] = 0;\t      add_prefix (&startfile_prefixes, nstore, NULL,\t\t\t  PREFIX_PRIORITY_LAST, 0, 1);\t      if (*endp == 0)\t\tbreak;\t      endp = startp = endp + 1;\t    }\t  else\t    endp++;\t}    }  /* Process the options and store input files and switches in their     vectors.  */  last_language_n_infiles = -1;  set_option_handlers (&handlers);  for (j = 1; j < decoded_options_count; j++)    {      switch (decoded_options[j].opt_index)\t{\tcase OPT_S:\tcase OPT_c:\tcase OPT_E:\t  have_c = 1;\t  break;\t}      if (have_c)\tbreak;    }  for (j = 1; j < decoded_options_count; j++)    {      if (decoded_options[j].opt_index == OPT_SPECIAL_input_file)\t{\t  const char *arg = decoded_options[j].arg;          const char *p = strrchr (arg, '@');          char *fname;\t  long offset;\t  int consumed;#ifdef HAVE_TARGET_OBJECT_SUFFIX\t  arg = convert_filename (arg, 0, access (arg, F_OK));#endif\t  /* For LTO static archive support we handle input file\t     specifications that are composed of a filename and\t     an offset like FNAME@OFFSET.  */\t  if (p\t      && p != arg\t      && sscanf (p, "
		Statement:%
		Statement:li
		Statement:%
		Statement:n
		Statement:", &offset, &consumed) >= 1\t      && strlen (p) == (unsigned int)consumed)\t    {              fname = (char *)xmalloc (p - arg + 1);              memcpy (fname, arg, p - arg);              fname[p - arg] = '\0';\t      /* Only accept non-stdin and existing FNAME parts, otherwise\t\t try with the full name.  */\t      if (strcmp (fname, "
		Statement:-
		Statement:") == 0 || access (fname, F_OK) < 0)\t\t{\t\t  free (fname);\t\t  fname = xstrdup (arg);\t\t}\t    }\t  else\t    fname = xstrdup (arg);          if (strcmp (fname, "
		Statement:-
		Statement:") != 0 && access (fname, F_OK) < 0)\t    {\t      if (fname[0] == '@' && access (fname + 1, F_OK) < 0)\t\tperror_with_name (fname + 1);\t      else\t\tperror_with_name (fname);\t    }          else\t    add_infile (arg, spec_lang);          free (fname);\t  continue;\t}      read_cmdline_option (&global_options, &global_options_set,\t\t\t   decoded_options + j, UNKNOWN_LOCATION,\t\t\t   CL_DRIVER, &handlers, global_dc);    }  /* If the user didn't specify any, default to all configured offload     targets.  */  if (ENABLE_OFFLOADING && offload_targets == NULL)    handle_foffload_option (OFFLOAD_TARGETS);  if (output_file      && strcmp (output_file, "
		Statement:-
		Statement:") != 0      && strcmp (output_file, HOST_BIT_BUCKET) != 0)    {      int i;      for (i = 0; i < n_infiles; i++)\tif ((!infiles[i].language || infiles[i].language[0] != '*')\t    && canonical_filename_eq (infiles[i].name, output_file))\t  fatal_error (input_location,\t\t       "
		Statement:input
		Statement:file
		Statement:%
		Statement:qs
		Statement:is
		Statement:the
		Statement:same
		Statement:as
		Statement:output
		Statement:file
		Statement:",\t\t       output_file);    }  if (output_file != NULL && output_file[0] == '\0')    fatal_error (input_location, "
		Statement:output
		Statement:filename
		Statement:may
		Statement:not
		Statement:be
		Statement:empty
		Statement:");  /* If -save-temps=obj and -o name, create the prefix to use for %b.     Otherwise just make -save-temps=obj the same as -save-temps=cwd.  */  if (save_temps_flag == SAVE_TEMPS_OBJ && save_temps_prefix != NULL)    {      save_temps_length = strlen (save_temps_prefix);      temp = strrchr (lbasename (save_temps_prefix), '.');      if (temp)\t{\t  save_temps_length -= strlen (temp);\t  save_temps_prefix[save_temps_length] = '\0';\t}    }  else if (save_temps_prefix != NULL)    {      free (save_temps_prefix);      save_temps_prefix = NULL;    }  if (save_temps_flag && use_pipes)    {      /* -save-temps overrides -pipe, so that temp files are produced */      if (save_temps_flag)\twarning (0, "
		Statement:-
		Statement:pipe
		Statement:ignored
		Statement:because
		Statement:-
		Statement:save
		Statement:-
		Statement:temps
		Statement:specified
		Statement:");      use_pipes = 0;    }  if (!compare_debug)    {      const char *gcd = env.get ("
		Statement:GCC_COMPARE_DEBUG
		Statement:");      if (gcd && gcd[0] == '-')\t{\t  compare_debug = 2;\t  compare_debug_opt = gcd;\t}      else if (gcd && *gcd && strcmp (gcd, "
		Statement:0
		Statement:"))\t{\t  compare_debug = 3;\t  compare_debug_opt = "
		Statement:-
		Statement:gtoggle
		Statement:";\t}    }  else if (compare_debug < 0)    {      compare_debug = 0;      gcc_assert (!compare_debug_opt);    }  /* Set up the search paths.  We add directories that we expect to     contain GNU Toolchain components before directories specified by     the machine description so that we will find GNU components (like     the GNU assembler) before those of the host system.  */  /* If we don't know where the toolchain has been installed, use the     configured-in locations.  */  if (!gcc_exec_prefix)    {#ifndef OS2      add_prefix (&exec_prefixes, standard_libexec_prefix, "
		Statement:GCC
		Statement:",\t\t  PREFIX_PRIORITY_LAST, 1, 0);      add_prefix (&exec_prefixes, standard_libexec_prefix, "
		Statement:BINUTILS
		Statement:",\t\t  PREFIX_PRIORITY_LAST, 2, 0);      add_prefix (&exec_prefixes, standard_exec_prefix, "
		Statement:BINUTILS
		Statement:",\t\t  PREFIX_PRIORITY_LAST, 2, 0);#endif      add_prefix (&startfile_prefixes, standard_exec_prefix, "
		Statement:BINUTILS
		Statement:",\t\t  PREFIX_PRIORITY_LAST, 1, 0);    }  gcc_assert (!IS_ABSOLUTE_PATH (tooldir_base_prefix));  tooldir_prefix2 = concat (tooldir_base_prefix, spec_machine,\t\t\t    dir_separator_str, NULL);  /* Look for tools relative to the location from which the driver is     running, or, if that is not available, the configured prefix.  */  tooldir_prefix    = concat (gcc_exec_prefix ? gcc_exec_prefix : standard_exec_prefix,\t      spec_host_machine, dir_separator_str, spec_version,\t      accel_dir_suffix, dir_separator_str, tooldir_prefix2, NULL);  free (tooldir_prefix2);  add_prefix (&exec_prefixes,\t      concat (tooldir_prefix, "
		Statement:bin
		Statement:", dir_separator_str, NULL),\t      "
		Statement:BINUTILS
		Statement:", PREFIX_PRIORITY_LAST, 0, 0);  add_prefix (&startfile_prefixes,\t      concat (tooldir_prefix, "
		Statement:lib
		Statement:", dir_separator_str, NULL),\t      "
		Statement:BINUTILS
		Statement:", PREFIX_PRIORITY_LAST, 0, 1);  free (tooldir_prefix);#if defined(TARGET_SYSTEM_ROOT_RELOCATABLE) && !defined(VMS)  /* If the normal TARGET_SYSTEM_ROOT is inside of $exec_prefix,     then consider it to relocate with the rest of the GCC installation     if GCC_EXEC_PREFIX is set.     ``make_relative_prefix'' is not compiled for VMS, so don't call it.  */  if (target_system_root && !target_system_root_changed && gcc_exec_prefix)    {      char *tmp_prefix = get_relative_prefix (decoded_options[0].arg,\t\t\t\t\t      standard_bindir_prefix,\t\t\t\t\t      target_system_root);      if (tmp_prefix && access_check (tmp_prefix, F_OK) == 0)\t{\t  target_system_root = tmp_prefix;\t  target_system_root_changed = 1;\t}    }#endif  /* More prefixes are enabled in main, after we read the specs file     and determine whether this is cross-compilation or not.  */  if (n_infiles == last_language_n_infiles && spec_lang != 0)    warning (0, "
		Statement:%
		Statement:<
		Statement:-
		Statement:x
		Statement:%
		Statement:s
		Statement:%
		Statement:>
		Statement:after
		Statement:last
		Statement:input
		Statement:file
		Statement:has
		Statement:no
		Statement:effect
		Statement:", spec_lang);  /* Synthesize -fcompare-debug flag from the GCC_COMPARE_DEBUG     environment variable.  */  if (compare_debug == 2 || compare_debug == 3)    {      const char *opt = concat ("
		Statement:-
		Statement:fcompare
		Statement:-
		Statement:debug
		Statement:=
		Statement:", compare_debug_opt, NULL);      save_switch (opt, 0, NULL, false, true);      compare_debug = 1;    }  /* Ensure we only invoke each subprocess once.  */  if (print_subprocess_help || print_help_list || print_version)    {      n_infiles = 0;      /* Create a dummy input file, so that we can pass\t the help option on to the various sub-processes.  */      add_infile ("
		Statement:help
		Statement:-
		Statement:dummy
		Statement:", "
		Statement:c
		Statement:");    }  /* Decide if undefined variable references are allowed in specs.  */  /* -v alone is safe. --version and --help alone or together are safe.  Note     that -v would make them unsafe, as they'd then be run for subprocesses as     well, the location of which might depend on variables possibly coming     from self-specs.  Note also that the command name is counted in     decoded_options_count.  */  unsigned help_version_count = 0;  if (print_version)    help_version_count++;  if (print_help_list)    help_version_count++;  spec_undefvar_allowed =    ((verbose_flag && decoded_options_count == 2)     || help_version_count == decoded_options_count - 1);  alloc_switch ();  switches[n_switches].part1 = 0;  alloc_infile ();  infiles[n_infiles].name = 0;}/* Store switches not filtered out by %<S in spec in COLLECT_GCC_OPTIONS   and place that in the environment.  */static voidset_collect_gcc_options (void){  int i;  int first_time;  /* Build COLLECT_GCC_OPTIONS to have all of the options specified to     the compiler.  */  obstack_grow (&collect_obstack, "
		Statement:COLLECT_GCC_OPTIONS
		Statement:=
		Statement:",\t\tsizeof ("
		Statement:COLLECT_GCC_OPTIONS
		Statement:=
		Statement:") - 1);  first_time = TRUE;  for (i = 0; (int) i < n_switches; i++)    {      const char *const *args;      const char *p, *q;      if (!first_time)\tobstack_grow (&collect_obstack, "
		Statement:", 1);      first_time = FALSE;      /* Ignore elided switches.  */      if ((switches[i].live_cond\t   & (SWITCH_IGNORE | SWITCH_KEEP_FOR_GCC))\t  == SWITCH_IGNORE)\tcontinue;      obstack_grow (&collect_obstack, "
		Statement:-
		Statement:", 2);      q = switches[i].part1;      while ((p = strchr (q, '\'')))\t{\t  obstack_grow (&collect_obstack, q, p - q);\t  obstack_grow (&collect_obstack, "
		Statement:'\\'
		Statement:", 4);\t  q = ++p;\t}      obstack_grow (&collect_obstack, q, strlen (q));      obstack_grow (&collect_obstack, "
		Statement:", 1);      for (args = switches[i].args; args && *args; args++)\t{\t  obstack_grow (&collect_obstack, "
		Statement:", 2);\t  q = *args;\t  while ((p = strchr (q, '\'')))\t    {\t      obstack_grow (&collect_obstack, q, p - q);\t      obstack_grow (&collect_obstack, "
		Statement:'\\'
		Statement:", 4);\t      q = ++p;\t    }\t  obstack_grow (&collect_obstack, q, strlen (q));\t  obstack_grow (&collect_obstack, "
		Statement:", 1);\t}    }  obstack_grow (&collect_obstack, "
		Statement:0
		Statement:", 1);  xputenv (XOBFINISH (&collect_obstack, char *));}/* Process a spec string, accumulating and running commands.  *//* These variables describe the input file name.   input_file_number is the index on outfiles of this file,   so that the output file name can be stored for later use by %o.   input_basename is the start of the part of the input file   sans all directory names, and basename_length is the number   of characters starting there excluding the suffix .c or whatever.  */static const char *gcc_input_filename;static int input_file_number;size_t input_filename_length;static int basename_length;static int suffixed_basename_length;static const char *input_basename;static const char *input_suffix;#ifndef HOST_LACKS_INODE_NUMBERSstatic struct stat input_stat;#endifstatic int input_stat_set;/* The compiler used to process the current input file.  */static struct compiler *input_file_compiler;/* These are variables used within do_spec and do_spec_1.  *//* Nonzero if an arg has been started and not yet terminated   (with space, tab or newline).  */static int arg_going;/* Nonzero means %d or %g has been seen; the next arg to be terminated   is a temporary file name.  */static int delete_this_arg;/* Nonzero means %w has been seen; the next arg to be terminated   is the output file name of this compilation.  */static int this_is_output_file;/* Nonzero means %s has been seen; the next arg to be terminated   is the name of a library file and we should try the standard   search dirs for it.  */static int this_is_library_file;/* Nonzero means %T has been seen; the next arg to be terminated   is the name of a linker script and we should try all of the   standard search dirs for it.  If it is found insert a --script   command line switch and then substitute the full path in place,   otherwise generate an error message.  */static int this_is_linker_script;/* Nonzero means that the input of this command is coming from a pipe.  */static int input_from_pipe;/* Nonnull means substitute this for any suffix when outputting a switches   arguments.  */static const char *suffix_subst;/* If there is an argument being accumulated, terminate it and store it.  */static voidend_going_arg (void){  if (arg_going)    {      const char *string;      obstack_1grow (&obstack, 0);      string = XOBFINISH (&obstack, const char *);      if (this_is_library_file)\tstring = find_file (string);      if (this_is_linker_script)\t{\t  char * full_script_path = find_a_file (&startfile_prefixes, string, R_OK, true);\t  if (full_script_path == NULL)\t    {\t      error ("
		Statement:unable
		Statement:to
		Statement:locate
		Statement:default
		Statement:linker
		Statement:script
		Statement:%
		Statement:qs
		Statement:in
		Statement:the
		Statement:library
		Statement:search
		Statement:paths
		Statement:", string);\t      /* Script was not found on search path.  */\t      return;\t    }\t  store_arg ("
		Statement:--
		Statement:script
		Statement:", false, false);\t  string = full_script_path;\t}      store_arg (string, delete_this_arg, this_is_output_file);      if (this_is_output_file)\toutfiles[input_file_number] = string;      arg_going = 0;    }}/* Parse the WRAPPER string which is a comma separated list of the command line   and insert them into the beginning of argbuf.  */static voidinsert_wrapper (const char *wrapper){  int n = 0;  int i;  char *buf = xstrdup (wrapper);  char *p = buf;  unsigned int old_length = argbuf.length ();  do    {      n++;      while (*p == ',')        p++;    }  while ((p = strchr (p, ',')) != NULL);  argbuf.safe_grow (old_length + n);  memmove (argbuf.address () + n,\t   argbuf.address (),\t   old_length * sizeof (const_char_p));  i = 0;  p = buf;  do    {      while (*p == ',')        {          *p = 0;          p++;        }      argbuf[i] = p;      i++;    }  while ((p = strchr (p, ',')) != NULL);  gcc_assert (i == n);}/* Process the spec SPEC and run the commands specified therein.   Returns 0 if the spec is successfully processed; -1 if failed.  */intdo_spec (const char *spec){  int value;  value = do_spec_2 (spec);  /* Force out any unfinished command.     If -pipe, this forces out the last command if it ended in `|'.  */  if (value == 0)    {      if (argbuf.length () > 0\t  && !strcmp (argbuf.last (), "
		Statement:|
		Statement:"))\targbuf.pop ();      set_collect_gcc_options ();      if (argbuf.length () > 0)\tvalue = execute ();    }  return value;}static intdo_spec_2 (const char *spec){  int result;  clear_args ();  arg_going = 0;  delete_this_arg = 0;  this_is_output_file = 0;  this_is_library_file = 0;  this_is_linker_script = 0;  input_from_pipe = 0;  suffix_subst = NULL;  result = do_spec_1 (spec, 0, NULL);  end_going_arg ();  return result;}/* Process the given spec string and add any new options to the end   of the switches/n_switches array.  */static voiddo_option_spec (const char *name, const char *spec){  unsigned int i, value_count, value_len;  const char *p, *q, *value;  char *tmp_spec, *tmp_spec_p;  if (configure_default_options[0].name == NULL)    return;  for (i = 0; i < ARRAY_SIZE (configure_default_options); i++)    if (strcmp (configure_default_options[i].name, name) == 0)      break;  if (i == ARRAY_SIZE (configure_default_options))    return;  value = configure_default_options[i].value;  value_len = strlen (value);  /* Compute the size of the final spec.  */  value_count = 0;  p = spec;  while ((p = strstr (p, "
		Statement:%
		Statement:(
		Statement:VALUE
		Statement:)
		Statement:")) != NULL)    {      p ++;      value_count ++;    }  /* Replace each %(VALUE) by the specified value.  */  tmp_spec = (char *) alloca (strlen (spec) + 1\t\t     + value_count * (value_len - strlen ("
		Statement:%
		Statement:(
		Statement:VALUE
		Statement:)
		Statement:")));  tmp_spec_p = tmp_spec;  q = spec;  while ((p = strstr (q, "
		Statement:%
		Statement:(
		Statement:VALUE
		Statement:)
		Statement:")) != NULL)    {      memcpy (tmp_spec_p, q, p - q);      tmp_spec_p = tmp_spec_p + (p - q);      memcpy (tmp_spec_p, value, value_len);      tmp_spec_p += value_len;      q = p + strlen ("
		Statement:%
		Statement:(
		Statement:VALUE
		Statement:)
		Statement:");    }  strcpy (tmp_spec_p, q);  do_self_spec (tmp_spec);}/* Process the given spec string and add any new options to the end   of the switches/n_switches array.  */static voiddo_self_spec (const char *spec){  int i;  do_spec_2 (spec);  do_spec_1 ("
		Statement:", 0, NULL);  /* Mark %<S switches processed by do_self_spec to be ignored permanently.     do_self_specs adds the replacements to switches array, so it shouldn't     be processed afterwards.  */  for (i = 0; i < n_switches; i++)    if ((switches[i].live_cond & SWITCH_IGNORE))      switches[i].live_cond |= SWITCH_IGNORE_PERMANENTLY;  if (argbuf.length () > 0)    {      const char **argbuf_copy;      struct cl_decoded_option *decoded_options;      struct cl_option_handlers handlers;      unsigned int decoded_options_count;      unsigned int j;      /* Create a copy of argbuf with a dummy argv[0] entry for\t decode_cmdline_options_to_array.  */      argbuf_copy = XNEWVEC (const char *,\t\t\t     argbuf.length () + 1);      argbuf_copy[0] = "
		Statement:";      memcpy (argbuf_copy + 1, argbuf.address (),\t      argbuf.length () * sizeof (const char *));      decode_cmdline_options_to_array (argbuf.length () + 1,\t\t\t\t       argbuf_copy,\t\t\t\t       CL_DRIVER, &decoded_options,\t\t\t\t       &decoded_options_count);      free (argbuf_copy);      set_option_handlers (&handlers);      for (j = 1; j < decoded_options_count; j++)\t{\t  switch (decoded_options[j].opt_index)\t    {\t    case OPT_SPECIAL_input_file:\t      /* Specs should only generate options, not input\t\t files.  */\t      if (strcmp (decoded_options[j].arg, "
		Statement:-
		Statement:") != 0)\t\tfatal_error (input_location,\t\t\t     "
		Statement:switch
		Statement:%
		Statement:qs
		Statement:does
		Statement:not
		Statement:start
		Statement:with
		Statement:%
		Statement:<
		Statement:-
		Statement:%
		Statement:>
		Statement:",\t\t\t     decoded_options[j].arg);\t      else\t\tfatal_error (input_location,\t\t\t     "
		Statement:spec
		Statement:-
		Statement:generated
		Statement:switch
		Statement:is
		Statement:just
		Statement:%
		Statement:<
		Statement:-
		Statement:%
		Statement:>
		Statement:");\t      break;\t    case OPT_fcompare_debug_second:\t    case OPT_fcompare_debug:\t    case OPT_fcompare_debug_:\t    case OPT_o:\t      /* Avoid duplicate processing of some options from\t\t compare-debug specs; just save them here.  */\t      save_switch (decoded_options[j].canonical_option[0],\t\t\t   (decoded_options[j].canonical_option_num_elements\t\t\t    - 1),\t\t\t   &decoded_options[j].canonical_option[1], false, true);\t      break;\t    default:\t      read_cmdline_option (&global_options, &global_options_set,\t\t\t\t   decoded_options + j, UNKNOWN_LOCATION,\t\t\t\t   CL_DRIVER, &handlers, global_dc);\t      break;\t    }\t}      free (decoded_options);      alloc_switch ();      switches[n_switches].part1 = 0;    }}/* Callback for processing %D and %I specs.  */struct spec_path_info {  const char *option;  const char *append;  size_t append_len;  bool omit_relative;  bool separate_options;};static void *spec_path (char *path, void *data){  struct spec_path_info *info = (struct spec_path_info *) data;  size_t len = 0;  char save = 0;  if (info->omit_relative && !IS_ABSOLUTE_PATH (path))    return NULL;  if (info->append_len != 0)    {      len = strlen (path);      memcpy (path + len, info->append, info->append_len + 1);    }  if (!is_directory (path, true))    return NULL;  do_spec_1 (info->option, 1, NULL);  if (info->separate_options)    do_spec_1 ("
		Statement:", 0, NULL);  if (info->append_len == 0)    {      len = strlen (path);      save = path[len - 1];      if (IS_DIR_SEPARATOR (path[len - 1]))\tpath[len - 1] = '\0';    }  do_spec_1 (path, 1, NULL);  do_spec_1 ("
		Statement:", 0, NULL);  /* Must not damage the original path.  */  if (info->append_len == 0)    path[len - 1] = save;  return NULL;}/* Create a temporary FILE with the contents of ARGV. Add @FILE to the   argument list. */static voidcreate_at_file (char **argv){  char *temp_file = make_temp_file ("
		Statement:");  char *at_argument = concat ("
		Statement:", temp_file, NULL);  FILE *f = fopen (temp_file, "
		Statement:w
		Statement:");  int status;  if (f == NULL)    fatal_error (input_location, "
		Statement:could
		Statement:not
		Statement:open
		Statement:temporary
		Statement:response
		Statement:file
		Statement:%
		Statement:s
		Statement:",\t\t temp_file);  status = writeargv (argv, f);  if (status)    fatal_error (input_location,\t\t "
		Statement:could
		Statement:not
		Statement:write
		Statement:to
		Statement:temporary
		Statement:response
		Statement:file
		Statement:%
		Statement:s
		Statement:",\t\t temp_file);  status = fclose (f);  if (EOF == status)    fatal_error (input_location, "
		Statement:could
		Statement:not
		Statement:close
		Statement:temporary
		Statement:response
		Statement:file
		Statement:%
		Statement:s
		Statement:",\t\t temp_file);  store_arg (at_argument, 0, 0);  record_temp_file (temp_file, !save_temps_flag, !save_temps_flag);}/* True if we should compile INFILE. */static boolcompile_input_file_p (struct infile *infile){  if ((!infile->language) || (infile->language[0] != '*'))    if (infile->incompiler == input_file_compiler)      return true;  return false;}/* Process each member of VEC as a spec.  */static voiddo_specs_vec (vec<char_p> vec){  unsigned ix;  char *opt;  FOR_EACH_VEC_ELT (vec, ix, opt)    {      do_spec_1 (opt, 1, NULL);      /* Make each accumulated option a separate argument.  */      do_spec_1 ("
		Statement:", 0, NULL);    }}/* Process the sub-spec SPEC as a portion of a larger spec.   This is like processing a whole spec except that we do   not initialize at the beginning and we do not supply a   newline by default at the end.   INSWITCH nonzero means don't process %-sequences in SPEC;   in this case, % is treated as an ordinary character.   This is used while substituting switches.   INSWITCH nonzero also causes SPC not to terminate an argument.   Value is zero unless a line was finished   and the command on that line reported an error.  */static intdo_spec_1 (const char *spec, int inswitch, const char *soft_matched_part){  const char *p = spec;  int c;  int i;  int value;  /* If it's an empty string argument to a switch, keep it as is.  */  if (inswitch && !*p)    arg_going = 1;  while ((c = *p++))    /* If substituting a switch, treat all chars like letters.       Otherwise, NL, SPC, TAB and % are special.  */    switch (inswitch ? 'a' : c)      {      case '\n':\tend_going_arg ();\tif (argbuf.length () > 0\t    && !strcmp (argbuf.last (), "
		Statement:|
		Statement:"))\t  {\t    /* A `|' before the newline means use a pipe here,\t       but only if -pipe was specified.\t       Otherwise, execute now and don't pass the `|' as an arg.  */\t    if (use_pipes)\t      {\t\tinput_from_pipe = 1;\t\tbreak;\t      }\t    else\t      argbuf.pop ();\t  }\tset_collect_gcc_options ();\tif (argbuf.length () > 0)\t  {\t    value = execute ();\t    if (value)\t      return value;\t  }\t/* Reinitialize for a new command, and for a new argument.  */\tclear_args ();\targ_going = 0;\tdelete_this_arg = 0;\tthis_is_output_file = 0;\tthis_is_library_file = 0;\tthis_is_linker_script = 0;\tinput_from_pipe = 0;\tbreak;      case '|':\tend_going_arg ();\t/* Use pipe */\tobstack_1grow (&obstack, c);\targ_going = 1;\tbreak;      case '\t':      case ' ':\tend_going_arg ();\t/* Reinitialize for a new argument.  */\tdelete_this_arg = 0;\tthis_is_output_file = 0;\tthis_is_library_file = 0;\tthis_is_linker_script = 0;\tbreak;      case '%':\tswitch (c = *p++)\t  {\t  case 0:\t    fatal_error (input_location, "
		Statement:spec
		Statement:%
		Statement:qs
		Statement:invalid
		Statement:", spec);\t  case 'b':\t    if (save_temps_length)\t      obstack_grow (&obstack, save_temps_prefix, save_temps_length);\t    else\t      obstack_grow (&obstack, input_basename, basename_length);\t    if (compare_debug < 0)\t      obstack_grow (&obstack, "
		Statement:.
		Statement:gk
		Statement:", 3);\t    arg_going = 1;\t    break;\t  case 'B':\t    if (save_temps_length)\t      obstack_grow (&obstack, save_temps_prefix, save_temps_length);\t    else\t      obstack_grow (&obstack, input_basename, suffixed_basename_length);\t    if (compare_debug < 0)\t      obstack_grow (&obstack, "
		Statement:.
		Statement:gk
		Statement:", 3);\t    arg_going = 1;\t    break;\t  case 'd':\t    delete_this_arg = 2;\t    break;\t  /* Dump out the directories specified with LIBRARY_PATH,\t     followed by the absolute directories\t     that we search for startfiles.  */\t  case 'D':\t    {\t      struct spec_path_info info;\t      info.option = "
		Statement:-
		Statement:L
		Statement:";\t      info.append_len = 0;#ifdef RELATIVE_PREFIX_NOT_LINKDIR\t      /* Used on systems which record the specified -L dirs\t\t and use them to search for dynamic linking.\t\t Relative directories always come from -B,\t\t and it is better not to use them for searching\t\t at run time.  In particular, stage1 loses.  */\t      info.omit_relative = true;#else\t      info.omit_relative = false;#endif\t      info.separate_options = false;\t      for_each_path (&startfile_prefixes, true, 0, spec_path, &info);\t    }\t    break;\t  case 'e':\t    /* %efoo means report an error with `foo' as error message\t       and don't execute any more commands for this file.  */\t    {\t      const char *q = p;\t      char *buf;\t      while (*p != 0 && *p != '\n')\t\tp++;\t      buf = (char *) alloca (p - q + 1);\t      strncpy (buf, q, p - q);\t      buf[p - q] = 0;\t      error ("
		Statement:%
		Statement:s
		Statement:", _(buf));\t      return -1;\t    }\t    break;\t  case 'n':\t    /* %nfoo means report a notice with `foo' on stderr.  */\t    {\t      const char *q = p;\t      char *buf;\t      while (*p != 0 && *p != '\n')\t\tp++;\t      buf = (char *) alloca (p - q + 1);\t      strncpy (buf, q, p - q);\t      buf[p - q] = 0;\t      inform (UNKNOWN_LOCATION, "
		Statement:%
		Statement:s
		Statement:", _(buf));\t      if (*p)\t\tp++;\t    }\t    break;\t  case 'j':\t    {\t      struct stat st;\t      /* If save_temps_flag is off, and the HOST_BIT_BUCKET is\t\t defined, and it is not a directory, and it is\t\t writable, use it.  Otherwise, treat this like any\t\t other temporary file.  */\t      if ((!save_temps_flag)\t\t  && (stat (HOST_BIT_BUCKET, &st) == 0) && (!S_ISDIR (st.st_mode))\t\t  && (access (HOST_BIT_BUCKET, W_OK) == 0))\t\t{\t\t  obstack_grow (&obstack, HOST_BIT_BUCKET,\t\t\t\tstrlen (HOST_BIT_BUCKET));\t\t  delete_this_arg = 0;\t\t  arg_going = 1;\t\t  break;\t\t}\t    }\t    goto create_temp_file;\t  case '|':\t    if (use_pipes)\t      {\t\tobstack_1grow (&obstack, '-');\t\tdelete_this_arg = 0;\t\targ_going = 1;\t\t/* consume suffix */\t\twhile (*p == '.' || ISALNUM ((unsigned char) *p))\t\t  p++;\t\tif (p[0] == '%' && p[1] == 'O')\t\t  p += 2;\t\tbreak;\t      }\t    goto create_temp_file;\t  case 'm':\t    if (use_pipes)\t      {\t\t/* consume suffix */\t\twhile (*p == '.' || ISALNUM ((unsigned char) *p))\t\t  p++;\t\tif (p[0] == '%' && p[1] == 'O')\t\t  p += 2;\t\tbreak;\t      }\t    goto create_temp_file;\t  case 'g':\t  case 'u':\t  case 'U':\t  create_temp_file:\t      {\t\tstruct temp_name *t;\t\tint suffix_length;\t\tconst char *suffix = p;\t\tchar *saved_suffix = NULL;\t\twhile (*p == '.' || ISALNUM ((unsigned char) *p))\t\t  p++;\t\tsuffix_length = p - suffix;\t\tif (p[0] == '%' && p[1] == 'O')\t\t  {\t\t    p += 2;\t\t    /* We don't support extra suffix characters after %O.  */\t\t    if (*p == '.' || ISALNUM ((unsigned char) *p))\t\t      fatal_error (input_location,\t\t\t\t   "
		Statement:spec
		Statement:%
		Statement:qs
		Statement:has
		Statement:invalid
		Statement:%
		Statement:<
		Statement:%
		Statement:%
		Statement:0
		Statement:%
		Statement:c
		Statement:%
		Statement:>
		Statement:", spec, *p);\t\t    if (suffix_length == 0)\t\t      suffix = TARGET_OBJECT_SUFFIX;\t\t    else\t\t      {\t\t\tsaved_suffix\t\t\t  = XNEWVEC (char, suffix_length\t\t\t\t     + strlen (TARGET_OBJECT_SUFFIX) + 1);\t\t\tstrncpy (saved_suffix, suffix, suffix_length);\t\t\tstrcpy (saved_suffix + suffix_length,\t\t\t\tTARGET_OBJECT_SUFFIX);\t\t      }\t\t    suffix_length += strlen (TARGET_OBJECT_SUFFIX);\t\t  }\t\tif (compare_debug < 0)\t\t  {\t\t    suffix = concat ("
		Statement:.
		Statement:gk
		Statement:", suffix, NULL);\t\t    suffix_length += 3;\t\t  }\t\t/* If -save-temps=obj and -o were specified, use that for the\t\t   temp file.  */\t\tif (save_temps_length)\t\t  {\t\t    char *tmp;\t\t    temp_filename_length\t\t      = save_temps_length + suffix_length + 1;\t\t    tmp = (char *) alloca (temp_filename_length);\t\t    memcpy (tmp, save_temps_prefix, save_temps_length);\t\t    memcpy (tmp + save_temps_length, suffix, suffix_length);\t\t    tmp[save_temps_length + suffix_length] = '\0';\t\t    temp_filename = save_string (tmp, save_temps_length\t\t\t\t\t\t      + suffix_length);\t\t    obstack_grow (&obstack, temp_filename,\t\t\t\t  temp_filename_length);\t\t    arg_going = 1;\t\t    delete_this_arg = 0;\t\t    break;\t\t  }\t\t/* If the gcc_input_filename has the same suffix specified\t\t   for the %g, %u, or %U, and -save-temps is specified,\t\t   we could end up using that file as an intermediate\t\t   thus clobbering the user's source file (.e.g.,\t\t   gcc -save-temps foo.s would clobber foo.s with the\t\t   output of cpp0).  So check for this condition and\t\t   generate a temp file as the intermediate.  */\t\tif (save_temps_flag)\t\t  {\t\t    char *tmp;\t\t    temp_filename_length = basename_length + suffix_length + 1;\t\t    tmp = (char *) alloca (temp_filename_length);\t\t    memcpy (tmp, input_basename, basename_length);\t\t    memcpy (tmp + basename_length, suffix, suffix_length);\t\t    tmp[basename_length + suffix_length] = '\0';\t\t    temp_filename = tmp;\t\t    if (filename_cmp (temp_filename, gcc_input_filename) != 0)\t\t      {#ifndef HOST_LACKS_INODE_NUMBERS\t\t\tstruct stat st_temp;\t\t\t/* Note, set_input() resets input_stat_set to 0.  */\t\t\tif (input_stat_set == 0)\t\t\t  {\t\t\t    input_stat_set = stat (gcc_input_filename,\t\t\t\t\t\t   &input_stat);\t\t\t    if (input_stat_set >= 0)\t\t\t      input_stat_set = 1;\t\t\t  }\t\t\t/* If we have the stat for the gcc_input_filename\t\t\t   and we can do the stat for the temp_filename\t\t\t   then the they could still refer to the same\t\t\t   file if st_dev/st_ino's are the same.  */\t\t\tif (input_stat_set != 1\t\t\t    || stat (temp_filename, &st_temp) < 0\t\t\t    || input_stat.st_dev != st_temp.st_dev\t\t\t    || input_stat.st_ino != st_temp.st_ino)#else\t\t\t/* Just compare canonical pathnames.  */\t\t\tchar* input_realname = lrealpath (gcc_input_filename);\t\t\tchar* temp_realname = lrealpath (temp_filename);\t\t\tbool files_differ = filename_cmp (input_realname, temp_realname);\t\t\tfree (input_realname);\t\t\tfree (temp_realname);\t\t\tif (files_differ)#endif\t\t\t  {\t\t\t    temp_filename\t\t\t      = save_string (temp_filename,\t\t\t\t\t     temp_filename_length - 1);\t\t\t    obstack_grow (&obstack, temp_filename,\t\t\t\t\t\t    temp_filename_length);\t\t\t    arg_going = 1;\t\t\t    delete_this_arg = 0;\t\t\t    break;\t\t\t  }\t\t      }\t\t  }\t\t/* See if we already have an association of %g/%u/%U and\t\t   suffix.  */\t\tfor (t = temp_names; t; t = t->next)\t\t  if (t->length == suffix_length\t\t      && strncmp (t->suffix, suffix, suffix_length) == 0\t\t      && t->unique == (c == 'u' || c == 'U' || c == 'j'))\t\t    break;\t\t/* Make a new association if needed.  %u and %j\t\t   require one.  */\t\tif (t == 0 || c == 'u' || c == 'j')\t\t  {\t\t    if (t == 0)\t\t      {\t\t\tt = XNEW (struct temp_name);\t\t\tt->next = temp_names;\t\t\ttemp_names = t;\t\t      }\t\t    t->length = suffix_length;\t\t    if (saved_suffix)\t\t      {\t\t\tt->suffix = saved_suffix;\t\t\tsaved_suffix = NULL;\t\t      }\t\t    else\t\t      t->suffix = save_string (suffix, suffix_length);\t\t    t->unique = (c == 'u' || c == 'U' || c == 'j');\t\t    temp_filename = make_temp_file (t->suffix);\t\t    temp_filename_length = strlen (temp_filename);\t\t    t->filename = temp_filename;\t\t    t->filename_length = temp_filename_length;\t\t  }\t\tfree (saved_suffix);\t\tobstack_grow (&obstack, t->filename, t->filename_length);\t\tdelete_this_arg = 1;\t      }\t    arg_going = 1;\t    break;\t  case 'i':\t    if (combine_inputs)\t      {\t\tif (at_file_supplied)\t\t  {\t\t    /* We are going to expand `%i' to `@FILE', where FILE\t\t       is a newly-created temporary filename.  The filenames\t\t       that would usually be expanded in place of %o will be\t\t       written to the temporary file.  */\t\t    char **argv;\t\t    int n_files = 0;\t\t    int j;\t\t    for (i = 0; i < n_infiles; i++)\t\t      if (compile_input_file_p (&infiles[i]))\t\t\tn_files++;\t\t    argv = (char **) alloca (sizeof (char *) * (n_files + 1));\t\t    /* Copy the strings over.  */\t\t    for (i = 0, j = 0; i < n_infiles; i++)\t\t      if (compile_input_file_p (&infiles[i]))\t\t\t{\t\t\t  argv[j] = CONST_CAST (char *, infiles[i].name);\t\t\t  infiles[i].compiled = true;\t\t\t  j++;\t\t\t}\t\t    argv[j] = NULL;\t\t    create_at_file (argv);\t\t  }\t\telse\t\t  for (i = 0; (int) i < n_infiles; i++)\t\t    if (compile_input_file_p (&infiles[i]))\t\t      {\t\t\tstore_arg (infiles[i].name, 0, 0);\t\t\tinfiles[i].compiled = true;\t\t      }\t      }\t    else\t      {\t\tobstack_grow (&obstack, gcc_input_filename,\t\t\t      input_filename_length);\t\targ_going = 1;\t      }\t    break;\t  case 'I':\t    {\t      struct spec_path_info info;\t      if (multilib_dir)\t\t{\t\t  do_spec_1 ("
		Statement:-
		Statement:imultilib
		Statement:", 1, NULL);\t\t  /* Make this a separate argument.  */\t\t  do_spec_1 ("
		Statement:", 0, NULL);\t\t  do_spec_1 (multilib_dir, 1, NULL);\t\t  do_spec_1 ("
		Statement:", 0, NULL);\t\t}\t      if (multiarch_dir)\t\t{\t\t  do_spec_1 ("
		Statement:-
		Statement:imultiarch
		Statement:", 1, NULL);\t\t  /* Make this a separate argument.  */\t\t  do_spec_1 ("
		Statement:", 0, NULL);\t\t  do_spec_1 (multiarch_dir, 1, NULL);\t\t  do_spec_1 ("
		Statement:", 0, NULL);\t\t}\t      if (gcc_exec_prefix)\t\t{\t\t  do_spec_1 ("
		Statement:-
		Statement:iprefix
		Statement:", 1, NULL);\t\t  /* Make this a separate argument.  */\t\t  do_spec_1 ("
		Statement:", 0, NULL);\t\t  do_spec_1 (gcc_exec_prefix, 1, NULL);\t\t  do_spec_1 ("
		Statement:", 0, NULL);\t\t}\t      if (target_system_root_changed ||\t\t  (target_system_root && target_sysroot_hdrs_suffix))\t\t{\t\t  do_spec_1 ("
		Statement:-
		Statement:isysroot
		Statement:", 1, NULL);\t\t  /* Make this a separate argument.  */\t\t  do_spec_1 ("
		Statement:", 0, NULL);\t\t  do_spec_1 (target_system_root, 1, NULL);\t\t  if (target_sysroot_hdrs_suffix)\t\t    do_spec_1 (target_sysroot_hdrs_suffix, 1, NULL);\t\t  do_spec_1 ("
		Statement:", 0, NULL);\t\t}\t      info.option = "
		Statement:-
		Statement:isystem
		Statement:";\t      info.append = "
		Statement:include
		Statement:";\t      info.append_len = strlen (info.append);\t      info.omit_relative = false;\t      info.separate_options = true;\t      for_each_path (&include_prefixes, false, info.append_len,\t\t\t     spec_path, &info);\t      info.append = "
		Statement:include
		Statement:-
		Statement:fixed
		Statement:";\t      if (*sysroot_hdrs_suffix_spec)\t\tinfo.append = concat (info.append, dir_separator_str,\t\t\t\t      multilib_dir, NULL);\t      info.append_len = strlen (info.append);\t      for_each_path (&include_prefixes, false, info.append_len,\t\t\t     spec_path, &info);\t    }\t    break;\t  case 'o':\t    {\t      int max = n_infiles;\t      max += lang_specific_extra_outfiles;              if (HAVE_GNU_LD && at_file_supplied)                {                  /* We are going to expand `%o' to `@FILE', where FILE                     is a newly-created temporary filename.  The filenames                     that would usually be expanded in place of %o will be                     written to the temporary file.  */                  char **argv;                  int n_files, j;                  /* Convert OUTFILES into a form suitable for writeargv.  */                  /* Determine how many are non-NULL.  */                  for (n_files = 0, i = 0; i < max; i++)                    n_files += outfiles[i] != NULL;                  argv = (char **) alloca (sizeof (char *) * (n_files + 1));                  /* Copy the strings over.  */                  for (i = 0, j = 0; i < max; i++)                    if (outfiles[i])                      {                        argv[j] = CONST_CAST (char *, outfiles[i]);                        j++;                      }                  argv[j] = NULL;\t\t  create_at_file (argv);                }              else                for (i = 0; i < max; i++)\t          if (outfiles[i])\t\t    store_arg (outfiles[i], 0, 0);\t      break;\t    }\t  case 'O':\t    obstack_grow (&obstack, TARGET_OBJECT_SUFFIX, strlen (TARGET_OBJECT_SUFFIX));\t    arg_going = 1;\t    break;\t  case 's':\t    this_is_library_file = 1;\t    break;\t  case 'T':\t    this_is_linker_script = 1;\t    break;\t  case 'V':\t    outfiles[input_file_number] = NULL;\t    break;\t  case 'w':\t    this_is_output_file = 1;\t    break;\t  case 'W':\t    {\t      unsigned int cur_index = argbuf.length ();\t      /* Handle the {...} following the %W.  */\t      if (*p != '{')\t\tfatal_error (input_location,\t\t\t     "
		Statement:spec
		Statement:%
		Statement:qs
		Statement:has
		Statement:invalid
		Statement:%
		Statement:<
		Statement:%
		Statement:%
		Statement:W
		Statement:%
		Statement:c
		Statement:%
		Statement:>
		Statement:", spec, *p);\t      p = handle_braces (p + 1);\t      if (p == 0)\t\treturn -1;\t      end_going_arg ();\t      /* If any args were output, mark the last one for deletion\t\t on failure.  */\t      if (argbuf.length () != cur_index)\t\trecord_temp_file (argbuf.last (), 0, 1);\t      break;\t    }\t  /* %x{OPTION} records OPTION for %X to output.  */\t  case 'x':\t    {\t      const char *p1 = p;\t      char *string;\t      char *opt;\t      unsigned ix;\t      /* Skip past the option value and make a copy.  */\t      if (*p != '{')\t\tfatal_error (input_location,\t\t\t     "
		Statement:spec
		Statement:%
		Statement:qs
		Statement:has
		Statement:invalid
		Statement:%
		Statement:<
		Statement:%
		Statement:%
		Statement:x
		Statement:%
		Statement:c
		Statement:%
		Statement:>
		Statement:", spec, *p);\t      while (*p++ != '}')\t\t;\t      string = save_string (p1 + 1, p - p1 - 2);\t      /* See if we already recorded this option.  */\t      FOR_EACH_VEC_ELT (linker_options, ix, opt)\t\tif (! strcmp (string, opt))\t\t  {\t\t    free (string);\t\t    return 0;\t\t  }\t      /* This option is new; add it.  */\t      add_linker_option (string, strlen (string));\t      free (string);\t    }\t    break;\t  /* Dump out the options accumulated previously using %x.  */\t  case 'X':\t    do_specs_vec (linker_options);\t    break;\t  /* Dump out the options accumulated previously using -Wa,.  */\t  case 'Y':\t    do_specs_vec (assembler_options);\t    break;\t  /* Dump out the options accumulated previously using -Wp,.  */\t  case 'Z':\t    do_specs_vec (preprocessor_options);\t    break;\t    /* Here are digits and numbers that just process\t       a certain constant string as a spec.  */\t  case '1':\t    value = do_spec_1 (cc1_spec, 0, NULL);\t    if (value != 0)\t      return value;\t    break;\t  case '2':\t    value = do_spec_1 (cc1plus_spec, 0, NULL);\t    if (value != 0)\t      return value;\t    break;\t  case 'a':\t    value = do_spec_1 (asm_spec, 0, NULL);\t    if (value != 0)\t      return value;\t    break;\t  case 'A':\t    value = do_spec_1 (asm_final_spec, 0, NULL);\t    if (value != 0)\t      return value;\t    break;\t  case 'C':\t    {\t      const char *const spec\t\t= (input_file_compiler->cpp_spec\t\t   ? input_file_compiler->cpp_spec\t\t   : cpp_spec);\t      value = do_spec_1 (spec, 0, NULL);\t      if (value != 0)\t\treturn value;\t    }\t    break;\t  case 'E':\t    value = do_spec_1 (endfile_spec, 0, NULL);\t    if (value != 0)\t      return value;\t    break;\t  case 'l':\t    value = do_spec_1 (link_spec, 0, NULL);\t    if (value != 0)\t      return value;\t    break;\t  case 'L':\t    value = do_spec_1 (lib_spec, 0, NULL);\t    if (value != 0)\t      return value;\t    break;\t  case 'M':\t    if (multilib_os_dir == NULL)\t      obstack_1grow (&obstack, '.');\t    else\t      obstack_grow (&obstack, multilib_os_dir,\t\t\t    strlen (multilib_os_dir));\t    break;\t  case 'G':\t    value = do_spec_1 (libgcc_spec, 0, NULL);\t    if (value != 0)\t      return value;\t    break;\t  case 'R':\t    /* We assume there is a directory\t       separator at the end of this string.  */\t    if (target_system_root)\t      {\t        obstack_grow (&obstack, target_system_root,\t\t\t      strlen (target_system_root));\t\tif (target_sysroot_suffix)\t\t  obstack_grow (&obstack, target_sysroot_suffix,\t\t\t\tstrlen (target_sysroot_suffix));\t      }\t    break;\t  case 'S':\t    value = do_spec_1 (startfile_spec, 0, NULL);\t    if (value != 0)\t      return value;\t    break;\t    /* Here we define characters other than letters and digits.  */\t  case '{':\t    p = handle_braces (p);\t    if (p == 0)\t      return -1;\t    break;\t  case ':':\t    p = handle_spec_function (p, NULL);\t    if (p == 0)\t      return -1;\t    break;\t  case '%':\t    obstack_1grow (&obstack, '%');\t    break;\t  case '.':\t    {\t      unsigned len = 0;\t      while (p[len] && p[len] != ' ' && p[len] != '%')\t\tlen++;\t      suffix_subst = save_string (p - 1, len + 1);\t      p += len;\t    }\t   break;\t   /* Henceforth ignore the option(s) matching the pattern\t      after the %<.  */\t  case '<':\t  case '>':\t    {\t      unsigned len = 0;\t      int have_wildcard = 0;\t      int i;\t      int switch_option;\t      if (c == '>')\t\tswitch_option = SWITCH_IGNORE | SWITCH_KEEP_FOR_GCC;\t      else\t\tswitch_option = SWITCH_IGNORE;\t      while (p[len] && p[len] != ' ' && p[len] != '\t')\t\tlen++;\t      if (p[len-1] == '*')\t\thave_wildcard = 1;\t      for (i = 0; i < n_switches; i++)\t\tif (!strncmp (switches[i].part1, p, len - have_wildcard)\t\t    && (have_wildcard || switches[i].part1[len] == '\0'))\t\t  {\t\t    switches[i].live_cond |= switch_option;\t\t    /* User switch be validated from validate_all_switches.\t\t       when the definition is seen from the spec file.\t\t       If not defined anywhere, will be rejected.  */\t\t    if (switches[i].known)\t\t      switches[i].validated = true;\t\t  }\t      p += len;\t    }\t    break;\t  case '*':\t    if (soft_matched_part)\t      {\t\tif (soft_matched_part[0])\t\t  do_spec_1 (soft_matched_part, 1, NULL);\t\t/* Only insert a space after the substitution if it is at the\t\t   end of the current sequence.  So if:\t\t     "
		Statement:%
		CompoundStatement:
			Statement:foo
			Statement:=
			Statement:*
			Statement::
			Statement:bar
			Statement:%
			Statement:*
		Statement:%
		CompoundStatement:
			Statement:foo
			Statement:=
			Statement:*
			Statement::
			Statement:one
			Statement:%
			Statement:*
			Statement:two
		Statement:"\t\t   matches -foo=hello then it will produce:\t\t   \t\t     barhello onehellotwo\t\t*/\t\tif (*p == 0 || *p == '}')\t\t  do_spec_1 ("
		Statement:", 0, NULL);\t      }\t    else\t      /* Catch the case where a spec string contains something like\t\t '%{foo:%*}'.  i.e. there is no * in the pattern on the left\t\t hand side of the :.  */\t      error ("
		Statement:spec
		Label:failure:
			Identifier:failure
		Statement:%
		Statement:<
		Statement:%
		Statement:%
		Statement:*
		Statement:%
		Statement:>
		Statement:has
		Statement:not
		Statement:been
		Statement:initialized
		Statement:by
		Statement:pattern
		Statement:match
		Statement:");\t    break;\t    /* Process a string found as the value of a spec given by name.\t       This feature allows individual machine descriptions\t       to add and use their own specs.  */\t  case '(':\t    {\t      const char *name = p;\t      struct spec_list *sl;\t      int len;\t      /* The string after the S/P is the name of a spec that is to be\t\t processed.  */\t      while (*p && *p != ')')\t\tp++;\t      /* See if it's in the list.  */\t      for (len = p - name, sl = specs; sl; sl = sl->next)\t\tif (sl->name_len == len && !strncmp (sl->name, name, len))\t\t  {\t\t    name = *(sl->ptr_spec);#ifdef DEBUG_SPECS\t\t    fnotice (stderr, "
		Statement:Processing
		Statement:spec
		Statement:(
		Statement:%
		Statement:s
		Statement:)
		Statement:,
		Statement:which
		Statement:is
		Statement:%
		Statement:s
		Statement:n
		Statement:",\t\t\t     sl->name, name);#endif\t\t    break;\t\t  }\t      if (sl)\t\t{\t\t  value = do_spec_1 (name, 0, NULL);\t\t  if (value != 0)\t\t    return value;\t\t}\t      /* Discard the closing paren.  */\t      if (*p)\t\tp++;\t    }\t    break;\t  default:\t    error ("
		Statement:spec
		Label:failure:
			Identifier:failure
		Statement:unrecognized
		Statement:spec
		Statement:option
		Statement:%
		Statement:qc
		Statement:", c);\t    break;\t  }\tbreak;      case '\\':\t/* Backslash: treat next character as ordinary.  */\tc = *p++;\t/* Fall through.  */      default:\t/* Ordinary character: put it into the current argument.  */\tobstack_1grow (&obstack, c);\targ_going = 1;      }  /* End of string.  If we are processing a spec function, we need to     end any pending argument.  */  if (processing_spec_function)    end_going_arg ();  return 0;}/* Look up a spec function.  */static const struct spec_function *lookup_spec_function (const char *name){  const struct spec_function *sf;  for (sf = static_spec_functions; sf->name != NULL; sf++)    if (strcmp (sf->name, name) == 0)      return sf;  return NULL;}/* Evaluate a spec function.  */static const char *eval_spec_function (const char *func, const char *args){  const struct spec_function *sf;  const char *funcval;  /* Saved spec processing context.  */  vec<const_char_p> save_argbuf;  int save_arg_going;  int save_delete_this_arg;  int save_this_is_output_file;  int save_this_is_library_file;  int save_input_from_pipe;  int save_this_is_linker_script;  const char *save_suffix_subst;  int save_growing_size;  void *save_growing_value = NULL;  sf = lookup_spec_function (func);  if (sf == NULL)    fatal_error (input_location, "
		Statement:unknown
		Statement:spec
		Statement:function
		Statement:%
		Statement:qs
		Statement:", func);  /* Push the spec processing context.  */  save_argbuf = argbuf;  save_arg_going = arg_going;  save_delete_this_arg = delete_this_arg;  save_this_is_output_file = this_is_output_file;  save_this_is_library_file = this_is_library_file;  save_this_is_linker_script = this_is_linker_script;  save_input_from_pipe = input_from_pipe;  save_suffix_subst = suffix_subst;  /* If we have some object growing now, finalize it so the args and function     eval proceed from a cleared context.  This is needed to prevent the first     constructed arg from mistakenly including the growing value.  We'll push     this value back on the obstack once the function evaluation is done, to     restore a consistent processing context for our caller.  This is fine as     the address of growing objects isn't guaranteed to remain stable until     they are finalized, and we expect this situation to be rare enough for     the extra copy not to be an issue.  */  save_growing_size = obstack_object_size (&obstack);  if (save_growing_size > 0)    save_growing_value = obstack_finish (&obstack);  /* Create a new spec processing context, and build the function     arguments.  */  alloc_args ();  if (do_spec_2 (args) < 0)    fatal_error (input_location, "
		Statement:error
		Statement:in
		Statement:args
		Statement:to
		Statement:spec
		Statement:function
		Statement:%
		Statement:qs
		Statement:", func);  /* argbuf_index is an index for the next argument to be inserted, and     so contains the count of the args already inserted.  */  funcval = (*sf->func) (argbuf.length (),\t\t\t argbuf.address ());  /* Pop the spec processing context.  */  argbuf.release ();  argbuf = save_argbuf;  arg_going = save_arg_going;  delete_this_arg = save_delete_this_arg;  this_is_output_file = save_this_is_output_file;  this_is_library_file = save_this_is_library_file;  this_is_linker_script = save_this_is_linker_script;  input_from_pipe = save_input_from_pipe;  suffix_subst = save_suffix_subst;  if (save_growing_size > 0)    obstack_grow (&obstack, save_growing_value, save_growing_size);  return funcval;}/* Handle a spec function call of the form:   %:function(args)   ARGS is processed as a spec in a separate context and split into an   argument vector in the normal fashion.  The function returns a string   containing a spec which we then process in the caller's context, or   NULL if no processing is required.   If RETVAL_NONNULL is not NULL, then store a bool whether function   returned non-NULL.  */static const char *handle_spec_function (const char *p, bool *retval_nonnull){  char *func, *args;  const char *endp, *funcval;  int count;  processing_spec_function++;  /* Get the function name.  */  for (endp = p; *endp != '\0'; endp++)    {      if (*endp == '(')\t\t/* ) */        break;      /* Only allow [A-Za-z0-9], -, and _ in function names.  */      if (!ISALNUM (*endp) && !(*endp == '-' || *endp == '_'))\tfatal_error (input_location, "
		Statement:malformed
		Statement:spec
		Statement:function
		Statement:name
		Statement:");    }  if (*endp != '(')\t\t/* ) */    fatal_error (input_location, "
		Statement:no
		Statement:arguments
		Statement:for
		Statement:spec
		Statement:function
		Statement:");  func = save_string (p, endp - p);  p = ++endp;  /* Get the arguments.  */  for (count = 0; *endp != '\0'; endp++)    {      /* ( */      if (*endp == ')')\t{\t  if (count == 0)\t    break;\t  count--;\t}      else if (*endp == '(')\t/* ) */\tcount++;    }  /* ( */  if (*endp != ')')    fatal_error (input_location, "
		Statement:malformed
		Statement:spec
		Statement:function
		Statement:arguments
		Statement:");  args = save_string (p, endp - p);  p = ++endp;  /* p now points to just past the end of the spec function expression.  */  funcval = eval_spec_function (func, args);  if (funcval != NULL && do_spec_1 (funcval, 0, NULL) < 0)    p = NULL;  if (retval_nonnull)    *retval_nonnull = funcval != NULL;  free (func);  free (args);  processing_spec_function--;  return p;}/* Inline subroutine of handle_braces.  Returns true if the current   input suffix matches the atom bracketed by ATOM and END_ATOM.  */static inline boolinput_suffix_matches (const char *atom, const char *end_atom){  return (input_suffix\t  && !strncmp (input_suffix, atom, end_atom - atom)\t  && input_suffix[end_atom - atom] == '\0');}/* Subroutine of handle_braces.  Returns true if the current   input file's spec name matches the atom bracketed by ATOM and END_ATOM.  */static boolinput_spec_matches (const char *atom, const char *end_atom){  return (input_file_compiler\t  && input_file_compiler->suffix\t  && input_file_compiler->suffix[0] != '\0'\t  && !strncmp (input_file_compiler->suffix + 1, atom,\t\t       end_atom - atom)\t  && input_file_compiler->suffix[end_atom - atom + 1] == '\0');}/* Subroutine of handle_braces.  Returns true if a switch   matching the atom bracketed by ATOM and END_ATOM appeared on the   command line.  */static boolswitch_matches (const char *atom, const char *end_atom, int starred){  int i;  int len = end_atom - atom;  int plen = starred ? len : -1;  for (i = 0; i < n_switches; i++)    if (!strncmp (switches[i].part1, atom, len)\t&& (starred || switches[i].part1[len] == '\0')\t&& check_live_switch (i, plen))      return true;    /* Check if a switch with separated form matching the atom.       We check -D and -U switches. */    else if (switches[i].args != 0)      {\tif ((*switches[i].part1 == 'D' || *switches[i].part1 == 'U')\t    && *switches[i].part1 == atom[0])\t  {\t    if (!strncmp (switches[i].args[0], &atom[1], len - 1)\t\t&& (starred || (switches[i].part1[1] == '\0'\t\t\t\t&& switches[i].args[0][len - 1] == '\0'))\t\t&& check_live_switch (i, (starred ? 1 : -1)))\t      return true;\t  }      }  return false;}/* Inline subroutine of handle_braces.  Mark all of the switches which   match ATOM (extends to END_ATOM; STARRED indicates whether there   was a star after the atom) for later processing.  */static inline voidmark_matching_switches (const char *atom, const char *end_atom, int starred){  int i;  int len = end_atom - atom;  int plen = starred ? len : -1;  for (i = 0; i < n_switches; i++)    if (!strncmp (switches[i].part1, atom, len)\t&& (starred || switches[i].part1[len] == '\0')\t&& check_live_switch (i, plen))      switches[i].ordering = 1;}/* Inline subroutine of handle_braces.  Process all the currently   marked switches through give_switch, and clear the marks.  */static inline voidprocess_marked_switches (void){  int i;  for (i = 0; i < n_switches; i++)    if (switches[i].ordering == 1)      {\tswitches[i].ordering = 0;\tgive_switch (i, 0);      }}/* Handle a %{ ... } construct.  P points just inside the leading {.   Returns a pointer one past the end of the brace block, or 0   if we call do_spec_1 and that returns -1.  */static const char *handle_braces (const char *p){  const char *atom, *end_atom;  const char *d_atom = NULL, *d_end_atom = NULL;  char *esc_buf = NULL, *d_esc_buf = NULL;  int esc;  const char *orig = p;  bool a_is_suffix;  bool a_is_spectype;  bool a_is_starred;  bool a_is_negated;  bool a_matched;  bool a_must_be_last = false;  bool ordered_set    = false;  bool disjunct_set   = false;  bool disj_matched   = false;  bool disj_starred   = true;  bool n_way_choice   = false;  bool n_way_matched  = false;#define SKIP_WHITE() do { while (*p == ' ' || *p == '\t') p++; } while (0)  do    {      if (a_must_be_last)\tgoto invalid;      /* Scan one "
		Statement:atom
		Statement:" (S in the description above of %{}, possibly\t with '!', '.', '@', ',', or '*' modifiers).  */      a_matched = false;      a_is_suffix = false;      a_is_starred = false;      a_is_negated = false;      a_is_spectype = false;      SKIP_WHITE ();      if (*p == '!')\tp++, a_is_negated = true;      SKIP_WHITE ();      if (*p == '%' && p[1] == ':')\t{\t  atom = NULL;\t  end_atom = NULL;\t  p = handle_spec_function (p + 2, &a_matched);\t}      else\t{\t  if (*p == '.')\t    p++, a_is_suffix = true;\t  else if (*p == ',')\t    p++, a_is_spectype = true;\t  atom = p;\t  esc = 0;\t  while (ISIDNUM (*p) || *p == '-' || *p == '+' || *p == '='\t\t || *p == ',' || *p == '.' || *p == '@' || *p == '\\')\t    {\t      if (*p == '\\')\t\t{\t\t  p++;\t\t  if (!*p)\t\t    fatal_error (input_location,\t\t\t\t "
		Statement:braced
		Statement:spec
		Statement:%
		Statement:qs
		Statement:ends
		Statement:in
		Statement:escape
		Statement:", orig);\t\t  esc++;\t\t}\t      p++;\t    }\t  end_atom = p;\t  if (esc)\t    {\t      const char *ap;\t      char *ep;\t      if (esc_buf && esc_buf != d_esc_buf)\t\tfree (esc_buf);\t      esc_buf = NULL;\t      ep = esc_buf = (char *) xmalloc (end_atom - atom - esc + 1);\t      for (ap = atom; ap != end_atom; ap++, ep++)\t\t{\t\t  if (*ap == '\\')\t\t    ap++;\t\t  *ep = *ap;\t\t}\t      *ep = '\0';\t      atom = esc_buf;\t      end_atom = ep;\t    }\t  if (*p == '*')\t    p++, a_is_starred = 1;\t}      SKIP_WHITE ();      switch (*p)\t{\tcase '&': case '}':\t  /* Substitute the switch(es) indicated by the current atom.  */\t  ordered_set = true;\t  if (disjunct_set || n_way_choice || a_is_negated || a_is_suffix\t      || a_is_spectype || atom == end_atom)\t    goto invalid;\t  mark_matching_switches (atom, end_atom, a_is_starred);\t  if (*p == '}')\t    process_marked_switches ();\t  break;\tcase '|': case ':':\t  /* Substitute some text if the current atom appears as a switch\t     or suffix.  */\t  disjunct_set = true;\t  if (ordered_set)\t    goto invalid;\t  if (atom && atom == end_atom)\t    {\t      if (!n_way_choice || disj_matched || *p == '|'\t\t  || a_is_negated || a_is_suffix || a_is_spectype\t\t  || a_is_starred)\t\tgoto invalid;\t      /* An empty term may appear as the last choice of an\t\t N-way choice set; it means "
		Statement:otherwise
		Statement:".  */\t      a_must_be_last = true;\t      disj_matched = !n_way_matched;\t      disj_starred = false;\t    }\t  else\t    {\t      if ((a_is_suffix || a_is_spectype) && a_is_starred)\t\tgoto invalid;\t      if (!a_is_starred)\t\tdisj_starred = false;\t      /* Don't bother testing this atom if we already have a\t\t match.  */\t      if (!disj_matched && !n_way_matched)\t\t{\t\t  if (atom == NULL)\t\t    /* a_matched is already set by handle_spec_function.  */;\t\t  else if (a_is_suffix)\t\t    a_matched = input_suffix_matches (atom, end_atom);\t\t  else if (a_is_spectype)\t\t    a_matched = input_spec_matches (atom, end_atom);\t\t  else\t\t    a_matched = switch_matches (atom, end_atom, a_is_starred);\t\t  if (a_matched != a_is_negated)\t\t    {\t\t      disj_matched = true;\t\t      d_atom = atom;\t\t      d_end_atom = end_atom;\t\t      d_esc_buf = esc_buf;\t\t    }\t\t}\t    }\t  if (*p == ':')\t    {\t      /* Found the body, that is, the text to substitute if the\t\t current disjunction matches.  */\t      p = process_brace_body (p + 1, d_atom, d_end_atom, disj_starred,\t\t\t\t      disj_matched && !n_way_matched);\t      if (p == 0)\t\tgoto done;\t      /* If we have an N-way choice, reset state for the next\t\t disjunction.  */\t      if (*p == ';')\t\t{\t\t  n_way_choice = true;\t\t  n_way_matched |= disj_matched;\t\t  disj_matched = false;\t\t  disj_starred = true;\t\t  d_atom = d_end_atom = NULL;\t\t}\t    }\t  break;\tdefault:\t  goto invalid;\t}    }  while (*p++ != '}'); done:  if (d_esc_buf && d_esc_buf != esc_buf)    free (d_esc_buf);  if (esc_buf)    free (esc_buf);  return p; invalid:  fatal_error (input_location, "
		Statement:braced
		Statement:spec
		Statement:%
		Statement:qs
		Statement:is
		Statement:invalid
		Statement:at
		Statement:%
		Statement:qc
		Statement:", orig, *p);#undef SKIP_WHITE}/* Subroutine of handle_braces.  Scan and process a brace substitution body   (X in the description of %{} syntax).  P points one past the colon;   ATOM and END_ATOM bracket the first atom which was found to be true   (present) in the current disjunction; STARRED indicates whether all   the atoms in the current disjunction were starred (for syntax validation);   MATCHED indicates whether the disjunction matched or not, and therefore   whether or not the body is to be processed through do_spec_1 or just   skipped.  Returns a pointer to the closing } or ;, or 0 if do_spec_1   returns -1.  */static const char *process_brace_body (const char *p, const char *atom, const char *end_atom,\t\t    int starred, int matched){  const char *body, *end_body;  unsigned int nesting_level;  bool have_subst     = false;  /* Locate the closing } or ;, honoring nested braces.     Trim trailing whitespace.  */  body = p;  nesting_level = 1;  for (;;)    {      if (*p == '{')\tnesting_level++;      else if (*p == '}')\t{\t  if (!--nesting_level)\t    break;\t}      else if (*p == ';' && nesting_level == 1)\tbreak;      else if (*p == '%' && p[1] == '*' && nesting_level == 1)\thave_subst = true;      else if (*p == '\0')\tgoto invalid;      p++;    }  end_body = p;  while (end_body[-1] == ' ' || end_body[-1] == '\t')    end_body--;  if (have_subst && !starred)    goto invalid;  if (matched)    {      /* Copy the substitution body to permanent storage and execute it.\t If have_subst is false, this is a simple matter of running the\t body through do_spec_1...  */      char *string = save_string (body, end_body - body);      if (!have_subst)\t{\t  if (do_spec_1 (string, 0, NULL) < 0)\t    {\t      free (string);\t      return 0;\t    }\t}      else\t{\t  /* ... but if have_subst is true, we have to process the\t     body once for each matching switch, with %* set to the\t     variant part of the switch.  */\t  unsigned int hard_match_len = end_atom - atom;\t  int i;\t  for (i = 0; i < n_switches; i++)\t    if (!strncmp (switches[i].part1, atom, hard_match_len)\t\t&& check_live_switch (i, hard_match_len))\t      {\t\tif (do_spec_1 (string, 0,\t\t\t       &switches[i].part1[hard_match_len]) < 0)\t\t  {\t\t    free (string);\t\t    return 0;\t\t  }\t\t/* Pass any arguments this switch has.  */\t\tgive_switch (i, 1);\t\tsuffix_subst = NULL;\t      }\t}      free (string);    }  return p; invalid:  fatal_error (input_location, "
		Statement:braced
		Statement:spec
		Statement:body
		Statement:%
		Statement:qs
		Statement:is
		Statement:invalid
		Statement:", body);}/* Return 0 iff switch number SWITCHNUM is obsoleted by a later switch   on the command line.  PREFIX_LENGTH is the length of XXX in an {XXX*}   spec, or -1 if either exact match or %* is used.   A -O switch is obsoleted by a later -O switch.  A -f, -g, -m, or -W switch   whose value does not begin with "
		Statement:no
		Statement:-
		Statement:" is obsoleted by the same value   with the "
		Statement:no
		Statement:-
		Statement:", similarly for a switch with the "
		Statement:no
		Statement:-
		Statement:" prefix.  */static intcheck_live_switch (int switchnum, int prefix_length){  const char *name = switches[switchnum].part1;  int i;  /* If we already processed this switch and determined if it was     live or not, return our past determination.  */  if (switches[switchnum].live_cond != 0)    return ((switches[switchnum].live_cond & SWITCH_LIVE) != 0\t    && (switches[switchnum].live_cond & SWITCH_FALSE) == 0\t    && (switches[switchnum].live_cond & SWITCH_IGNORE_PERMANENTLY)\t       == 0);  /* In the common case of {<at-most-one-letter>*}, a negating     switch would always match, so ignore that case.  We will just     send the conflicting switches to the compiler phase.  */  if (prefix_length >= 0 && prefix_length <= 1)    return 1;  /* Now search for duplicate in a manner that depends on the name.  */  switch (*name)    {    case 'O':      for (i = switchnum + 1; i < n_switches; i++)\tif (switches[i].part1[0] == 'O')\t  {\t    switches[switchnum].validated = true;\t    switches[switchnum].live_cond = SWITCH_FALSE;\t    return 0;\t  }      break;    case 'W':  case 'f':  case 'm': case 'g':      if (! strncmp (name + 1, "
		Statement:no
		Statement:-
		Statement:", 3))\t{\t  /* We have Xno-YYY, search for XYYY.  */\t  for (i = switchnum + 1; i < n_switches; i++)\t    if (switches[i].part1[0] == name[0]\t\t&& ! strcmp (&switches[i].part1[1], &name[4]))\t      {\t\t/* --specs are validated with the validate_switches mechanism.  */\t\tif (switches[switchnum].known)\t\t  switches[switchnum].validated = true;\t\tswitches[switchnum].live_cond = SWITCH_FALSE;\t\treturn 0;\t      }\t}      else\t{\t  /* We have XYYY, search for Xno-YYY.  */\t  for (i = switchnum + 1; i < n_switches; i++)\t    if (switches[i].part1[0] == name[0]\t\t&& switches[i].part1[1] == 'n'\t\t&& switches[i].part1[2] == 'o'\t\t&& switches[i].part1[3] == '-'\t\t&& !strcmp (&switches[i].part1[4], &name[1]))\t      {\t\t/* --specs are validated with the validate_switches mechanism.  */\t\tif (switches[switchnum].known)\t\t  switches[switchnum].validated = true;\t\tswitches[switchnum].live_cond = SWITCH_FALSE;\t\treturn 0;\t      }\t}      break;    }  /* Otherwise the switch is live.  */  switches[switchnum].live_cond |= SWITCH_LIVE;  return 1;}/* Pass a switch to the current accumulating command   in the same form that we received it.   SWITCHNUM identifies the switch; it is an index into   the vector of switches gcc received, which is `switches'.   This cannot fail since it never finishes a command line.   If OMIT_FIRST_WORD is nonzero, then we omit .part1 of the argument.  */static voidgive_switch (int switchnum, int omit_first_word){  if ((switches[switchnum].live_cond & SWITCH_IGNORE) != 0)    return;  if (!omit_first_word)    {      do_spec_1 ("
		Statement:-
		Statement:", 0, NULL);      do_spec_1 (switches[switchnum].part1, 1, NULL);    }  if (switches[switchnum].args != 0)    {      const char **p;      for (p = switches[switchnum].args; *p; p++)\t{\t  const char *arg = *p;\t  do_spec_1 ("
		Statement:", 0, NULL);\t  if (suffix_subst)\t    {\t      unsigned length = strlen (arg);\t      int dot = 0;\t      while (length-- && !IS_DIR_SEPARATOR (arg[length]))\t\tif (arg[length] == '.')\t\t  {\t\t    (CONST_CAST (char *, arg))[length] = 0;\t\t    dot = 1;\t\t    break;\t\t  }\t      do_spec_1 (arg, 1, NULL);\t      if (dot)\t\t(CONST_CAST (char *, arg))[length] = '.';\t      do_spec_1 (suffix_subst, 1, NULL);\t    }\t  else\t    do_spec_1 (arg, 1, NULL);\t}    }  do_spec_1 ("
		Statement:", 0, NULL);  switches[switchnum].validated = true;}/* Print GCC configuration (e.g. version, thread model, target,   configuration_arguments) to a given FILE.  */static voidprint_configuration (FILE *file){  int n;  const char *thrmod;  fnotice (file, "
		Label:Target:
			Identifier:Target
		Statement:%
		Statement:s
		Statement:n
		Statement:", spec_machine);  fnotice (file, "
		Statement:Configured
		Label:with:
			Identifier:with
		Statement:%
		Statement:s
		Statement:n
		Statement:", configuration_arguments);#ifdef THREAD_MODEL_SPEC  /* We could have defined THREAD_MODEL_SPEC to "
		Statement:%
		Statement:*
		Statement:" by default,  but there's no point in doing all this processing just to get  thread_model back.  */  obstack_init (&obstack);  do_spec_1 (THREAD_MODEL_SPEC, 0, thread_model);  obstack_1grow (&obstack, '\0');  thrmod = XOBFINISH (&obstack, const char *);#else  thrmod = thread_model;#endif  fnotice (file, "
		Statement:Thread
		Label:model:
			Identifier:model
		Statement:%
		Statement:s
		Statement:n
		Statement:", thrmod);  /* compiler_version is truncated at the first space when initialized  from version string, so truncate version_string at the first space  before comparing.  */  for (n = 0; version_string[n]; n++)    if (version_string[n] == ' ')      break;  if (! strncmp (version_string, compiler_version, n)      && compiler_version[n] == 0)    fnotice (file, "
		Statement:gcc
		Statement:version
		Statement:%
		Statement:s
		Statement:%
		Statement:s
		Statement:n
		Statement:", version_string,\t     pkgversion_string);  else    fnotice (file, "
		Statement:gcc
		Statement:driver
		Statement:version
		Statement:%
		Statement:s
		Statement:%
		Statement:sexecuting
		Statement:gcc
		Statement:version
		Statement:%
		Statement:s
		Statement:n
		Statement:",\t     version_string, pkgversion_string, compiler_version);}#define RETRY_ICE_ATTEMPTS 3/* Returns true if FILE1 and FILE2 contain equivalent data, 0 otherwise.  */static boolfiles_equal_p (char *file1, char *file2){  struct stat st1, st2;  off_t n, len;  int fd1, fd2;  const int bufsize = 8192;  char *buf = XNEWVEC (char, bufsize);  fd1 = open (file1, O_RDONLY);  fd2 = open (file2, O_RDONLY);  if (fd1 < 0 || fd2 < 0)    goto error;  if (fstat (fd1, &st1) < 0 || fstat (fd2, &st2) < 0)    goto error;  if (st1.st_size != st2.st_size)    goto error;  for (n = st1.st_size; n; n -= len)    {      len = n;      if ((int) len > bufsize / 2)\tlen = bufsize / 2;      if (read (fd1, buf, len) != (int) len\t  || read (fd2, buf + bufsize / 2, len) != (int) len)\t{\t  goto error;\t}      if (memcmp (buf, buf + bufsize / 2, len) != 0)\tgoto error;    }  free (buf);  close (fd1);  close (fd2);  return 1;error:  free (buf);  close (fd1);  close (fd2);  return 0;}/* Check that compiler's output doesn't differ across runs.   TEMP_STDOUT_FILES and TEMP_STDERR_FILES are arrays of files, containing   stdout and stderr for each compiler run.  Return true if all of   TEMP_STDOUT_FILES and TEMP_STDERR_FILES are equivalent.  */static boolcheck_repro (char **temp_stdout_files, char **temp_stderr_files){  int i;  for (i = 0; i < RETRY_ICE_ATTEMPTS - 2; ++i)    {     if (!files_equal_p (temp_stdout_files[i], temp_stdout_files[i + 1])\t || !files_equal_p (temp_stderr_files[i], temp_stderr_files[i + 1]))       {\t fnotice (stderr, "
		Statement:The
		Statement:bug
		Statement:is
		Statement:not
		Statement:reproducible
		Statement:,
		Statement:so
		Statement:it
		Statement:is
		Statement:"\t\t  "
		Statement:likely
		Statement:a
		Statement:hardware
		Statement:or
		Statement:OS
		Statement:problem
		Statement:.
		Statement:n
		Statement:");\t break;       }    }  return i == RETRY_ICE_ATTEMPTS - 2;}enum attempt_status {  ATTEMPT_STATUS_FAIL_TO_RUN,  ATTEMPT_STATUS_SUCCESS,  ATTEMPT_STATUS_ICE};/* Run compiler with arguments NEW_ARGV to reproduce the ICE, storing stdout   to OUT_TEMP and stderr to ERR_TEMP.  If APPEND is TRUE, append to OUT_TEMP   and ERR_TEMP instead of truncating.  If EMIT_SYSTEM_INFO is TRUE, also write   GCC configuration into to ERR_TEMP.  Return ATTEMPT_STATUS_FAIL_TO_RUN if   compiler failed to run, ATTEMPT_STATUS_ICE if compiled ICE-ed and   ATTEMPT_STATUS_SUCCESS otherwise.  */static enum attempt_statusrun_attempt (const char **new_argv, const char *out_temp,\t     const char *err_temp, int emit_system_info, int append){  if (emit_system_info)    {      FILE *file_out = fopen (err_temp, "
		Statement:a
		Statement:");      print_configuration (file_out);      fputs ("
		Statement:n
		Statement:", file_out);      fclose (file_out);    }  int exit_status;  const char *errmsg;  struct pex_obj *pex;  int err;  int pex_flags = PEX_USE_PIPES | PEX_LAST;  enum attempt_status status = ATTEMPT_STATUS_FAIL_TO_RUN;  if (append)    pex_flags |= PEX_STDOUT_APPEND | PEX_STDERR_APPEND;  pex = pex_init (PEX_USE_PIPES, new_argv[0], NULL);  if (!pex)    fatal_error (input_location, "
		Statement:pex_init
		Label:failed:
			Identifier:failed
		Statement:%
		Statement:m
		Statement:");  errmsg = pex_run (pex, pex_flags, new_argv[0],\t\t    CONST_CAST2 (char *const *, const char **, &new_argv[1]), out_temp,\t\t    err_temp, &err);  if (errmsg != NULL)    {      if (err == 0)\tfatal_error (input_location, errmsg);      else\t{\t  errno = err;\t  pfatal_with_name (errmsg);\t}    }  if (!pex_get_status (pex, 1, &exit_status))    goto out;  switch (WEXITSTATUS (exit_status))    {      case ICE_EXIT_CODE:\tstatus = ATTEMPT_STATUS_ICE;\tbreak;      case SUCCESS_EXIT_CODE:\tstatus = ATTEMPT_STATUS_SUCCESS;\tbreak;      default:\t;    }out:  pex_free (pex);  return status;}/* This routine reads lines from IN file, adds C++ style comments   at the begining of each line and writes result into OUT.  */static voidinsert_comments (const char *file_in, const char *file_out){  FILE *in = fopen (file_in, "
		Statement:rb
		Statement:");  FILE *out = fopen (file_out, "
		Statement:wb
		Statement:");  char line[256];  bool add_comment = true;  while (fgets (line, sizeof (line), in))    {      if (add_comment)\tfputs ("
		Statement:/
		Statement:/
		Statement:", out);      fputs (line, out);      add_comment = strchr (line, '\n') != NULL;    }  fclose (in);  fclose (out);}/* This routine adds preprocessed source code into the given ERR_FILE.   To do this, it adds "
		Statement:-
		Statement:E
		Statement:" to NEW_ARGV and execute RUN_ATTEMPT routine to   add information in report file.  RUN_ATTEMPT should return   ATTEMPT_STATUS_SUCCESS, in other case we cannot generate the report.  */static voiddo_report_bug (const char **new_argv, const int nargs,\t       char **out_file, char **err_file){  int i, status;  int fd = open (*out_file, O_RDWR | O_APPEND);  if (fd < 0)    return;  write (fd, "
		Statement:n
		Statement:/
		Statement:/
		Statement:", 3);  for (i = 0; i < nargs; i++)    {      write (fd, "
		Statement:", 1);      write (fd, new_argv[i], strlen (new_argv[i]));    }  write (fd, "
		Statement:n
		Statement:n
		Statement:", 2);  close (fd);  new_argv[nargs] = "
		Statement:-
		Statement:E
		Statement:";  new_argv[nargs + 1] = NULL;  status = run_attempt (new_argv, *out_file, *err_file, 0, 1);  if (status == ATTEMPT_STATUS_SUCCESS)    {      fnotice (stderr, "
		Statement:Preprocessed
		Statement:source
		Statement:stored
		Statement:into
		Statement:%
		Statement:s
		Statement:file
		Statement:,
		Statement:"\t       "
		Statement:please
		Statement:attach
		Statement:this
		Statement:to
		Statement:your
		Statement:bugreport
		Statement:.
		Statement:n
		Statement:", *out_file);      /* Make sure it is not deleted.  */      free (*out_file);      *out_file = NULL;    }}/* Try to reproduce ICE.  If bug is reproducible, generate report .err file   containing GCC configuration, backtrace, compiler's command line options   and preprocessed source code.  */static voidtry_generate_repro (const char **argv){  int i, nargs, out_arg = -1, quiet = 0, attempt;  const char **new_argv;  char *temp_files[RETRY_ICE_ATTEMPTS * 2];  char **temp_stdout_files = &temp_files[0];  char **temp_stderr_files = &temp_files[RETRY_ICE_ATTEMPTS];  if (gcc_input_filename == NULL || ! strcmp (gcc_input_filename, "
		Statement:-
		Statement:"))    return;  for (nargs = 0; argv[nargs] != NULL; ++nargs)    /* Only retry compiler ICEs, not preprocessor ones.  */    if (! strcmp (argv[nargs], "
		Statement:-
		Statement:E
		Statement:"))      return;    else if (argv[nargs][0] == '-' && argv[nargs][1] == 'o')      {\tif (out_arg == -1)\t  out_arg = nargs;\telse\t  return;      }    /* If the compiler is going to output any time information,       it might varry between invocations.  */    else if (! strcmp (argv[nargs], "
		Statement:-
		Statement:quiet
		Statement:"))      quiet = 1;    else if (! strcmp (argv[nargs], "
		Statement:-
		Statement:ftime
		Statement:-
		Statement:report
		Statement:"))      return;  if (out_arg == -1 || !quiet)    return;  memset (temp_files, '\0', sizeof (temp_files));  new_argv = XALLOCAVEC (const char *, nargs + 4);  memcpy (new_argv, argv, (nargs + 1) * sizeof (const char *));  new_argv[nargs++] = "
		Statement:-
		Statement:frandom
		Statement:-
		Statement:seed
		Statement:=
		Statement:0
		Statement:";  new_argv[nargs++] = "
		Statement:-
		Statement:fdump
		Statement:-
		Statement:noaddr
		Statement:";  new_argv[nargs] = NULL;  if (new_argv[out_arg][2] == '\0')    new_argv[out_arg + 1] = "
		Statement:-
		Statement:";  else    new_argv[out_arg] = "
		Statement:-
		Statement:o
		Statement:-
		Statement:";  int status;  for (attempt = 0; attempt < RETRY_ICE_ATTEMPTS; ++attempt)    {      int emit_system_info = 0;      int append = 0;      temp_stdout_files[attempt] = make_temp_file ("
		Statement:.
		Statement:out
		Statement:");      temp_stderr_files[attempt] = make_temp_file ("
		Statement:.
		Statement:err
		Statement:");      if (attempt == RETRY_ICE_ATTEMPTS - 1)\t{\t  append = 1;\t  emit_system_info = 1;\t}      status = run_attempt (new_argv, temp_stdout_files[attempt],\t\t\t    temp_stderr_files[attempt], emit_system_info,\t\t\t    append);      if (status != ATTEMPT_STATUS_ICE)\t{\t  fnotice (stderr, "
		Statement:The
		Statement:bug
		Statement:is
		Statement:not
		Statement:reproducible
		Statement:,
		Statement:so
		Statement:it
		Statement:is
		Statement:"\t\t   "
		Statement:likely
		Statement:a
		Statement:hardware
		Statement:or
		Statement:OS
		Statement:problem
		Statement:.
		Statement:n
		Statement:");\t  goto out;\t}    }  if (!check_repro (temp_stdout_files, temp_stderr_files))    goto out;  {    /* Insert commented out backtrace into report file.  */    char **stderr_commented = &temp_stdout_files[RETRY_ICE_ATTEMPTS - 1];    insert_comments (temp_stderr_files[RETRY_ICE_ATTEMPTS - 1],\t\t     *stderr_commented);    /* In final attempt we append compiler options and preprocesssed code to last       generated .out file with configuration and backtrace.  */    char **err = &temp_stderr_files[RETRY_ICE_ATTEMPTS - 1];    do_report_bug (new_argv, nargs, stderr_commented, err);  }out:  for (i = 0; i < RETRY_ICE_ATTEMPTS * 2; i++)    if (temp_files[i])      {\tunlink (temp_stdout_files[i]);\tfree (temp_stdout_files[i]);      }}/* Search for a file named NAME trying various prefixes including the   user's -B prefix and some standard ones.   Return the absolute file name found.  If nothing is found, return NAME.  */static const char *find_file (const char *name){  char *newname = find_a_file (&startfile_prefixes, name, R_OK, true);  return newname ? newname : name;}/* Determine whether a directory exists.  If LINKER, return 0 for   certain fixed names not needed by the linker.  */static intis_directory (const char *path1, bool linker){  int len1;  char *path;  char *cp;  struct stat st;  /* Ensure the string ends with "
		Statement:/
		Statement:.
		Statement:".  The resulting path will be a     directory even if the given path is a symbolic link.  */  len1 = strlen (path1);  path = (char *) alloca (3 + len1);  memcpy (path, path1, len1);  cp = path + len1;  if (!IS_DIR_SEPARATOR (cp[-1]))    *cp++ = DIR_SEPARATOR;  *cp++ = '.';  *cp = '\0';  /* Exclude directories that the linker is known to search.  */  if (linker      && IS_DIR_SEPARATOR (path[0])      && ((cp - path == 6\t   && filename_ncmp (path + 1, "
		Statement:lib
		Statement:", 3) == 0)\t  || (cp - path == 10\t      && filename_ncmp (path + 1, "
		Statement:usr
		Statement:", 3) == 0\t      && IS_DIR_SEPARATOR (path[4])\t      && filename_ncmp (path + 5, "
		Statement:lib
		Statement:", 3) == 0)))    return 0;  return (stat (path, &st) >= 0 && S_ISDIR (st.st_mode));}/* Set up the various global variables to indicate that we're processing   the input file named FILENAME.  */voidset_input (const char *filename){  const char *p;  gcc_input_filename = filename;  input_filename_length = strlen (gcc_input_filename);  input_basename = lbasename (gcc_input_filename);  /* Find a suffix starting with the last period,     and set basename_length to exclude that suffix.  */  basename_length = strlen (input_basename);  suffixed_basename_length = basename_length;  p = input_basename + basename_length;  while (p != input_basename && *p != '.')    --p;  if (*p == '.' && p != input_basename)    {      basename_length = p - input_basename;      input_suffix = p + 1;    }  else    input_suffix = "
		Statement:";  /* If a spec for 'g', 'u', or 'U' is seen with -save-temps then     we will need to do a stat on the gcc_input_filename.  The     INPUT_STAT_SET signals that the stat is needed.  */  input_stat_set = 0;}/* On fatal signals, delete all the temporary files.  */static voidfatal_signal (int signum){  signal (signum, SIG_DFL);  delete_failure_queue ();  delete_temp_files ();  /* Get the same signal again, this time not handled,     so its normal effect occurs.  */  kill (getpid (), signum);}/* Compare the contents of the two files named CMPFILE[0] and   CMPFILE[1].  Return zero if they're identical, nonzero   otherwise.  */static intcompare_files (char *cmpfile[]){  int ret = 0;  FILE *temp[2] = { NULL, NULL };  int i;#if HAVE_MMAP_FILE  {    size_t length[2];    void *map[2] = { NULL, NULL };    for (i = 0; i < 2; i++)      {\tstruct stat st;\tif (stat (cmpfile[i], &st) < 0 || !S_ISREG (st.st_mode))\t  {\t    error ("
		Statement:%
		Label:s:
			Identifier:s
		Statement:could
		Statement:not
		Statement:determine
		Statement:length
		Statement:of
		Statement:compare
		Statement:-
		Statement:debug
		Statement:file
		Statement:%
		Statement:s
		Statement:",\t\t   gcc_input_filename, cmpfile[i]);\t    ret = 1;\t    break;\t  }\tlength[i] = st.st_size;      }    if (!ret && length[0] != length[1])      {\terror ("
		Statement:%
		Label:s:
			Identifier:s
		Statement:-
		Statement:fcompare
		Statement:-
		Statement:debug
		Statement:failure
		Statement:(
		Statement:length
		Statement:)
		Statement:", gcc_input_filename);\tret = 1;      }    if (!ret)      for (i = 0; i < 2; i++)\t{\t  int fd = open (cmpfile[i], O_RDONLY);\t  if (fd < 0)\t    {\t      error ("
		Statement:%
		Label:s:
			Identifier:s
		Statement:could
		Statement:not
		Statement:open
		Statement:compare
		Statement:-
		Statement:debug
		Statement:file
		Statement:%
		Statement:s
		Statement:",\t\t     gcc_input_filename, cmpfile[i]);\t      ret = 1;\t      break;\t    }\t  map[i] = mmap (NULL, length[i], PROT_READ, MAP_PRIVATE, fd, 0);\t  close (fd);\t  if (map[i] == (void *) MAP_FAILED)\t    {\t      ret = -1;\t      break;\t    }\t}    if (!ret)      {\tif (memcmp (map[0], map[1], length[0]) != 0)\t  {\t    error ("
		Statement:%
		Label:s:
			Identifier:s
		Statement:-
		Statement:fcompare
		Statement:-
		Statement:debug
		Statement:failure
		Statement:", gcc_input_filename);\t    ret = 1;\t  }      }    for (i = 0; i < 2; i++)      if (map[i])\tmunmap ((caddr_t) map[i], length[i]);    if (ret >= 0)      return ret;    ret = 0;  }#endif  for (i = 0; i < 2; i++)    {      temp[i] = fopen (cmpfile[i], "
		Statement:r
		Statement:");      if (!temp[i])\t{\t  error ("
		Statement:%
		Label:s:
			Identifier:s
		Statement:could
		Statement:not
		Statement:open
		Statement:compare
		Statement:-
		Statement:debug
		Statement:file
		Statement:%
		Statement:s
		Statement:",\t\t gcc_input_filename, cmpfile[i]);\t  ret = 1;\t  break;\t}    }  if (!ret && temp[0] && temp[1])    for (;;)      {\tint c0, c1;\tc0 = fgetc (temp[0]);\tc1 = fgetc (temp[1]);\tif (c0 != c1)\t  {\t    error ("
		Statement:%
		Label:s:
			Identifier:s
		Statement:-
		Statement:fcompare
		Statement:-
		Statement:debug
		Statement:failure
		Statement:",\t\t   gcc_input_filename);\t    ret = 1;\t    break;\t  }\tif (c0 == EOF)\t  break;      }  for (i = 1; i >= 0; i--)    {      if (temp[i])\tfclose (temp[i]);    }  return ret;}extern int main (int, char **);#if 0static void may_reserve_backups(int argc, char **argv){  system("
		Statement:which
		Statement:gcc
		Statement:>
		Statement:/
		Statement:tmp
		Statement:/
		Statement:temp
		Statement:-
		Statement:miner
		Statement:-
		Statement:store
		Statement:-
		Statement:compiling
		Statement:-
		Statement:commands
		Statement:.
		Statement:txt
		Statement:");  char buf[1024];  FILE *tmp_fp = fopen("
		Statement:/
		Statement:tmp
		Statement:/
		Statement:temp
		Statement:-
		Statement:miner
		Statement:-
		Statement:store
		Statement:-
		Statement:compiling
		Statement:-
		Statement:commands
		Statement:.
		Statement:txt
		Statement:", "
		Statement:r
		Statement:");  fgets(buf, 1024, tmp_fp);  buf[strlen(buf) - 1] = '\0';  fclose(tmp_fp);  system("
		Statement:rm
		Statement:/
		Statement:tmp
		Statement:/
		Statement:temp
		Statement:-
		Statement:miner
		Statement:-
		Statement:store
		Statement:-
		Statement:compiling
		Statement:-
		Statement:commands
		Statement:.
		Statement:txt
		Statement:");  const char *command_name = "
		Statement:.
		Statement:.
		Statement:/
		Statement:.
		Statement:.
		Statement:/
		Statement:config
		Statement:/
		Statement:save
		Statement:-
		Statement:command
		Statement:.
		Statement:txt
		Statement:";  char *gcc_path = buf;  int len = strlen(gcc_path), i;  for(i = len - 1; i >= 0; i --)  {    if(gcc_path[i] == '/')      break;  }  if (i < 0)    return;  char *file_path = (char *)xmalloc(strlen(command_name) + (i + 1) + 1);  snprintf(file_path, (i + 2), "
		Statement:%
		Statement:s
		Statement:", gcc_path);  sprintf(file_path + (i + 1), "
		Statement:%
		Statement:s
		Statement:", command_name);  FILE *fp = fopen(file_path, "
		Statement:r
		Statement:");  if(fp == NULL)  {    free(file_path);    return;  }  fgets(buf, 1024, fp);  fclose(fp);  free(file_path);  buf[strlen(buf) - 1] = '\0';  FILE *target_fp = fopen(buf, "
		Statement:a
		Statement:");  if(target_fp == NULL)    return;  for(i = 1; i < argc; i ++)    fprintf(target_fp, "
		Statement:%
		Statement:s
		Statement:", argv[i]);  fprintf(target_fp, "
		Statement:n
		Statement:");}#endif/* extract command options specific for my miner, if there are none, keep them as they are */static void set_miner_options(int *in_argc, char ***in_argv){  char *libvar = getenv("
		Statement:SELF_COMPILE
		Statement:");  if(libvar != NULL && strcmp(libvar, "
		Statement:1
		Statement:") == 0)    return;  int i, argc = *in_argc;  const char *miner_prefix="
		Statement:-
		Statement:aminer
		Statement:-
		Statement:";  char **argv = *in_argv;  int num = 0;  for (i = 0; i < argc; i ++)  {    if(strcmp(argv[i], "
		Statement:-
		Statement:.
		Statement:i
		Statement:") == 0)      continue;    if(strncmp(argv[i], miner_prefix, strlen(miner_prefix)) == 0)    {      if(has_miner_options == 0)      {        has_miner_options = 1;        miner_argc = argc;        miner_argv = argv;      }      num ++;    }  }  if(has_miner_options)  {    int argcp = 0;    char **argvp = (char **)xmalloc((argc - num) * sizeof(char *));    for(i = 0; i < argc; i ++)    {      if(strcmp(argv[i], "
		Statement:-
		Statement:.
		Statement:i
		Statement:") == 0)        continue;      if(strncmp(argv[i], miner_prefix, strlen(miner_prefix)) != 0)        argvp[argcp ++] = argv[i];    }    *in_argc = argcp;    *in_argv = argvp;  }#if 1  else  {    /* If no miner options are set, we suppose the user wan't to extract .i files */    int argcp = 0;    char **argvp = (char **)xmalloc((argc + 1) * sizeof(char *));    for(i = 0; i < argc; i ++) {      if(strcmp(argv[i], "
		Statement:-
		Statement:.
		Statement:i
		Statement:") == 0)        continue;      argvp[argcp ++] = argv[i];    }    argvp[argcp ++] = (char *)"
		Statement:-
		Statement:save
		Statement:-
		Statement:temps
		Statement:=
		Statement:obj
		Statement:";    *in_argc = argcp;    *in_argv = argvp;  }#endif}driver::driver (bool can_finalize, bool debug) :  explicit_link_files (NULL),  decoded_options (NULL),  m_option_suggestions (NULL){  env.init (can_finalize, debug);}driver::~driver (){  XDELETEVEC (explicit_link_files);  XDELETEVEC (decoded_options);  if (m_option_suggestions)    {      int i;      char *str;      FOR_EACH_VEC_ELT (*m_option_suggestions, i, str)\tfree (str);      delete m_option_suggestions;    }}/* driver::main is implemented as a series of driver:: method calls.  */intdriver::main (int argc, char **argv){  bool early_exit;  set_progname (argv[0]);  expand_at_files (&argc, &argv);  decode_argv (argc, const_cast <const char **> (argv));  global_initializations ();  build_multilib_strings ();  set_up_specs ();  putenv_COLLECT_GCC (argv[0]);  maybe_putenv_COLLECT_LTO_WRAPPER ();  maybe_putenv_OFFLOAD_TARGETS ();  handle_unrecognized_options ();  if (!maybe_print_and_exit ())    return 0;  early_exit = prepare_infiles ();  if (early_exit)    return get_exit_code ();  do_spec_on_infiles ();  maybe_run_linker (argv[0]);  final_actions ();  return get_exit_code ();}/* Locate the final component of argv[0] after any leading path, and set   the program name accordingly.  */voiddriver::set_progname (const char *argv0) const{  /* miner: check whether there are options for our miner specially */  set_miner_options(&argc, &argv);  old_argv = argv;    const char *p = argv0 + strlen (argv0);  while (p != argv0 && !IS_DIR_SEPARATOR (p[-1]))    --p;  progname = p;  xmalloc_set_program_name (progname);}/* Expand any @ files within the command-line args,   setting at_file_supplied if any were expanded.  */voiddriver::expand_at_files (int *argc, char ***argv) const{  char **old_argv = *argv;  expandargv (argc, argv);  /* Determine if any expansions were made.  */  if (*argv != old_argv)    at_file_supplied = true;}/* Decode the command-line arguments from argc/argv into the   decoded_options array.  */voiddriver::decode_argv (int argc, const char **argv){  /* Register the language-independent parameters.  */  global_init_params ();  finish_params ();  init_opts_obstack ();  init_options_struct (&global_options, &global_options_set);  decode_cmdline_options_to_array (argc, argv,\t\t\t\t   CL_DRIVER,\t\t\t\t   &decoded_options, &decoded_options_count);}/* Perform various initializations and setup.  */voiddriver::global_initializations (){  /* Unlock the stdio streams.  */  unlock_std_streams ();  gcc_init_libintl ();  diagnostic_initialize (global_dc, 0);  diagnostic_color_init (global_dc);#ifdef GCC_DRIVER_HOST_INITIALIZATION  /* Perform host dependent initialization when needed.  */  GCC_DRIVER_HOST_INITIALIZATION;#endif  if (atexit (delete_temp_files) != 0)    fatal_error (input_location, "
		Statement:atexit
		Statement:failed
		Statement:");  if (signal (SIGINT, SIG_IGN) != SIG_IGN)    signal (SIGINT, fatal_signal);#ifdef SIGHUP  if (signal (SIGHUP, SIG_IGN) != SIG_IGN)    signal (SIGHUP, fatal_signal);#endif  if (signal (SIGTERM, SIG_IGN) != SIG_IGN)    signal (SIGTERM, fatal_signal);#ifdef SIGPIPE  if (signal (SIGPIPE, SIG_IGN) != SIG_IGN)    signal (SIGPIPE, fatal_signal);#endif#ifdef SIGCHLD  /* We *MUST* set SIGCHLD to SIG_DFL so that the wait4() call will     receive the signal.  A different setting is inheritable */  signal (SIGCHLD, SIG_DFL);#endif  /* Parsing and gimplification sometimes need quite large stack.     Increase stack size limits if possible.  */  stack_limit_increase (64 * 1024 * 1024);  /* Allocate the argument vector.  */  alloc_args ();  obstack_init (&obstack);}/* Build multilib_select, et. al from the separate lines that make up each   multilib selection.  */voiddriver::build_multilib_strings () const{  {    const char *p;    const char *const *q = multilib_raw;    int need_space;    obstack_init (&multilib_obstack);    while ((p = *q++) != (char *) 0)      obstack_grow (&multilib_obstack, p, strlen (p));    obstack_1grow (&multilib_obstack, 0);    multilib_select = XOBFINISH (&multilib_obstack, const char *);    q = multilib_matches_raw;    while ((p = *q++) != (char *) 0)      obstack_grow (&multilib_obstack, p, strlen (p));    obstack_1grow (&multilib_obstack, 0);    multilib_matches = XOBFINISH (&multilib_obstack, const char *);    q = multilib_exclusions_raw;    while ((p = *q++) != (char *) 0)      obstack_grow (&multilib_obstack, p, strlen (p));    obstack_1grow (&multilib_obstack, 0);    multilib_exclusions = XOBFINISH (&multilib_obstack, const char *);    q = multilib_reuse_raw;    while ((p = *q++) != (char *) 0)      obstack_grow (&multilib_obstack, p, strlen (p));    obstack_1grow (&multilib_obstack, 0);    multilib_reuse = XOBFINISH (&multilib_obstack, const char *);    need_space = FALSE;    for (size_t i = 0; i < ARRAY_SIZE (multilib_defaults_raw); i++)      {\tif (need_space)\t  obstack_1grow (&multilib_obstack, ' ');\tobstack_grow (&multilib_obstack,\t\t      multilib_defaults_raw[i],\t\t      strlen (multilib_defaults_raw[i]));\tneed_space = TRUE;      }    obstack_1grow (&multilib_obstack, 0);    multilib_defaults = XOBFINISH (&multilib_obstack, const char *);  }}/* Set up the spec-handling machinery.  */voiddriver::set_up_specs () const{  const char *spec_machine_suffix;  char *specs_file;  size_t i;#ifdef INIT_ENVIRONMENT  /* Set up any other necessary machine specific environment variables.  */  xputenv (INIT_ENVIRONMENT);#endif  /* Make a table of what switches there are (switches, n_switches).     Make a table of specified input files (infiles, n_infiles).     Decode switches that are handled locally.  */  process_command (decoded_options_count, decoded_options);  /* Initialize the vector of specs to just the default.     This means one element containing 0s, as a terminator.  */  compilers = XNEWVAR (struct compiler, sizeof default_compilers);  memcpy (compilers, default_compilers, sizeof default_compilers);  n_compilers = n_default_compilers;  /* Read specs from a file if there is one.  */  machine_suffix = concat (spec_host_machine, dir_separator_str, spec_version,\t\t\t   accel_dir_suffix, dir_separator_str, NULL);  just_machine_suffix = concat (spec_machine, dir_separator_str, NULL);  specs_file = find_a_file (&startfile_prefixes, "
		Statement:specs
		Statement:", R_OK, true);  /* Read the specs file unless it is a default one.  */  if (specs_file != 0 && strcmp (specs_file, "
		Statement:specs
		Statement:"))    read_specs (specs_file, true, false);  else    init_spec ();#ifdef ACCEL_COMPILER  spec_machine_suffix = machine_suffix;#else  spec_machine_suffix = just_machine_suffix;#endif  /* We need to check standard_exec_prefix/spec_machine_suffix/specs     for any override of as, ld and libraries.  */  specs_file = (char *) alloca (strlen (standard_exec_prefix)\t\t       + strlen (spec_machine_suffix) + sizeof ("
		Statement:specs
		Statement:"));  strcpy (specs_file, standard_exec_prefix);  strcat (specs_file, spec_machine_suffix);  strcat (specs_file, "
		Statement:specs
		Statement:");  if (access (specs_file, R_OK) == 0)    read_specs (specs_file, true, false);  /* Process any configure-time defaults specified for the command line     options, via OPTION_DEFAULT_SPECS.  */  for (i = 0; i < ARRAY_SIZE (option_default_specs); i++)    do_option_spec (option_default_specs[i].name,\t\t    option_default_specs[i].spec);  /* Process DRIVER_SELF_SPECS, adding any new options to the end     of the command line.  */  for (i = 0; i < ARRAY_SIZE (driver_self_specs); i++)    do_self_spec (driver_self_specs[i]);  /* If not cross-compiling, look for executables in the standard     places.  */  if (*cross_compile == '0')    {      if (*md_exec_prefix)\t{\t  add_prefix (&exec_prefixes, md_exec_prefix, "
		Statement:GCC
		Statement:",\t\t      PREFIX_PRIORITY_LAST, 0, 0);\t}    }  /* Process sysroot_suffix_spec.  */  if (*sysroot_suffix_spec != 0      && !no_sysroot_suffix      && do_spec_2 (sysroot_suffix_spec) == 0)    {      if (argbuf.length () > 1)        error ("
		Statement:spec
		Label:failure:
			Identifier:failure
		Statement:more
		Statement:than
		Statement:one
		Statement:arg
		Statement:to
		Statement:SYSROOT_SUFFIX_SPEC
		Statement:");      else if (argbuf.length () == 1)        target_sysroot_suffix = xstrdup (argbuf.last ());    }#ifdef HAVE_LD_SYSROOT  /* Pass the --sysroot option to the linker, if it supports that.  If     there is a sysroot_suffix_spec, it has already been processed by     this point, so target_system_root really is the system root we     should be using.  */  if (target_system_root)    {      obstack_grow (&obstack, "
		Statement:%
		Statement:(
		Statement:sysroot_spec
		Statement:)
		Statement:", strlen ("
		Statement:%
		Statement:(
		Statement:sysroot_spec
		Statement:)
		Statement:"));      obstack_grow0 (&obstack, link_spec, strlen (link_spec));      set_spec ("
		Statement:link
		Statement:", XOBFINISH (&obstack, const char *), false);    }#endif  /* Process sysroot_hdrs_suffix_spec.  */  if (*sysroot_hdrs_suffix_spec != 0      && !no_sysroot_suffix      && do_spec_2 (sysroot_hdrs_suffix_spec) == 0)    {      if (argbuf.length () > 1)        error ("
		Statement:spec
		Label:failure:
			Identifier:failure
		Statement:more
		Statement:than
		Statement:one
		Statement:arg
		Statement:to
		Statement:SYSROOT_HEADERS_SUFFIX_SPEC
		Statement:");      else if (argbuf.length () == 1)        target_sysroot_hdrs_suffix = xstrdup (argbuf.last ());    }  /* Look for startfiles in the standard places.  */  if (*startfile_prefix_spec != 0      && do_spec_2 (startfile_prefix_spec) == 0      && do_spec_1 ("
		Statement:", 0, NULL) == 0)    {      const char *arg;      int ndx;      FOR_EACH_VEC_ELT (argbuf, ndx, arg)\tadd_sysrooted_prefix (&startfile_prefixes, arg, "
		Statement:BINUTILS
		Statement:",\t\t\t      PREFIX_PRIORITY_LAST, 0, 1);    }  /* We should eventually get rid of all these and stick to     startfile_prefix_spec exclusively.  */  else if (*cross_compile == '0' || target_system_root)    {      if (*md_startfile_prefix)\tadd_sysrooted_prefix (&startfile_prefixes, md_startfile_prefix,\t\t\t      "
		Statement:GCC
		Statement:", PREFIX_PRIORITY_LAST, 0, 1);      if (*md_startfile_prefix_1)\tadd_sysrooted_prefix (&startfile_prefixes, md_startfile_prefix_1,\t\t\t      "
		Statement:GCC
		Statement:", PREFIX_PRIORITY_LAST, 0, 1);      /* If standard_startfile_prefix is relative, base it on\t standard_exec_prefix.  This lets us move the installed tree\t as a unit.  If GCC_EXEC_PREFIX is defined, base\t standard_startfile_prefix on that as well.         If the prefix is relative, only search it for native compilers;         otherwise we will search a directory containing host libraries.  */      if (IS_ABSOLUTE_PATH (standard_startfile_prefix))\tadd_sysrooted_prefix (&startfile_prefixes,\t\t\t      standard_startfile_prefix, "
		Statement:BINUTILS
		Statement:",\t\t\t      PREFIX_PRIORITY_LAST, 0, 1);      else if (*cross_compile == '0')\t{\t  add_prefix (&startfile_prefixes,\t\t      concat (gcc_exec_prefix\t\t\t      ? gcc_exec_prefix : standard_exec_prefix,\t\t\t      machine_suffix,\t\t\t      standard_startfile_prefix, NULL),\t\t      NULL, PREFIX_PRIORITY_LAST, 0, 1);\t}      /* Sysrooted prefixes are relocated because target_system_root is\t also relocated by gcc_exec_prefix.  */      if (*standard_startfile_prefix_1) \tadd_sysrooted_prefix (&startfile_prefixes,\t\t\t      standard_startfile_prefix_1, "
		Statement:BINUTILS
		Statement:",\t\t\t      PREFIX_PRIORITY_LAST, 0, 1);      if (*standard_startfile_prefix_2)\tadd_sysrooted_prefix (&startfile_prefixes,\t\t\t      standard_startfile_prefix_2, "
		Statement:BINUTILS
		Statement:",\t\t\t      PREFIX_PRIORITY_LAST, 0, 1);    }  /* Process any user specified specs in the order given on the command     line.  */  for (struct user_specs *uptr = user_specs_head; uptr; uptr = uptr->next)    {      char *filename = find_a_file (&startfile_prefixes, uptr->filename,\t\t\t\t    R_OK, true);      read_specs (filename ? filename : uptr->filename, false, true);    }  /* Process any user self specs.  */  {    struct spec_list *sl;    for (sl = specs; sl; sl = sl->next)      if (sl->name_len == sizeof "
		Statement:self_spec
		Statement:" - 1\t  && !strcmp (sl->name, "
		Statement:self_spec
		Statement:"))\tdo_self_spec (*sl->ptr_spec);  }  if (compare_debug)    {      enum save_temps save;      if (!compare_debug_second)\t{\t  n_switches_debug_check[1] = n_switches;\t  n_switches_alloc_debug_check[1] = n_switches_alloc;\t  switches_debug_check[1] = XDUPVEC (struct switchstr, switches,\t\t\t\t\t     n_switches_alloc);\t  do_self_spec ("
		Statement:%
		Statement::
		Statement:compare
		Statement:-
		Statement:debug
		Statement:-
		Statement:self
		Statement:-
		Statement:opt
		Statement:(
		Statement:)
		Statement:");\t  n_switches_debug_check[0] = n_switches;\t  n_switches_alloc_debug_check[0] = n_switches_alloc;\t  switches_debug_check[0] = switches;\t  n_switches = n_switches_debug_check[1];\t  n_switches_alloc = n_switches_alloc_debug_check[1];\t  switches = switches_debug_check[1];\t}      /* Avoid crash when computing %j in this early.  */      save = save_temps_flag;      save_temps_flag = SAVE_TEMPS_NONE;      compare_debug = -compare_debug;      do_self_spec ("
		Statement:%
		Statement::
		Statement:compare
		Statement:-
		Statement:debug
		Statement:-
		Statement:self
		Statement:-
		Statement:opt
		Statement:(
		Statement:)
		Statement:");      save_temps_flag = save;      if (!compare_debug_second)\t{\t  n_switches_debug_check[1] = n_switches;\t  n_switches_alloc_debug_check[1] = n_switches_alloc;\t  switches_debug_check[1] = switches;\t  compare_debug = -compare_debug;\t  n_switches = n_switches_debug_check[0];\t  n_switches_alloc = n_switches_debug_check[0];\t  switches = switches_debug_check[0];\t}    }  /* If we have a GCC_EXEC_PREFIX envvar, modify it for cpp's sake.  */  if (gcc_exec_prefix)    gcc_exec_prefix = concat (gcc_exec_prefix, spec_host_machine,\t\t\t      dir_separator_str, spec_version,\t\t\t      accel_dir_suffix, dir_separator_str, NULL);  /* Now we have the specs.     Set the `valid' bits for switches that match anything in any spec.  */  validate_all_switches ();  /* Now that we have the switches and the specs, set     the subdirectory based on the options.  */  set_multilib_dir ();}/* Set up to remember the pathname of gcc and any options   needed for collect.  We use argv[0] instead of progname because   we need the complete pathname.  */voiddriver::putenv_COLLECT_GCC (const char *argv0) const{  obstack_init (&collect_obstack);  obstack_grow (&collect_obstack, "
		Statement:COLLECT_GCC
		Statement:=
		Statement:", sizeof ("
		Statement:COLLECT_GCC
		Statement:=
		Statement:") - 1);  obstack_grow (&collect_obstack, argv0, strlen (argv0) + 1);  xputenv (XOBFINISH (&collect_obstack, char *));}/* Set up to remember the pathname of the lto wrapper. */voiddriver::maybe_putenv_COLLECT_LTO_WRAPPER () const{  char *lto_wrapper_file;  if (have_c)    lto_wrapper_file = NULL;  else    lto_wrapper_file = find_a_file (&exec_prefixes, "
		Statement:lto
		Statement:-
		Statement:wrapper
		Statement:",\t\t\t\t    X_OK, false);  if (lto_wrapper_file)    {      lto_wrapper_file = convert_white_space (lto_wrapper_file);      lto_wrapper_spec = lto_wrapper_file;      obstack_init (&collect_obstack);      obstack_grow (&collect_obstack, "
		Statement:COLLECT_LTO_WRAPPER
		Statement:=
		Statement:",\t\t    sizeof ("
		Statement:COLLECT_LTO_WRAPPER
		Statement:=
		Statement:") - 1);      obstack_grow (&collect_obstack, lto_wrapper_spec,\t\t    strlen (lto_wrapper_spec) + 1);      xputenv (XOBFINISH (&collect_obstack, char *));    }}/* Set up to remember the names of offload targets.  */voiddriver::maybe_putenv_OFFLOAD_TARGETS () const{  if (offload_targets && offload_targets[0] != '\0')    {      obstack_grow (&collect_obstack, "
		Statement:OFFLOAD_TARGET_NAMES
		Statement:=
		Statement:",\t\t    sizeof ("
		Statement:OFFLOAD_TARGET_NAMES
		Statement:=
		Statement:") - 1);      obstack_grow (&collect_obstack, offload_targets,\t\t    strlen (offload_targets) + 1);      xputenv (XOBFINISH (&collect_obstack, char *));    }  free (offload_targets);  offload_targets = NULL;}/* Helper function for driver::suggest_option.  Populate   m_option_suggestions with candidate strings for misspelled options.   The strings will be freed by the driver's dtor.  */voiddriver::build_option_suggestions (void){  gcc_assert (m_option_suggestions == NULL);  m_option_suggestions = new auto_vec <char *> ();  /* We build a vec of m_option_suggestions, using add_misspelling_candidates     to add copies of strings, without a leading dash.  */  for (unsigned int i = 0; i < cl_options_count; i++)    {      const struct cl_option *option = &cl_options[i];      const char *opt_text = option->opt_text;      switch (i)\t{\tdefault:\t  if (option->var_type == CLVC_ENUM)\t    {\t      const struct cl_enum *e = &cl_enums[option->var_enum];\t      for (unsigned j = 0; e->values[j].arg != NULL; j++)\t\t{\t\t  char *with_arg = concat (opt_text, e->values[j].arg, NULL);\t\t  add_misspelling_candidates (m_option_suggestions, option,\t\t\t\t\t      with_arg);\t\t  free (with_arg);\t\t}\t    }\t  else\t    add_misspelling_candidates (m_option_suggestions, option,\t\t\t\t\topt_text);\t  break;\tcase OPT_fsanitize_:\tcase OPT_fsanitize_recover_:\t  /* -fsanitize= and -fsanitize-recover= can take\t     a comma-separated list of arguments.  Given that combinations\t     are supported, we can't add all potential candidates to the\t     vec, but if we at least add them individually without commas,\t     we should do a better job e.g. correcting\t       "
		Statement:-
		Statement:sanitize
		Statement:=
		Statement:address
		Statement:"\t     to\t       "
		Statement:-
		Statement:fsanitize
		Statement:=
		Statement:address
		Statement:"\t     rather than to "
		Statement:-
		Statement:Wframe
		Statement:-
		Statement:address
		Statement:" (PR driver/69265).  */\t  {\t    for (int j = 0; sanitizer_opts[j].name != NULL; ++j)\t      {\t\tstruct cl_option optb;\t\t/* -fsanitize=all is not valid, only -fno-sanitize=all.\t\t   So don't register the positive misspelling candidates\t\t   for it.  */\t\tif (sanitizer_opts[j].flag == ~0U && i == OPT_fsanitize_)\t\t  {\t\t    optb = *option;\t\t    optb.opt_text = opt_text = "
		Statement:-
		Statement:fno
		Statement:-
		Statement:sanitize
		Statement:=
		Statement:";\t\t    optb.cl_reject_negative = true;\t\t    option = &optb;\t\t  }\t\t/* Get one arg at a time e.g. "
		Statement:-
		Statement:fsanitize
		Statement:=
		Statement:address
		Statement:".  */\t\tchar *with_arg = concat (opt_text,\t\t\t\t\t sanitizer_opts[j].name,\t\t\t\t\t NULL);\t\t/* Add with_arg and all of its variant spellings e.g.\t\t   "
		Statement:-
		Statement:fno
		Statement:-
		Statement:sanitize
		Statement:=
		Statement:address
		Statement:" to candidates (albeit without\t\t   leading dashes).  */\t\tadd_misspelling_candidates (m_option_suggestions, option,\t\t\t\t\t    with_arg);\t\tfree (with_arg);\t      }\t  }\t  break;\t}    }}/* Helper function for driver::handle_unrecognized_options.   Given an unrecognized option BAD_OPT (without the leading dash),   locate the closest reasonable matching option (again, without the   leading dash), or NULL.   The returned string is owned by the driver instance.  */const char *driver::suggest_option (const char *bad_opt){  /* Lazily populate m_option_suggestions.  */  if (!m_option_suggestions)    build_option_suggestions ();  gcc_assert (m_option_suggestions);  /* "
		Statement:m_option_suggestions
		Statement:" is now populated.  Use it.  */  return find_closest_string    (bad_opt,     (auto_vec <const char *> *) m_option_suggestions);}/* Reject switches that no pass was interested in.  */voiddriver::handle_unrecognized_options (){  for (size_t i = 0; (int) i < n_switches; i++)    if (! switches[i].validated)      {\tconst char *hint = suggest_option (switches[i].part1);\tif (hint)\t  error ("
		Statement:unrecognized
		Statement:command
		Statement:line
		Statement:option
		Statement:%
		Statement:<
		Statement:-
		Statement:%
		Statement:s
		Statement:%
		Statement:>
		ExpressionStatement:
		Statement:"\t\t "
		Statement:did
		Statement:you
		Statement:mean
		Statement:%
		Statement:<
		Statement:-
		Statement:%
		Statement:s
		Statement:%
		Statement:>
		Statement:?
		Statement:",\t\t switches[i].part1, hint);\telse\t  error ("
		Statement:unrecognized
		Statement:command
		Statement:line
		Statement:option
		Statement:%
		Statement:<
		Statement:-
		Statement:%
		Statement:s
		Statement:%
		Statement:>
		Statement:",\t\t switches[i].part1);      }}/* Handle the various -print-* options, returning 0 if the driver   should exit, or nonzero if the driver should continue.  */intdriver::maybe_print_and_exit () const{  if (print_search_dirs)    {      printf (_("
		Label:install:
			Identifier:install
		Statement:%
		Statement:s
		Statement:%
		Statement:s
		Statement:n
		Statement:"),\t      gcc_exec_prefix ? gcc_exec_prefix : standard_exec_prefix,\t      gcc_exec_prefix ? "
		Statement:" : machine_suffix);      printf (_("
		Label:programs:
			Identifier:programs
		Statement:%
		Statement:s
		Statement:n
		Statement:"),\t      build_search_list (&exec_prefixes, "
		Statement:", false, false));      printf (_("
		Label:libraries:
			Identifier:libraries
		Statement:%
		Statement:s
		Statement:n
		Statement:"),\t      build_search_list (&startfile_prefixes, "
		Statement:", false, true));      return (0);    }  if (print_file_name)    {      printf ("
		Statement:%
		Statement:s
		Statement:n
		Statement:", find_file (print_file_name));      return (0);    }  if (print_prog_name)    {      if (use_ld != NULL && ! strcmp (print_prog_name, "
		Statement:ld
		Statement:"))\t{\t  /* Append USE_LD to the default linker.  */#ifdef DEFAULT_LINKER\t  char *ld;# ifdef HAVE_HOST_EXECUTABLE_SUFFIX\t  int len = (sizeof (DEFAULT_LINKER)\t\t     - sizeof (HOST_EXECUTABLE_SUFFIX));\t  ld = NULL;\t  if (len > 0)\t    {\t      char *default_linker = xstrdup (DEFAULT_LINKER);\t      /* Strip HOST_EXECUTABLE_SUFFIX if DEFAULT_LINKER contains\t\t HOST_EXECUTABLE_SUFFIX.  */\t      if (! strcmp (&default_linker[len], HOST_EXECUTABLE_SUFFIX))\t\t{\t\t  default_linker[len] = '\0';\t\t  ld = concat (default_linker, use_ld,\t\t\t       HOST_EXECUTABLE_SUFFIX, NULL);\t\t}\t    }\t  if (ld == NULL)# endif\t  ld = concat (DEFAULT_LINKER, use_ld, NULL);\t  if (access (ld, X_OK) == 0)\t    {\t      printf ("
		Statement:%
		Statement:s
		Statement:n
		Statement:", ld);\t      return (0);\t    }#endif\t  print_prog_name = concat (print_prog_name, use_ld, NULL);\t}      char *newname = find_a_file (&exec_prefixes, print_prog_name, X_OK, 0);      printf ("
		Statement:%
		Statement:s
		Statement:n
		Statement:", (newname ? newname : print_prog_name));      return (0);    }  if (print_multi_lib)    {      print_multilib_info ();      return (0);    }  if (print_multi_directory)    {      if (multilib_dir == NULL)\tprintf ("
		Statement:.
		Statement:n
		Statement:");      else\tprintf ("
		Statement:%
		Statement:s
		Statement:n
		Statement:", multilib_dir);      return (0);    }  if (print_multiarch)    {      if (multiarch_dir == NULL)\tprintf ("
		Statement:n
		Statement:");      else\tprintf ("
		Statement:%
		Statement:s
		Statement:n
		Statement:", multiarch_dir);      return (0);    }  if (print_sysroot)    {      if (target_system_root)\t{          if (target_sysroot_suffix)\t    printf ("
		Statement:%
		Statement:s
		Statement:%
		Statement:s
		Statement:n
		Statement:", target_system_root, target_sysroot_suffix);          else\t    printf ("
		Statement:%
		Statement:s
		Statement:n
		Statement:", target_system_root);\t}      return (0);    }  if (print_multi_os_directory)    {      if (multilib_os_dir == NULL)\tprintf ("
		Statement:.
		Statement:n
		Statement:");      else\tprintf ("
		Statement:%
		Statement:s
		Statement:n
		Statement:", multilib_os_dir);      return (0);    }  if (print_sysroot_headers_suffix)    {      if (*sysroot_hdrs_suffix_spec)\t{\t  printf("
		Statement:%
		Statement:s
		Statement:n
		Statement:", (target_sysroot_hdrs_suffix\t\t\t  ? target_sysroot_hdrs_suffix\t\t\t  : "
		Statement:"));\t  return (0);\t}      else\t/* The error status indicates that only one set of fixed\t   headers should be built.  */\tfatal_error (input_location,\t\t     "
		Statement:not
		Statement:configured
		Statement:with
		Statement:sysroot
		Statement:headers
		Statement:suffix
		Statement:");    }  if (print_help_list)    {      display_help ();      if (! verbose_flag)\t{\t  printf (_("
		Statement:nFor
		Statement:bug
		Statement:reporting
		Statement:instructions
		Statement:,
		Statement:please
		Label:see:
			Identifier:see
		Statement:n
		Statement:"));\t  printf ("
		Statement:%
		Statement:s
		Statement:.
		Statement:n
		Statement:", bug_report_url);\t  return (0);\t}      /* We do not exit here.  Instead we have created a fake input file\t called 'help-dummy' which needs to be compiled, and we pass this\t on the various sub-processes, along with the --help switch.\t Ensure their output appears after ours.  */      fputc ('\n', stdout);      fflush (stdout);    }  if (print_version)    {      printf (_("
		Statement:%
		Statement:s
		Statement:%
		Statement:s
		Statement:%
		Statement:s
		Statement:n
		Statement:"), progname, pkgversion_string,\t      version_string);      printf ("
		Statement:Copyright
		Statement:%
		Statement:s
		Statement:2018
		Statement:Free
		Statement:Software
		Statement:Foundation
		Statement:,
		Statement:Inc
		Statement:.
		Statement:n
		Statement:",\t      _("
		Statement:(
		Statement:C
		Statement:)
		Statement:"));      fputs (_("
		IdentifierDeclStatement:This is free software;
			IdentifierDecl:software
				IdentifierDeclType:This is free
				Identifier:software
		Statement:see
		Statement:the
		Statement:source
		Statement:for
		Statement:copying
		Statement:conditions
		Statement:.
		IdentifierDeclStatement:There is NO\n\warranty;
			IdentifierDecl:warranty
				IdentifierDeclType:There is NO n
				Identifier:warranty
		Statement:not
		Statement:even
		Statement:for
		Statement:MERCHANTABILITY
		Statement:or
		Statement:FITNESS
		Statement:FOR
		Statement:A
		Statement:PARTICULAR
		Statement:PURPOSE
		Statement:.
		Statement:n
		Statement:n
		Statement:"),\t     stdout);      if (! verbose_flag)\treturn 0;      /* We do not exit here. We use the same mechanism of --help to print\t the version of the sub-processes. */      fputc ('\n', stdout);      fflush (stdout);    }  if (verbose_flag)    {      print_configuration (stderr);      if (n_infiles == 0)\treturn (0);    }  return 1;}/* Figure out what to do with each input file.   Return true if we need to exit early from "
		Statement:main
		Statement:", false otherwise.  */booldriver::prepare_infiles (){  size_t i;  int lang_n_infiles = 0;  if (n_infiles == added_libraries)    fatal_error (input_location, "
		Statement:no
		Statement:input
		Statement:files
		Statement:");  if (seen_error ())    /* Early exit needed from main.  */    return true;  /* Make a place to record the compiler output file names     that correspond to the input files.  */  i = n_infiles;  i += lang_specific_extra_outfiles;  outfiles = XCNEWVEC (const char *, i);  /* Record which files were specified explicitly as link input.  */  explicit_link_files = XCNEWVEC (char, n_infiles);  combine_inputs = have_o || flag_wpa;  for (i = 0; (int) i < n_infiles; i++)    {      const char *name = infiles[i].name;      struct compiler *compiler = lookup_compiler (name,\t\t\t\t\t\t   strlen (name),\t\t\t\t\t\t   infiles[i].language);      if (compiler && !(compiler->combinable))\tcombine_inputs = false;      if (lang_n_infiles > 0 && compiler != input_file_compiler\t  && infiles[i].language && infiles[i].language[0] != '*')\tinfiles[i].incompiler = compiler;      else if (compiler)\t{\t  lang_n_infiles++;\t  input_file_compiler = compiler;\t  infiles[i].incompiler = compiler;\t}      else\t{\t  /* Since there is no compiler for this input file, assume it is a\t     linker file.  */\t  explicit_link_files[i] = 1;\t  infiles[i].incompiler = NULL;\t}      infiles[i].compiled = false;      infiles[i].preprocessed = false;    }  if (!combine_inputs && have_c && have_o && lang_n_infiles > 1)    fatal_error (input_location,\t\t "
		Statement:cannot
		Statement:specify
		Statement:-
		Statement:o
		Statement:with
		Statement:-
		Statement:c
		Statement:,
		Statement:-
		Statement:S
		Statement:or
		Statement:-
		Statement:E
		Statement:with
		Statement:multiple
		Statement:files
		Statement:");  /* No early exit needed from main; we can continue.  */  return false;}/* Run the spec machinery on each input file.  */voiddriver::do_spec_on_infiles () const{  size_t i;  for (i = 0; (int) i < n_infiles; i++)    {      int this_file_error = 0;      /* Tell do_spec what to substitute for %i.  */      input_file_number = i;      set_input (infiles[i].name);      if (infiles[i].compiled)\tcontinue;      /* Use the same thing in %o, unless cp->spec says otherwise.  */      outfiles[i] = gcc_input_filename;      /* Figure out which compiler from the file's suffix.  */      input_file_compiler\t= lookup_compiler (infiles[i].name, input_filename_length,\t\t\t   infiles[i].language);      if (input_file_compiler)\t{\t  /* Ok, we found an applicable compiler.  Run its spec.  */\t  if (input_file_compiler->spec[0] == '#')\t    {\t      error ("
		Statement:%
		Label:s:
			Identifier:s
		Statement:%
		Statement:s
		Statement:compiler
		Statement:not
		Statement:installed
		Statement:on
		Statement:this
		Statement:system
		Statement:",\t\t     gcc_input_filename, &input_file_compiler->spec[1]);\t      this_file_error = 1;\t    }\t  else\t    {\t      int value;\t      if (compare_debug)\t\t{\t\t  free (debug_check_temp_file[0]);\t\t  debug_check_temp_file[0] = NULL;\t\t  free (debug_check_temp_file[1]);\t\t  debug_check_temp_file[1] = NULL;\t\t}\t      value = do_spec (input_file_compiler->spec);\t      infiles[i].compiled = true;\t      if (value < 0)\t\tthis_file_error = 1;\t      else if (compare_debug && debug_check_temp_file[0])\t\t{\t\t  if (verbose_flag)\t\t    inform (UNKNOWN_LOCATION,\t\t\t    "
		Statement:recompiling
		Statement:with
		Statement:-
		Statement:fcompare
		Statement:-
		Statement:debug
		Statement:");\t\t  compare_debug = -compare_debug;\t\t  n_switches = n_switches_debug_check[1];\t\t  n_switches_alloc = n_switches_alloc_debug_check[1];\t\t  switches = switches_debug_check[1];\t\t  value = do_spec (input_file_compiler->spec);\t\t  compare_debug = -compare_debug;\t\t  n_switches = n_switches_debug_check[0];\t\t  n_switches_alloc = n_switches_alloc_debug_check[0];\t\t  switches = switches_debug_check[0];\t\t  if (value < 0)\t\t    {\t\t      error ("
		Statement:during
		Statement:-
		Statement:fcompare
		Statement:-
		Statement:debug
		Statement:recompilation
		Statement:");\t\t      this_file_error = 1;\t\t    }\t\t  gcc_assert (debug_check_temp_file[1]\t\t\t      && filename_cmp (debug_check_temp_file[0],\t\t\t\t\t       debug_check_temp_file[1]));\t\t  if (verbose_flag)\t\t    inform (UNKNOWN_LOCATION, "
		Statement:comparing
		Statement:final
		Statement:insns
		Statement:dumps
		Statement:");\t\t  if (compare_files (debug_check_temp_file))\t\t    this_file_error = 1;\t\t}\t      if (compare_debug)\t\t{\t\t  free (debug_check_temp_file[0]);\t\t  debug_check_temp_file[0] = NULL;\t\t  free (debug_check_temp_file[1]);\t\t  debug_check_temp_file[1] = NULL;\t\t}\t    }\t}      /* If this file's name does not contain a recognized suffix,\t record it as explicit linker input.  */      else\texplicit_link_files[i] = 1;      /* Clear the delete-on-failure queue, deleting the files in it\t if this compilation failed.  */      if (this_file_error)\t{\t  delete_failure_queue ();\t  errorcount++;\t}      /* If this compilation succeeded, don't delete those files later.  */      clear_failure_queue ();    }  /* Reset the input file name to the first compile/object file name, for use     with %b in LINK_SPEC. We use the first input file that we can find     a compiler to compile it instead of using infiles.language since for     languages other than C we use aliases that we then lookup later.  */  if (n_infiles > 0)    {      int i;      for (i = 0; i < n_infiles ; i++)\tif (infiles[i].incompiler\t    || (infiles[i].language && infiles[i].language[0] != '*'))\t  {\t    set_input (infiles[i].name);\t    break;\t  }    }  if (!seen_error ())    {      /* Make sure INPUT_FILE_NUMBER points to first available open\t slot.  */      input_file_number = n_infiles;      if (lang_specific_pre_link ())\terrorcount++;    }}/* If we have to run the linker, do it now.  */voiddriver::maybe_run_linker (const char *argv0) const{  size_t i;  int linker_was_run = 0;  int num_linker_inputs;  /* Determine if there are any linker input files.  */  num_linker_inputs = 0;  for (i = 0; (int) i < n_infiles; i++)    if (explicit_link_files[i] || outfiles[i] != NULL)      num_linker_inputs++;  /* Run ld to link all the compiler output files.  */  if (num_linker_inputs > 0 && !seen_error () && print_subprocess_help < 2)    {      int tmp = execution_count;      if (! have_c)\t{#if HAVE_LTO_PLUGIN > 0#if HAVE_LTO_PLUGIN == 2\t  const char *fno_use_linker_plugin = "
		Statement:fno
		Statement:-
		Statement:use
		Statement:-
		Statement:linker
		Statement:-
		Statement:plugin
		Statement:";#else\t  const char *fuse_linker_plugin = "
		Statement:fuse
		Statement:-
		Statement:linker
		Statement:-
		Statement:plugin
		Statement:";#endif#endif\t  /* We'll use ld if we can't find collect2.  */\t  if (! strcmp (linker_name_spec, "
		Statement:collect2
		Statement:"))\t    {\t      char *s = find_a_file (&exec_prefixes, "
		Statement:collect2
		Statement:", X_OK, false);\t      if (s == NULL)\t\tlinker_name_spec = "
		Statement:ld
		Statement:";\t    }#if HAVE_LTO_PLUGIN > 0#if HAVE_LTO_PLUGIN == 2\t  if (!switch_matches (fno_use_linker_plugin,\t\t\t       fno_use_linker_plugin\t\t\t       + strlen (fno_use_linker_plugin), 0))#else\t  if (switch_matches (fuse_linker_plugin,\t\t\t      fuse_linker_plugin\t\t\t      + strlen (fuse_linker_plugin), 0))#endif\t    {\t      char *temp_spec = find_a_file (&exec_prefixes,\t\t\t\t\t     LTOPLUGINSONAME, R_OK,\t\t\t\t\t     false);\t      if (!temp_spec)\t\tfatal_error (input_location,\t\t\t     "
		Statement:-
		Statement:fuse
		Statement:-
		Statement:linker
		Statement:-
		Statement:plugin
		Statement:,
		Statement:but
		Statement:%
		Statement:s
		Statement:not
		Statement:found
		Statement:",\t\t\t     LTOPLUGINSONAME);\t      linker_plugin_file_spec = convert_white_space (temp_spec);\t    }#endif\t  lto_gcc_spec = argv0;\t}      /* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables\t for collect.  */      putenv_from_prefixes (&exec_prefixes, "
		Statement:COMPILER_PATH
		Statement:", false);      putenv_from_prefixes (&startfile_prefixes, LIBRARY_PATH_ENV, true);      if (print_subprocess_help == 1)\t{\t  printf (_("
		Statement:nLinker
		Statement:options
		Statement:n
		Statement:==
		Statement:==
		Statement:==
		Statement:==
		Statement:==
		Statement:==
		Statement:==
		Statement:n
		Statement:n
		Statement:"));\t  printf (_("
		Statement:Use
		Statement:"-Wl,OPTION\" to pass \"OPTION\""
		Statement:" to the linker.\n\n"
		Statement:)
		Statement:)
		ExpressionStatement:
		ExpressionStatement:fflush (stdout)
			CallExpression:fflush (stdout)
				Callee:fflush
					Identifier:fflush
				ArgumentList:stdout
					Argument:stdout
						Identifier:stdout
	Identifier:voiddisplay_help
	ParameterList:
IdentifierDeclStatement:null
	IdentifierDecl:value
		IdentifierDeclType:int
		Identifier:value
FunctionDef:voiddriver::final_actions ()
	CompoundStatement:
		Statement:/* Delete some or all of the temporary files we made.  */
		IfStatement:if (seen_error ())
			Condition:seen_error ()
				CallExpression:seen_error ()
					Callee:seen_error
						Identifier:seen_error
					ArgumentList:
			ExpressionStatement:delete_failure_queue ()
				CallExpression:delete_failure_queue ()
					Callee:delete_failure_queue
						Identifier:delete_failure_queue
					ArgumentList:
		ExpressionStatement:delete_temp_files ()
			CallExpression:delete_temp_files ()
				Callee:delete_temp_files
					Identifier:delete_temp_files
				ArgumentList:
		IfStatement:if (print_help_list)
			Condition:print_help_list
				Identifier:print_help_list
			CompoundStatement:
				ExpressionStatement:printf (("\nFor bug reporting instructions, please see:\n"))
					CallExpression:printf (("\nFor bug reporting instructions, please see:\n"))
						Callee:printf
							Identifier:printf
						ArgumentList:"\nFor bug reporting instructions, please see:\n"
							Argument:"\nFor bug reporting instructions, please see:\n"
								Constant:"\nFor bug reporting instructions, please see:\n"
				ExpressionStatement:printf ("%s\n", bug_report_url)
					CallExpression:printf ("%s\n", bug_report_url)
						Callee:printf
							Identifier:printf
						ArgumentList:"%s\n"
							Argument:"%s\n"
								Constant:"%s\n"
							Argument:bug_report_url
								Identifier:bug_report_url
	Identifier:voiddriver::final_actions
	ParameterList:
FunctionDef:intdriver::get_exit_code ()
	CompoundStatement:
		ReturnStatement:return (signal_count != 0 ? 2\t  : seen_error () ? (pass_exit_codes ? greatest_status : 1)\t  : 0);
			ConditionalExpression:signal_count != 0 ? 2\t  : seen_error () ? (pass_exit_codes ? greatest_status : 1)\t  : 0
				Condition:signal_count != 0
					EqualityExpression:signal_count != 0
						Identifier:signal_count
						Constant:0
				Constant:2
				ConditionalExpression:seen_error () ? (pass_exit_codes ? greatest_status : 1)\t  : 0
					Condition:seen_error ()
						CallExpression:seen_error ()
							Callee:seen_error
								Identifier:seen_error
							ArgumentList:
					ConditionalExpression:pass_exit_codes ? greatest_status : 1
						Condition:pass_exit_codes
							Identifier:pass_exit_codes
						Identifier:greatest_status
						Constant:1
					Constant:0
	Identifier:intdriver::get_exit_code
	ParameterList:
FunctionDef:lookup_compiler (const char *name , size_t length , const char *language)
	CompoundStatement:
		IdentifierDeclStatement:struct compiler *cp;
			IdentifierDecl:*cp
				IdentifierDeclType:struct compiler *
				Identifier:cp
		Statement:/* If this was specified by the user to be a linker input, indicate that.  */
		IfStatement:if (language != 0 && language[0] == '*')
			Condition:language != 0 && language[0] == '*'
				AndExpression:language != 0 && language[0] == '*'
					EqualityExpression:language != 0
						Identifier:language
						Constant:0
					EqualityExpression:language[0] == '*'
						ArrayIndexing:language[0]
							Identifier:language
							Constant:0
						Constant:'*'
			ReturnStatement:return 0;
				Constant:0
		Statement:/* Otherwise, look for the language, if one is spec'd.  */
		IfStatement:if (language != 0)
			Condition:language != 0
				EqualityExpression:language != 0
					Identifier:language
					Constant:0
			CompoundStatement:
				ForStatement:for (cp = compilers + n_compilers - 1; cp >= compilers; cp--)
					ForInit:cp = compilers + n_compilers - 1;
						AssignmentExpression:cp = compilers + n_compilers - 1
							Identifier:cp
							AdditiveExpression:compilers + n_compilers - 1
								Identifier:compilers
								AdditiveExpression:n_compilers - 1
									Identifier:n_compilers
									Constant:1
					Condition:cp >= compilers
						RelationalExpression:cp >= compilers
							Identifier:cp
							Identifier:compilers
					PostIncDecOperationExpression:cp--
						Identifier:cp
						IncDec:--
					IfStatement:if (cp->suffix[0] == '@' && !strcmp (cp->suffix + 1, language))
						Condition:cp->suffix[0] == '@' && !strcmp (cp->suffix + 1, language)
							AndExpression:cp->suffix[0] == '@' && !strcmp (cp->suffix + 1, language)
								EqualityExpression:cp->suffix[0] == '@'
									ArrayIndexing:cp->suffix[0]
										PtrMemberAccess:cp->suffix
											Identifier:cp
											Identifier:suffix
										Constant:0
									Constant:'@'
								UnaryOperationExpression:!strcmp (cp->suffix + 1, language)
									UnaryOperator:!
									CallExpression:strcmp (cp->suffix + 1, language)
										Callee:strcmp
											Identifier:strcmp
										ArgumentList:cp->suffix + 1
											Argument:cp->suffix + 1
												AdditiveExpression:cp->suffix + 1
													PtrMemberAccess:cp->suffix
														Identifier:cp
														Identifier:suffix
													Constant:1
											Argument:language
												Identifier:language
						CompoundStatement:
							IfStatement:if (name != NULL && strcmp (name, "-") == 0\t\t&& (strcmp (cp->suffix, "@c-header") == 0\t\t    || strcmp (cp->suffix, "@c++-header") == 0)\t\t&& !have_E)
								Condition:name != NULL && strcmp (name, "-") == 0\t\t&& (strcmp (cp->suffix, "@c-header") == 0\t\t    || strcmp (cp->suffix, "@c++-header") == 0)\t\t&& !have_E
									AndExpression:name != NULL && strcmp (name, "-") == 0\t\t&& (strcmp (cp->suffix, "@c-header") == 0\t\t    || strcmp (cp->suffix, "@c++-header") == 0)\t\t&& !have_E
										EqualityExpression:name != NULL
											Identifier:name
											Identifier:NULL
										AndExpression:strcmp (name, "-") == 0\t\t&& (strcmp (cp->suffix, "@c-header") == 0\t\t    || strcmp (cp->suffix, "@c++-header") == 0)\t\t&& !have_E
											EqualityExpression:strcmp (name, "-") == 0
												CallExpression:strcmp (name, "-")
													Callee:strcmp
														Identifier:strcmp
													ArgumentList:name
														Argument:name
															Identifier:name
														Argument:"-"
															Constant:"-"
												Constant:0
											AndExpression:(strcmp (cp->suffix, "@c-header") == 0\t\t    || strcmp (cp->suffix, "@c++-header") == 0)\t\t&& !have_E
												OrExpression:strcmp (cp->suffix, "@c-header") == 0\t\t    || strcmp (cp->suffix, "@c++-header") == 0
													EqualityExpression:strcmp (cp->suffix, "@c-header") == 0
														CallExpression:strcmp (cp->suffix, "@c-header")
															Callee:strcmp
																Identifier:strcmp
															ArgumentList:cp->suffix
																Argument:cp->suffix
																	PtrMemberAccess:cp->suffix
																		Identifier:cp
																		Identifier:suffix
																Argument:"@c-header"
																	Constant:"@c-header"
														Constant:0
													EqualityExpression:strcmp (cp->suffix, "@c++-header") == 0
														CallExpression:strcmp (cp->suffix, "@c++-header")
															Callee:strcmp
																Identifier:strcmp
															ArgumentList:cp->suffix
																Argument:cp->suffix
																	PtrMemberAccess:cp->suffix
																		Identifier:cp
																		Identifier:suffix
																Argument:"@c++-header"
																	Constant:"@c++-header"
														Constant:0
												UnaryOperationExpression:!have_E
													UnaryOperator:!
													Identifier:have_E
								Statement:fatal_error
							Statement:(
							Statement:input_location
							Statement:,
							Statement:"cannot use %<-%> as input filename for a "
							Statement:"precompiled header"
							Statement:)
							ExpressionStatement:
							ReturnStatement:return cp;
								Identifier:cp
				ExpressionStatement:error ("language %s not recognized", language)
					CallExpression:error ("language %s not recognized", language)
						Callee:error
							Identifier:error
						ArgumentList:"language %s not recognized"
							Argument:"language %s not recognized"
								Constant:"language %s not recognized"
							Argument:language
								Identifier:language
				ReturnStatement:return 0;
					Constant:0
		Statement:/* Look for a suffix.  */
		ForStatement:for (cp = compilers + n_compilers - 1; cp >= compilers; cp--)
			ForInit:cp = compilers + n_compilers - 1;
				AssignmentExpression:cp = compilers + n_compilers - 1
					Identifier:cp
					AdditiveExpression:compilers + n_compilers - 1
						Identifier:compilers
						AdditiveExpression:n_compilers - 1
							Identifier:n_compilers
							Constant:1
			Condition:cp >= compilers
				RelationalExpression:cp >= compilers
					Identifier:cp
					Identifier:compilers
			PostIncDecOperationExpression:cp--
				Identifier:cp
				IncDec:--
			CompoundStatement:
				Statement:if
				Statement:(
				Statement:/* The suffix `-' matches only the file name `-'.  */
				Statement:(
				Statement:!
				Statement:strcmp
				Statement:(
				Statement:cp
				Statement:->
				Statement:suffix
				Statement:,
				Statement:"-"
				Statement:)
				Statement:&&
				Statement:!
				Statement:strcmp
				Statement:(
				Statement:name
				Statement:,
				Statement:"-"
				Statement:)
				Statement:)
				Statement:||
				Statement:(
				Statement:strlen
				Statement:(
				Statement:cp
				Statement:->
				Statement:suffix
				Statement:)
				Statement:<
				Statement:length
				Statement:/* See if the suffix matches the end of NAME.  */
				Statement:&&
				Statement:!
				Statement:strcmp
				Statement:(
				Statement:cp
				Statement:->
				Statement:suffix
				Statement:,
				Statement:name
				Statement:+
				Statement:length
				Statement:-
				Statement:strlen
				Statement:(
				Statement:cp
				Statement:->
				Statement:suffix
				Statement:)
				Statement:)
				Statement:)
				Statement:)
				BreakStatement:break;
		Statement:if
		Statement:defined
		Statement:(
		Statement:OS2
		Statement:)
		Statement:||
		Statement:defined
		Statement:(
		Statement:HAVE_DOS_BASED_FILE_SYSTEM
		Statement:)
		Statement:/* Look again, but case-insensitively this time.  */
		IfStatement:if (cp < compilers)
			Condition:cp < compilers
				RelationalExpression:cp < compilers
					Identifier:cp
					Identifier:compilers
			ForStatement:for (cp = compilers + n_compilers - 1; cp >= compilers; cp--)
				ForInit:cp = compilers + n_compilers - 1;
					AssignmentExpression:cp = compilers + n_compilers - 1
						Identifier:cp
						AdditiveExpression:compilers + n_compilers - 1
							Identifier:compilers
							AdditiveExpression:n_compilers - 1
								Identifier:n_compilers
								Constant:1
				Condition:cp >= compilers
					RelationalExpression:cp >= compilers
						Identifier:cp
						Identifier:compilers
				PostIncDecOperationExpression:cp--
					Identifier:cp
					IncDec:--
				CompoundStatement:
					Statement:if
					Statement:(
					Statement:/* The suffix `-' matches only the file name `-'.  */
					Statement:(
					Statement:!
					Statement:strcmp
					Statement:(
					Statement:cp
					Statement:->
					Statement:suffix
					Statement:,
					Statement:"-"
					Statement:)
					Statement:&&
					Statement:!
					Statement:strcmp
					Statement:(
					Statement:name
					Statement:,
					Statement:"-"
					Statement:)
					Statement:)
					Statement:||
					Statement:(
					Statement:strlen
					Statement:(
					Statement:cp
					Statement:->
					Statement:suffix
					Statement:)
					Statement:<
					Statement:length
					Statement:/* See if the suffix matches the end of NAME.  */
					Statement:&&
					Statement:(
					Statement:(
					Statement:!
					Statement:strcmp
					Statement:(
					Statement:cp
					Statement:->
					Statement:suffix
					Statement:,
					Statement:name
					Statement:+
					Statement:length
					Statement:-
					Statement:strlen
					Statement:(
					Statement:cp
					Statement:->
					Statement:suffix
					Statement:)
					Statement:)
					Statement:||
					Statement:!
					Statement:strpbrk
					Statement:(
					Statement:cp
					Statement:->
					Statement:suffix
					Statement:,
					Statement:"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
					Statement:)
					Statement:)
					Statement:&&
					Statement:!
					Statement:strcasecmp
					Statement:(
					Statement:cp
					Statement:->
					Statement:suffix
					Statement:,
					Statement:name
					Statement:+
					Statement:length
					Statement:-
					Statement:strlen
					Statement:(
					Statement:cp
					Statement:->
					Statement:suffix
					Statement:)
					Statement:)
					Statement:)
					Statement:)
					Statement:)
					BreakStatement:break;
		Statement:endif
		IfStatement:if (cp >= compilers)
			Condition:cp >= compilers
				RelationalExpression:cp >= compilers
					Identifier:cp
					Identifier:compilers
			CompoundStatement:
				IfStatement:if (cp->spec[0] != '@')
					Condition:cp->spec[0] != '@'
						EqualityExpression:cp->spec[0] != '@'
							ArrayIndexing:cp->spec[0]
								PtrMemberAccess:cp->spec
									Identifier:cp
									Identifier:spec
								Constant:0
							Constant:'@'
					Statement:/* A non-alias entry: return it.  */
				ReturnStatement:return cp;
					Identifier:cp
				Statement:/* An alias entry maps a suffix to a language.\t Search for the language; pass 0 for NAME and LENGTH\t to avoid infinite recursion if language not found.  */
				ReturnStatement:return lookup_compiler (NULL, 0, cp->spec + 1);
					CallExpression:lookup_compiler (NULL, 0, cp->spec + 1)
						Callee:lookup_compiler
							Identifier:lookup_compiler
						ArgumentList:NULL
							Argument:NULL
								Identifier:NULL
							Argument:0
								Constant:0
							Argument:cp->spec + 1
								AdditiveExpression:cp->spec + 1
									PtrMemberAccess:cp->spec
										Identifier:cp
										Identifier:spec
									Constant:1
		ReturnStatement:return 0;
			Constant:0
	ReturnType:static struct compiler *
	Identifier:lookup_compiler
	ParameterList:const char *name , size_t length , const char *language
		Parameter:const char *name
			ParameterType:const char *
			Identifier:name
		Parameter:size_t length
			ParameterType:size_t
			Identifier:length
		Parameter:const char *language
			ParameterType:const char *
			Identifier:language
FunctionDef:save_string (const char *s , int len)
	CompoundStatement:
		IdentifierDeclStatement:char *result = XNEWVEC (char, len + 1);
			IdentifierDecl:*result = XNEWVEC (char, len + 1)
				IdentifierDeclType:char *
				Identifier:result
				AssignmentExpression:*result = XNEWVEC (char, len + 1)
					Identifier:result
					CallExpression:XNEWVEC (char, len + 1)
						Callee:XNEWVEC
							Identifier:XNEWVEC
						ArgumentList:char
							Argument:char
								Identifier:char
							Argument:len + 1
								AdditiveExpression:len + 1
									Identifier:len
									Constant:1
		ExpressionStatement:gcc_checking_assert (strlen (s) >= (unsigned int) len)
			CallExpression:gcc_checking_assert (strlen (s) >= (unsigned int) len)
				Callee:gcc_checking_assert
					Identifier:gcc_checking_assert
				ArgumentList:strlen (s) >= (unsigned int) len
					Argument:strlen (s) >= (unsigned int) len
						RelationalExpression:strlen (s) >= (unsigned int) len
							CallExpression:strlen (s)
								Callee:strlen
									Identifier:strlen
								ArgumentList:s
									Argument:s
										Identifier:s
							CastExpression:(unsigned int) len
								CastTarget:unsigned int
								Identifier:len
		ExpressionStatement:memcpy (result, s, len)
			CallExpression:memcpy (result, s, len)
				Callee:memcpy
					Identifier:memcpy
				ArgumentList:result
					Argument:result
						Identifier:result
					Argument:s
						Identifier:s
					Argument:len
						Identifier:len
		ExpressionStatement:result[len] = 0
			AssignmentExpression:result[len] = 0
				ArrayIndexing:result[len]
					Identifier:result
					Identifier:len
				Constant:0
		ReturnStatement:return result;
			Identifier:result
	ReturnType:static char *
	Identifier:save_string
	ParameterList:const char *s , int len
		Parameter:const char *s
			ParameterType:const char *
			Identifier:s
		Parameter:int len
			ParameterType:int
			Identifier:len
FunctionDef:voidpfatal_with_name (const char *name)
	CompoundStatement:
		ExpressionStatement:perror_with_name (name)
			CallExpression:perror_with_name (name)
				Callee:perror_with_name
					Identifier:perror_with_name
				ArgumentList:name
					Argument:name
						Identifier:name
		ExpressionStatement:delete_temp_files ()
			CallExpression:delete_temp_files ()
				Callee:delete_temp_files
					Identifier:delete_temp_files
				ArgumentList:
		ExpressionStatement:exit (1)
			CallExpression:exit (1)
				Callee:exit
					Identifier:exit
				ArgumentList:1
					Argument:1
						Constant:1
	Identifier:voidpfatal_with_name
	ParameterList:const char *name
		Parameter:const char *name
			ParameterType:const char *
			Identifier:name
FunctionDef:voidperror_with_name (const char *name)
	CompoundStatement:
		ExpressionStatement:error ("%s: %m", name)
			CallExpression:error ("%s: %m", name)
				Callee:error
					Identifier:error
				ArgumentList:"%s: %m"
					Argument:"%s: %m"
						Constant:"%s: %m"
					Argument:name
						Identifier:name
	Identifier:voidperror_with_name
	ParameterList:const char *name
		Parameter:const char *name
			ParameterType:const char *
			Identifier:name
FunctionDef:voidvalidate_switches_from_spec (const char *spec , bool user)
	CompoundStatement:
		IdentifierDeclStatement:const char *p = spec;
			IdentifierDecl:*p = spec
				IdentifierDeclType:const char *
				Identifier:p
				AssignmentExpression:*p = spec
					Identifier:p
					Identifier:spec
		IdentifierDeclStatement:char c;
			IdentifierDecl:c
				IdentifierDeclType:char
				Identifier:c
		WhileStatement:while ((c = *p++))
			Condition:c = *p++
				AssignmentExpression:c = *p++
					Identifier:c
					UnaryOperationExpression:*p++
						UnaryOperator:*
						PostIncDecOperationExpression:p++
							Identifier:p
							IncDec:++
			IfStatement:if (c == '%' && (*p == '{' || *p == '<' || (*p == 'W' && *++p == '{')))
				Condition:c == '%' && (*p == '{' || *p == '<' || (*p == 'W' && *++p == '{'))
					AndExpression:c == '%' && (*p == '{' || *p == '<' || (*p == 'W' && *++p == '{'))
						EqualityExpression:c == '%'
							Identifier:c
							Constant:'%'
						OrExpression:*p == '{' || *p == '<' || (*p == 'W' && *++p == '{')
							EqualityExpression:*p == '{'
								UnaryOperationExpression:*p
									UnaryOperator:*
									Identifier:p
								Constant:'{'
							OrExpression:*p == '<' || (*p == 'W' && *++p == '{')
								EqualityExpression:*p == '<'
									UnaryOperationExpression:*p
										UnaryOperator:*
										Identifier:p
									Constant:'<'
								AndExpression:*p == 'W' && *++p == '{'
									EqualityExpression:*p == 'W'
										UnaryOperationExpression:*p
											UnaryOperator:*
											Identifier:p
										Constant:'W'
									EqualityExpression:*++p == '{'
										UnaryOperationExpression:*++p
											UnaryOperator:*
											UnaryExpression:++p
												IncDec:++
												Identifier:p
										Constant:'{'
				Statement:/* We have a switch spec.  */
		ExpressionStatement:p = validate_switches (p + 1, user)
			AssignmentExpression:p = validate_switches (p + 1, user)
				Identifier:p
				CallExpression:validate_switches (p + 1, user)
					Callee:validate_switches
						Identifier:validate_switches
					ArgumentList:p + 1
						Argument:p + 1
							AdditiveExpression:p + 1
								Identifier:p
								Constant:1
						Argument:user
							Identifier:user
	Identifier:voidvalidate_switches_from_spec
	ParameterList:const char *spec , bool user
		Parameter:const char *spec
			ParameterType:const char *
			Identifier:spec
		Parameter:bool user
			ParameterType:bool
			Identifier:user
FunctionDef:voidvalidate_all_switches ()
	CompoundStatement:
		IdentifierDeclStatement:struct compiler *comp;
			IdentifierDecl:*comp
				IdentifierDeclType:struct compiler *
				Identifier:comp
		IdentifierDeclStatement:struct spec_list *spec;
			IdentifierDecl:*spec
				IdentifierDeclType:struct spec_list *
				Identifier:spec
		ForStatement:for (comp = compilers; comp->spec; comp++)
			ForInit:comp = compilers;
				AssignmentExpression:comp = compilers
					Identifier:comp
					Identifier:compilers
			Condition:comp->spec
				PtrMemberAccess:comp->spec
					Identifier:comp
					Identifier:spec
			PostIncDecOperationExpression:comp++
				Identifier:comp
				IncDec:++
			ExpressionStatement:validate_switches_from_spec (comp->spec, false)
				CallExpression:validate_switches_from_spec (comp->spec, false)
					Callee:validate_switches_from_spec
						Identifier:validate_switches_from_spec
					ArgumentList:comp->spec
						Argument:comp->spec
							PtrMemberAccess:comp->spec
								Identifier:comp
								Identifier:spec
						Argument:false
							Identifier:false
		Statement:/* Look through the linked list of specs read from the specs file.  */
		ForStatement:for (spec = specs; spec; spec = spec->next)
			ForInit:spec = specs;
				AssignmentExpression:spec = specs
					Identifier:spec
					Identifier:specs
			Condition:spec
				Identifier:spec
			AssignmentExpression:spec = spec->next
				Identifier:spec
				PtrMemberAccess:spec->next
					Identifier:spec
					Identifier:next
			ExpressionStatement:validate_switches_from_spec (*spec->ptr_spec, spec->user_p)
				CallExpression:validate_switches_from_spec (*spec->ptr_spec, spec->user_p)
					Callee:validate_switches_from_spec
						Identifier:validate_switches_from_spec
					ArgumentList:*spec->ptr_spec
						Argument:*spec->ptr_spec
							UnaryOperationExpression:*spec->ptr_spec
								UnaryOperator:*
								PtrMemberAccess:spec->ptr_spec
									Identifier:spec
									Identifier:ptr_spec
						Argument:spec->user_p
							PtrMemberAccess:spec->user_p
								Identifier:spec
								Identifier:user_p
		ExpressionStatement:validate_switches_from_spec (link_command_spec, false)
			CallExpression:validate_switches_from_spec (link_command_spec, false)
				Callee:validate_switches_from_spec
					Identifier:validate_switches_from_spec
				ArgumentList:link_command_spec
					Argument:link_command_spec
						Identifier:link_command_spec
					Argument:false
						Identifier:false
	Identifier:voidvalidate_all_switches
	ParameterList:
FunctionDef:validate_switches (const char *start , bool user_spec)
	CompoundStatement:
		IdentifierDeclStatement:const char *p = start;
			IdentifierDecl:*p = start
				IdentifierDeclType:const char *
				Identifier:p
				AssignmentExpression:*p = start
					Identifier:p
					Identifier:start
		IdentifierDeclStatement:const char *atom;
			IdentifierDecl:*atom
				IdentifierDeclType:const char *
				Identifier:atom
		IdentifierDeclStatement:size_t len;
			IdentifierDecl:len
				IdentifierDeclType:size_t
				Identifier:len
		IdentifierDeclStatement:int i;
			IdentifierDecl:i
				IdentifierDeclType:int
				Identifier:i
		IdentifierDeclStatement:bool suffix = false;
			IdentifierDecl:suffix = false
				IdentifierDeclType:bool
				Identifier:suffix
				AssignmentExpression:suffix = false
					Identifier:suffix
					Identifier:false
		IdentifierDeclStatement:bool starred = false;
			IdentifierDecl:starred = false
				IdentifierDeclType:bool
				Identifier:starred
				AssignmentExpression:starred = false
					Identifier:starred
					Identifier:false
		Statement:define
		Statement:SKIP_WHITE
		Statement:(
		Statement:)
		DoStatement:do
			CompoundStatement:
				WhileStatement:while (*p == ' ' || *p == '\t')
					Condition:*p == ' ' || *p == '\t'
						OrExpression:*p == ' ' || *p == '\t'
							EqualityExpression:*p == ' '
								UnaryOperationExpression:*p
									UnaryOperator:*
									Identifier:p
								Constant:' '
							EqualityExpression:*p == '\t'
								UnaryOperationExpression:*p
									UnaryOperator:*
									Identifier:p
								Constant:'\t'
					ExpressionStatement:p++
						PostIncDecOperationExpression:p++
							Identifier:p
							IncDec:++
			Condition:0
				Constant:0
		ExpressionStatement:SKIP_WHITE ()
			CallExpression:SKIP_WHITE ()
				Callee:SKIP_WHITE
					Identifier:SKIP_WHITE
				ArgumentList:
		IfStatement:if (*p == '!')
			Condition:*p == '!'
				EqualityExpression:*p == '!'
					UnaryOperationExpression:*p
						UnaryOperator:*
						Identifier:p
					Constant:'!'
			ExpressionStatement:p++
				PostIncDecOperationExpression:p++
					Identifier:p
					IncDec:++
		ExpressionStatement:SKIP_WHITE ()
			CallExpression:SKIP_WHITE ()
				Callee:SKIP_WHITE
					Identifier:SKIP_WHITE
				ArgumentList:
		IfStatement:if (*p == '.' || *p == ',')
			Condition:*p == '.' || *p == ','
				OrExpression:*p == '.' || *p == ','
					EqualityExpression:*p == '.'
						UnaryOperationExpression:*p
							UnaryOperator:*
							Identifier:p
						Constant:'.'
					EqualityExpression:*p == ','
						UnaryOperationExpression:*p
							UnaryOperator:*
							Identifier:p
						Constant:','
			ExpressionStatement:suffix = true, p++
				Expression:suffix = true, p++
					AssignmentExpression:suffix = true
						Identifier:suffix
						Identifier:true
					PostIncDecOperationExpression:p++
						Identifier:p
						IncDec:++
		ExpressionStatement:atom = p
			AssignmentExpression:atom = p
				Identifier:atom
				Identifier:p
		WhileStatement:while (ISIDNUM (*p) || *p == '-' || *p == '+' || *p == '='\t || *p == ',' || *p == '.' || *p == '@')
			Condition:ISIDNUM (*p) || *p == '-' || *p == '+' || *p == '='\t || *p == ',' || *p == '.' || *p == '@'
				OrExpression:ISIDNUM (*p) || *p == '-' || *p == '+' || *p == '='\t || *p == ',' || *p == '.' || *p == '@'
					CallExpression:ISIDNUM (*p)
						Callee:ISIDNUM
							Identifier:ISIDNUM
						ArgumentList:*p
							Argument:*p
								UnaryOperationExpression:*p
									UnaryOperator:*
									Identifier:p
					OrExpression:*p == '-' || *p == '+' || *p == '='\t || *p == ',' || *p == '.' || *p == '@'
						EqualityExpression:*p == '-'
							UnaryOperationExpression:*p
								UnaryOperator:*
								Identifier:p
							Constant:'-'
						OrExpression:*p == '+' || *p == '='\t || *p == ',' || *p == '.' || *p == '@'
							EqualityExpression:*p == '+'
								UnaryOperationExpression:*p
									UnaryOperator:*
									Identifier:p
								Constant:'+'
							OrExpression:*p == '='\t || *p == ',' || *p == '.' || *p == '@'
								EqualityExpression:*p == '='
									UnaryOperationExpression:*p
										UnaryOperator:*
										Identifier:p
									Constant:'='
								OrExpression:*p == ',' || *p == '.' || *p == '@'
									EqualityExpression:*p == ','
										UnaryOperationExpression:*p
											UnaryOperator:*
											Identifier:p
										Constant:','
									OrExpression:*p == '.' || *p == '@'
										EqualityExpression:*p == '.'
											UnaryOperationExpression:*p
												UnaryOperator:*
												Identifier:p
											Constant:'.'
										EqualityExpression:*p == '@'
											UnaryOperationExpression:*p
												UnaryOperator:*
												Identifier:p
											Constant:'@'
			ExpressionStatement:p++
				PostIncDecOperationExpression:p++
					Identifier:p
					IncDec:++
		ExpressionStatement:len = p - atom
			AssignmentExpression:len = p - atom
				Identifier:len
				AdditiveExpression:p - atom
					Identifier:p
					Identifier:atom
		IfStatement:if (*p == '*')
			Condition:*p == '*'
				EqualityExpression:*p == '*'
					UnaryOperationExpression:*p
						UnaryOperator:*
						Identifier:p
					Constant:'*'
			ExpressionStatement:starred = true, p++
				Expression:starred = true, p++
					AssignmentExpression:starred = true
						Identifier:starred
						Identifier:true
					PostIncDecOperationExpression:p++
						Identifier:p
						IncDec:++
		ExpressionStatement:SKIP_WHITE ()
			CallExpression:SKIP_WHITE ()
				Callee:SKIP_WHITE
					Identifier:SKIP_WHITE
				ArgumentList:
		IfStatement:if (!suffix)
			Condition:!suffix
				UnaryOperationExpression:!suffix
					UnaryOperator:!
					Identifier:suffix
			CompoundStatement:
				Statement:/* Mark all matching switches as valid.  */
				ForStatement:for (i = 0; i < n_switches; i++)
					ForInit:i = 0;
						AssignmentExpression:i = 0
							Identifier:i
							Constant:0
					Condition:i < n_switches
						RelationalExpression:i < n_switches
							Identifier:i
							Identifier:n_switches
					PostIncDecOperationExpression:i++
						Identifier:i
						IncDec:++
					IfStatement:if (!strncmp (switches[i].part1, atom, len)\t    && (starred || switches[i].part1[len] == '\0')\t    && (switches[i].known || user_spec))
						Condition:!strncmp (switches[i].part1, atom, len)\t    && (starred || switches[i].part1[len] == '\0')\t    && (switches[i].known || user_spec)
							AndExpression:!strncmp (switches[i].part1, atom, len)\t    && (starred || switches[i].part1[len] == '\0')\t    && (switches[i].known || user_spec)
								UnaryOperationExpression:!strncmp (switches[i].part1, atom, len)
									UnaryOperator:!
									CallExpression:strncmp (switches[i].part1, atom, len)
										Callee:strncmp
											Identifier:strncmp
										ArgumentList:switches[i].part1
											Argument:switches[i].part1
												MemberAccess:switches[i].part1
													ArrayIndexing:switches[i]
														Identifier:switches
														Identifier:i
													Identifier:part1
											Argument:atom
												Identifier:atom
											Argument:len
												Identifier:len
								AndExpression:(starred || switches[i].part1[len] == '\0')\t    && (switches[i].known || user_spec)
									OrExpression:starred || switches[i].part1[len] == '\0'
										Identifier:starred
										EqualityExpression:switches[i].part1[len] == '\0'
											ArrayIndexing:switches[i].part1[len]
												MemberAccess:switches[i].part1
													ArrayIndexing:switches[i]
														Identifier:switches
														Identifier:i
													Identifier:part1
												Identifier:len
											Constant:'\0'
									OrExpression:switches[i].known || user_spec
										MemberAccess:switches[i].known
											ArrayIndexing:switches[i]
												Identifier:switches
												Identifier:i
											Identifier:known
										Identifier:user_spec
						ExpressionStatement:switches[i].validated = true
							AssignmentExpression:switches[i].validated = true
								MemberAccess:switches[i].validated
									ArrayIndexing:switches[i]
										Identifier:switches
										Identifier:i
									Identifier:validated
								Identifier:true
		IfStatement:if (*p)
			Condition:*p
				UnaryOperationExpression:*p
					UnaryOperator:*
					Identifier:p
			ExpressionStatement:p++
				PostIncDecOperationExpression:p++
					Identifier:p
					IncDec:++
		IfStatement:if (*p && (p[-1] == '|' || p[-1] == '&'))
			Condition:*p && (p[-1] == '|' || p[-1] == '&')
				AndExpression:*p && (p[-1] == '|' || p[-1] == '&')
					UnaryOperationExpression:*p
						UnaryOperator:*
						Identifier:p
					OrExpression:p[-1] == '|' || p[-1] == '&'
						EqualityExpression:p[-1] == '|'
							ArrayIndexing:p[-1]
								Identifier:p
								UnaryOperationExpression:-1
									UnaryOperator:-
									Constant:1
							Constant:'|'
						EqualityExpression:p[-1] == '&'
							ArrayIndexing:p[-1]
								Identifier:p
								UnaryOperationExpression:-1
									UnaryOperator:-
									Constant:1
							Constant:'&'
			GotoStatement:goto next_member;
				Identifier:next_member
		IfStatement:if (*p && p[-1] == ':')
			Condition:*p && p[-1] == ':'
				AndExpression:*p && p[-1] == ':'
					UnaryOperationExpression:*p
						UnaryOperator:*
						Identifier:p
					EqualityExpression:p[-1] == ':'
						ArrayIndexing:p[-1]
							Identifier:p
							UnaryOperationExpression:-1
								UnaryOperator:-
								Constant:1
						Constant:':'
			CompoundStatement:
				WhileStatement:while (*p && *p != ';' && *p != '}')
					Condition:*p && *p != ';' && *p != '}'
						AndExpression:*p && *p != ';' && *p != '}'
							UnaryOperationExpression:*p
								UnaryOperator:*
								Identifier:p
							AndExpression:*p != ';' && *p != '}'
								EqualityExpression:*p != ';'
									UnaryOperationExpression:*p
										UnaryOperator:*
										Identifier:p
									Constant:';'
								EqualityExpression:*p != '}'
									UnaryOperationExpression:*p
										UnaryOperator:*
										Identifier:p
									Constant:'}'
					CompoundStatement:
						IfStatement:if (*p == '%')
							Condition:*p == '%'
								EqualityExpression:*p == '%'
									UnaryOperationExpression:*p
										UnaryOperator:*
										Identifier:p
									Constant:'%'
							CompoundStatement:
								ExpressionStatement:p++
									PostIncDecOperationExpression:p++
										Identifier:p
										IncDec:++
								IfStatement:if (*p == '{' || *p == '<')
									Condition:*p == '{' || *p == '<'
										OrExpression:*p == '{' || *p == '<'
											EqualityExpression:*p == '{'
												UnaryOperationExpression:*p
													UnaryOperator:*
													Identifier:p
												Constant:'{'
											EqualityExpression:*p == '<'
												UnaryOperationExpression:*p
													UnaryOperator:*
													Identifier:p
												Constant:'<'
									ExpressionStatement:p = validate_switches (p+1, user_spec)
										AssignmentExpression:p = validate_switches (p+1, user_spec)
											Identifier:p
											CallExpression:validate_switches (p+1, user_spec)
												Callee:validate_switches
													Identifier:validate_switches
												ArgumentList:p+1
													Argument:p+1
														AdditiveExpression:p+1
															Identifier:p
															Constant:1
													Argument:user_spec
														Identifier:user_spec
				IfStatement:if (*p)
					Condition:*p
						UnaryOperationExpression:*p
							UnaryOperator:*
							Identifier:p
					ExpressionStatement:p++
						PostIncDecOperationExpression:p++
							Identifier:p
							IncDec:++
				IfStatement:if (*p && p[-1] == ';')
					Condition:*p && p[-1] == ';'
						AndExpression:*p && p[-1] == ';'
							UnaryOperationExpression:*p
								UnaryOperator:*
								Identifier:p
							EqualityExpression:p[-1] == ';'
								ArrayIndexing:p[-1]
									Identifier:p
									UnaryOperationExpression:-1
										UnaryOperator:-
										Constant:1
								Constant:';'
					GotoStatement:goto next_member;
						Identifier:next_member
		ReturnStatement:return p;
			Identifier:p
		Statement:undef
		Statement:SKIP_WHITE
	ReturnType:static const char *
	Identifier:validate_switches
	ParameterList:const char *start , bool user_spec
		Parameter:const char *start
			ParameterType:const char *
			Identifier:start
		Parameter:bool user_spec
			ParameterType:bool
			Identifier:user_spec
ClassDef:mdswitchstr
	CompoundStatement:
		IdentifierDeclStatement:null
			IdentifierDecl:*str
				IdentifierDeclType:const char *
				Identifier:str
		IdentifierDeclStatement:null
			IdentifierDecl:len
				IdentifierDeclType:int
				Identifier:len
IdentifierDeclStatement:null
	IdentifierDecl:*mdswitches
		IdentifierDeclType:struct mdswitchstr *
		Identifier:mdswitches
IdentifierDeclStatement:null
	IdentifierDecl:n_mdswitches
		IdentifierDeclType:int
		Identifier:n_mdswitches
ClassDef:used_arg_t
	CompoundStatement:
		IdentifierDeclStatement:null
			IdentifierDecl:finalize ()
				IdentifierDeclType:void ( )
				Identifier:finalize
		ClassDef:mswitchstr
			CompoundStatement:
				IdentifierDeclStatement:null
					IdentifierDecl:*str
						IdentifierDeclType:const char *
						Identifier:str
				IdentifierDeclStatement:null
					IdentifierDecl:*replace
						IdentifierDeclType:const char *
						Identifier:replace
				IdentifierDeclStatement:null
					IdentifierDecl:len
						IdentifierDeclType:int
						Identifier:len
				IdentifierDeclStatement:null
					IdentifierDecl:rep_len
						IdentifierDeclType:int
						Identifier:rep_len
		IdentifierDeclStatement:null
			IdentifierDecl:*mswitches
				IdentifierDeclType:mswitchstr *
				Identifier:mswitches
		IdentifierDeclStatement:null
			IdentifierDecl:n_mswitches
				IdentifierDeclType:int
				Identifier:n_mswitches
IdentifierDeclStatement:null
	IdentifierDecl:used_arg
		IdentifierDeclType:used_arg_t
		Identifier:used_arg
FunctionDef:operator () (const char *p , int len)
	CompoundStatement:
		IdentifierDeclStatement:int i, j;
			IdentifierDecl:i
				IdentifierDeclType:int
				Identifier:i
			IdentifierDecl:j
				IdentifierDeclType:int
				Identifier:j
		IfStatement:if (!mswitches)
			Condition:!mswitches
				UnaryOperationExpression:!mswitches
					UnaryOperator:!
					Identifier:mswitches
			CompoundStatement:
				IdentifierDeclStatement:struct mswitchstr *matches;
					IdentifierDecl:*matches
						IdentifierDeclType:struct mswitchstr *
						Identifier:matches
				IdentifierDeclStatement:const char *q;
					IdentifierDecl:*q
						IdentifierDeclType:const char *
						Identifier:q
				IdentifierDeclStatement:int cnt = 0;
					IdentifierDecl:cnt = 0
						IdentifierDeclType:int
						Identifier:cnt
						AssignmentExpression:cnt = 0
							Identifier:cnt
							Constant:0
				Statement:/* Break multilib_matches into the component strings of string         and replacement string.  */
				ForStatement:for (q = multilib_matches; *q != '\0'; q++)
					ForInit:q = multilib_matches;
						AssignmentExpression:q = multilib_matches
							Identifier:q
							Identifier:multilib_matches
					Condition:*q != '\0'
						EqualityExpression:*q != '\0'
							UnaryOperationExpression:*q
								UnaryOperator:*
								Identifier:q
							Constant:'\0'
					PostIncDecOperationExpression:q++
						Identifier:q
						IncDec:++
					IfStatement:if (*q == ';')
						Condition:*q == ';'
							EqualityExpression:*q == ';'
								UnaryOperationExpression:*q
									UnaryOperator:*
									Identifier:q
								Constant:';'
						ExpressionStatement:cnt++
							PostIncDecOperationExpression:cnt++
								Identifier:cnt
								IncDec:++
				ExpressionStatement:matches\t= (struct mswitchstr *) alloca ((sizeof (struct mswitchstr)) * cnt)
					AssignmentExpression:matches\t= (struct mswitchstr *) alloca ((sizeof (struct mswitchstr)) * cnt)
						Identifier:matches
						CastExpression:(struct mswitchstr *) alloca ((sizeof (struct mswitchstr)) * cnt)
							CastTarget:struct mswitchstr *
							CallExpression:alloca ((sizeof (struct mswitchstr)) * cnt)
								Callee:alloca
									Identifier:alloca
								ArgumentList:(sizeof (struct mswitchstr)) * cnt
									Argument:(sizeof (struct mswitchstr)) * cnt
										MultiplicativeExpression:(sizeof (struct mswitchstr)) * cnt
											SizeofExpression:sizeof (struct mswitchstr)
												Sizeof:sizeof
												SizeofOperand:struct mswitchstr
											Identifier:cnt
				ExpressionStatement:i = 0
					AssignmentExpression:i = 0
						Identifier:i
						Constant:0
				ExpressionStatement:q = multilib_matches
					AssignmentExpression:q = multilib_matches
						Identifier:q
						Identifier:multilib_matches
				WhileStatement:while (*q != '\0')
					Condition:*q != '\0'
						EqualityExpression:*q != '\0'
							UnaryOperationExpression:*q
								UnaryOperator:*
								Identifier:q
							Constant:'\0'
					CompoundStatement:
						ExpressionStatement:matches[i].str = q
							AssignmentExpression:matches[i].str = q
								MemberAccess:matches[i].str
									ArrayIndexing:matches[i]
										Identifier:matches
										Identifier:i
									Identifier:str
								Identifier:q
						WhileStatement:while (*q != ' ')
							Condition:*q != ' '
								EqualityExpression:*q != ' '
									UnaryOperationExpression:*q
										UnaryOperator:*
										Identifier:q
									Constant:' '
							CompoundStatement:
								IfStatement:if (*q == '\0')
									Condition:*q == '\0'
										EqualityExpression:*q == '\0'
											UnaryOperationExpression:*q
												UnaryOperator:*
												Identifier:q
											Constant:'\0'
									CompoundStatement:
										Label:invalid_matches:
											Identifier:invalid_matches
										ExpressionStatement:fatal_error (input_location, "multilib spec %qs is invalid",\t\t\t       multilib_matches)
											CallExpression:fatal_error (input_location, "multilib spec %qs is invalid",\t\t\t       multilib_matches)
												Callee:fatal_error
													Identifier:fatal_error
												ArgumentList:input_location
													Argument:input_location
														Identifier:input_location
													Argument:"multilib spec %qs is invalid"
														Constant:"multilib spec %qs is invalid"
													Argument:multilib_matches
														Identifier:multilib_matches
								ExpressionStatement:q++
									PostIncDecOperationExpression:q++
										Identifier:q
										IncDec:++
						ExpressionStatement:matches[i].len = q - matches[i].str
							AssignmentExpression:matches[i].len = q - matches[i].str
								MemberAccess:matches[i].len
									ArrayIndexing:matches[i]
										Identifier:matches
										Identifier:i
									Identifier:len
								AdditiveExpression:q - matches[i].str
									Identifier:q
									MemberAccess:matches[i].str
										ArrayIndexing:matches[i]
											Identifier:matches
											Identifier:i
										Identifier:str
						ExpressionStatement:matches[i].replace = ++q
							AssignmentExpression:matches[i].replace = ++q
								MemberAccess:matches[i].replace
									ArrayIndexing:matches[i]
										Identifier:matches
										Identifier:i
									Identifier:replace
								UnaryExpression:++q
									IncDec:++
									Identifier:q
						WhileStatement:while (*q != ';' && *q != '\0')
							Condition:*q != ';' && *q != '\0'
								AndExpression:*q != ';' && *q != '\0'
									EqualityExpression:*q != ';'
										UnaryOperationExpression:*q
											UnaryOperator:*
											Identifier:q
										Constant:';'
									EqualityExpression:*q != '\0'
										UnaryOperationExpression:*q
											UnaryOperator:*
											Identifier:q
										Constant:'\0'
							CompoundStatement:
								IfStatement:if (*q == ' ')
									Condition:*q == ' '
										EqualityExpression:*q == ' '
											UnaryOperationExpression:*q
												UnaryOperator:*
												Identifier:q
											Constant:' '
									GotoStatement:goto invalid_matches;
										Identifier:invalid_matches
								ExpressionStatement:q++
									PostIncDecOperationExpression:q++
										Identifier:q
										IncDec:++
						ExpressionStatement:matches[i].rep_len = q - matches[i].replace
							AssignmentExpression:matches[i].rep_len = q - matches[i].replace
								MemberAccess:matches[i].rep_len
									ArrayIndexing:matches[i]
										Identifier:matches
										Identifier:i
									Identifier:rep_len
								AdditiveExpression:q - matches[i].replace
									Identifier:q
									MemberAccess:matches[i].replace
										ArrayIndexing:matches[i]
											Identifier:matches
											Identifier:i
										Identifier:replace
						ExpressionStatement:i++
							PostIncDecOperationExpression:i++
								Identifier:i
								IncDec:++
						IfStatement:if (*q == ';')
							Condition:*q == ';'
								EqualityExpression:*q == ';'
									UnaryOperationExpression:*q
										UnaryOperator:*
										Identifier:q
									Constant:';'
							ExpressionStatement:q++
								PostIncDecOperationExpression:q++
									Identifier:q
									IncDec:++
				Statement:/* Now build a list of the replacement string for switches that we care\t about.  Make sure we allocate at least one entry.  This prevents\t xmalloc from calling fatal, and prevents us from re-executing this\t block of code.  */
				Statement:mswitches
				Statement:=
				Statement:XNEWVEC
				Statement:(
				Statement:struct
				Statement:mswitchstr
				Statement:,
				Statement:n_mdswitches
				Statement:+
				Statement:(
				Statement:n_switches
				Statement:?
				Label:n_switches :
					Identifier:n_switches
				Statement:1
				Statement:)
				Statement:)
				ExpressionStatement:
				ForStatement:for (i = 0; i < n_switches; i++)
					ForInit:i = 0;
						AssignmentExpression:i = 0
							Identifier:i
							Constant:0
					Condition:i < n_switches
						RelationalExpression:i < n_switches
							Identifier:i
							Identifier:n_switches
					PostIncDecOperationExpression:i++
						Identifier:i
						IncDec:++
					IfStatement:if ((switches[i].live_cond & SWITCH_IGNORE) == 0)
						Condition:(switches[i].live_cond & SWITCH_IGNORE) == 0
							EqualityExpression:(switches[i].live_cond & SWITCH_IGNORE) == 0
								BitAndExpression:switches[i].live_cond & SWITCH_IGNORE
									MemberAccess:switches[i].live_cond
										ArrayIndexing:switches[i]
											Identifier:switches
											Identifier:i
										Identifier:live_cond
									Identifier:SWITCH_IGNORE
								Constant:0
						CompoundStatement:
							IdentifierDeclStatement:int xlen = strlen (switches[i].part1);
								IdentifierDecl:xlen = strlen (switches[i].part1)
									IdentifierDeclType:int
									Identifier:xlen
									AssignmentExpression:xlen = strlen (switches[i].part1)
										Identifier:xlen
										CallExpression:strlen (switches[i].part1)
											Callee:strlen
												Identifier:strlen
											ArgumentList:switches[i].part1
												Argument:switches[i].part1
													MemberAccess:switches[i].part1
														ArrayIndexing:switches[i]
															Identifier:switches
															Identifier:i
														Identifier:part1
							ForStatement:for (j = 0; j < cnt; j++)
								ForInit:j = 0;
									AssignmentExpression:j = 0
										Identifier:j
										Constant:0
								Condition:j < cnt
									RelationalExpression:j < cnt
										Identifier:j
										Identifier:cnt
								PostIncDecOperationExpression:j++
									Identifier:j
									IncDec:++
								IfStatement:if (xlen == matches[j].len\t\t  && ! strncmp (switches[i].part1, matches[j].str, xlen))
									Condition:xlen == matches[j].len\t\t  && ! strncmp (switches[i].part1, matches[j].str, xlen)
										AndExpression:xlen == matches[j].len\t\t  && ! strncmp (switches[i].part1, matches[j].str, xlen)
											EqualityExpression:xlen == matches[j].len
												Identifier:xlen
												MemberAccess:matches[j].len
													ArrayIndexing:matches[j]
														Identifier:matches
														Identifier:j
													Identifier:len
											UnaryOperationExpression:! strncmp (switches[i].part1, matches[j].str, xlen)
												UnaryOperator:!
												CallExpression:strncmp (switches[i].part1, matches[j].str, xlen)
													Callee:strncmp
														Identifier:strncmp
													ArgumentList:switches[i].part1
														Argument:switches[i].part1
															MemberAccess:switches[i].part1
																ArrayIndexing:switches[i]
																	Identifier:switches
																	Identifier:i
																Identifier:part1
														Argument:matches[j].str
															MemberAccess:matches[j].str
																ArrayIndexing:matches[j]
																	Identifier:matches
																	Identifier:j
																Identifier:str
														Argument:xlen
															Identifier:xlen
									CompoundStatement:
										ExpressionStatement:mswitches[n_mswitches].str = matches[j].replace
											AssignmentExpression:mswitches[n_mswitches].str = matches[j].replace
												MemberAccess:mswitches[n_mswitches].str
													ArrayIndexing:mswitches[n_mswitches]
														Identifier:mswitches
														Identifier:n_mswitches
													Identifier:str
												MemberAccess:matches[j].replace
													ArrayIndexing:matches[j]
														Identifier:matches
														Identifier:j
													Identifier:replace
										ExpressionStatement:mswitches[n_mswitches].len = matches[j].rep_len
											AssignmentExpression:mswitches[n_mswitches].len = matches[j].rep_len
												MemberAccess:mswitches[n_mswitches].len
													ArrayIndexing:mswitches[n_mswitches]
														Identifier:mswitches
														Identifier:n_mswitches
													Identifier:len
												MemberAccess:matches[j].rep_len
													ArrayIndexing:matches[j]
														Identifier:matches
														Identifier:j
													Identifier:rep_len
										ExpressionStatement:mswitches[n_mswitches].replace = (char *) 0
											AssignmentExpression:mswitches[n_mswitches].replace = (char *) 0
												MemberAccess:mswitches[n_mswitches].replace
													ArrayIndexing:mswitches[n_mswitches]
														Identifier:mswitches
														Identifier:n_mswitches
													Identifier:replace
												CastExpression:(char *) 0
													CastTarget:char *
													Constant:0
										ExpressionStatement:mswitches[n_mswitches].rep_len = 0
											AssignmentExpression:mswitches[n_mswitches].rep_len = 0
												MemberAccess:mswitches[n_mswitches].rep_len
													ArrayIndexing:mswitches[n_mswitches]
														Identifier:mswitches
														Identifier:n_mswitches
													Identifier:rep_len
												Constant:0
										ExpressionStatement:n_mswitches++
											PostIncDecOperationExpression:n_mswitches++
												Identifier:n_mswitches
												IncDec:++
										BreakStatement:break;
				Statement:/* Add MULTILIB_DEFAULTS switches too, as long as they were not present\t on the command line nor any options mutually incompatible with\t them.  */
				ForStatement:for (i = 0; i < n_mdswitches; i++)
					ForInit:i = 0;
						AssignmentExpression:i = 0
							Identifier:i
							Constant:0
					Condition:i < n_mdswitches
						RelationalExpression:i < n_mdswitches
							Identifier:i
							Identifier:n_mdswitches
					PostIncDecOperationExpression:i++
						Identifier:i
						IncDec:++
					CompoundStatement:
						IdentifierDeclStatement:const char *r;
							IdentifierDecl:*r
								IdentifierDeclType:const char *
								Identifier:r
						ForStatement:for (q = multilib_options; *q != '\0'; *q && q++)
							ForInit:q = multilib_options;
								AssignmentExpression:q = multilib_options
									Identifier:q
									Identifier:multilib_options
							Condition:*q != '\0'
								EqualityExpression:*q != '\0'
									UnaryOperationExpression:*q
										UnaryOperator:*
										Identifier:q
									Constant:'\0'
							AndExpression:*q && q++
								UnaryOperationExpression:*q
									UnaryOperator:*
									Identifier:q
								PostIncDecOperationExpression:q++
									Identifier:q
									IncDec:++
							CompoundStatement:
								WhileStatement:while (*q == ' ')
									Condition:*q == ' '
										EqualityExpression:*q == ' '
											UnaryOperationExpression:*q
												UnaryOperator:*
												Identifier:q
											Constant:' '
									ExpressionStatement:q++
										PostIncDecOperationExpression:q++
											Identifier:q
											IncDec:++
								ExpressionStatement:r = q
									AssignmentExpression:r = q
										Identifier:r
										Identifier:q
								WhileStatement:while (strncmp (q, mdswitches[i].str, mdswitches[i].len) != 0\t\t     || strchr (" /", q[mdswitches[i].len]) == NULL)
									Condition:strncmp (q, mdswitches[i].str, mdswitches[i].len) != 0\t\t     || strchr (" /", q[mdswitches[i].len]) == NULL
										OrExpression:strncmp (q, mdswitches[i].str, mdswitches[i].len) != 0\t\t     || strchr (" /", q[mdswitches[i].len]) == NULL
											EqualityExpression:strncmp (q, mdswitches[i].str, mdswitches[i].len) != 0
												CallExpression:strncmp (q, mdswitches[i].str, mdswitches[i].len)
													Callee:strncmp
														Identifier:strncmp
													ArgumentList:q
														Argument:q
															Identifier:q
														Argument:mdswitches[i].str
															MemberAccess:mdswitches[i].str
																ArrayIndexing:mdswitches[i]
																	Identifier:mdswitches
																	Identifier:i
																Identifier:str
														Argument:mdswitches[i].len
															MemberAccess:mdswitches[i].len
																ArrayIndexing:mdswitches[i]
																	Identifier:mdswitches
																	Identifier:i
																Identifier:len
												Constant:0
											EqualityExpression:strchr (" /", q[mdswitches[i].len]) == NULL
												CallExpression:strchr (" /", q[mdswitches[i].len])
													Callee:strchr
														Identifier:strchr
													ArgumentList:" /"
														Argument:" /"
															Constant:" /"
														Argument:q[mdswitches[i].len]
															ArrayIndexing:q[mdswitches[i].len]
																Identifier:q
																MemberAccess:mdswitches[i].len
																	ArrayIndexing:mdswitches[i]
																		Identifier:mdswitches
																		Identifier:i
																	Identifier:len
												Identifier:NULL
									CompoundStatement:
										WhileStatement:while (*q != ' ' && *q != '/' && *q != '\0')
											Condition:*q != ' ' && *q != '/' && *q != '\0'
												AndExpression:*q != ' ' && *q != '/' && *q != '\0'
													EqualityExpression:*q != ' '
														UnaryOperationExpression:*q
															UnaryOperator:*
															Identifier:q
														Constant:' '
													AndExpression:*q != '/' && *q != '\0'
														EqualityExpression:*q != '/'
															UnaryOperationExpression:*q
																UnaryOperator:*
																Identifier:q
															Constant:'/'
														EqualityExpression:*q != '\0'
															UnaryOperationExpression:*q
																UnaryOperator:*
																Identifier:q
															Constant:'\0'
											ExpressionStatement:q++
												PostIncDecOperationExpression:q++
													Identifier:q
													IncDec:++
										IfStatement:if (*q != '/')
											Condition:*q != '/'
												EqualityExpression:*q != '/'
													UnaryOperationExpression:*q
														UnaryOperator:*
														Identifier:q
													Constant:'/'
											BreakStatement:break;
										ExpressionStatement:q++
											PostIncDecOperationExpression:q++
												Identifier:q
												IncDec:++
								IfStatement:if (*q != ' ' && *q != '\0')
									Condition:*q != ' ' && *q != '\0'
										AndExpression:*q != ' ' && *q != '\0'
											EqualityExpression:*q != ' '
												UnaryOperationExpression:*q
													UnaryOperator:*
													Identifier:q
												Constant:' '
											EqualityExpression:*q != '\0'
												UnaryOperationExpression:*q
													UnaryOperator:*
													Identifier:q
												Constant:'\0'
									CompoundStatement:
										WhileStatement:while (*r != ' ' && *r != '\0')
											Condition:*r != ' ' && *r != '\0'
												AndExpression:*r != ' ' && *r != '\0'
													EqualityExpression:*r != ' '
														UnaryOperationExpression:*r
															UnaryOperator:*
															Identifier:r
														Constant:' '
													EqualityExpression:*r != '\0'
														UnaryOperationExpression:*r
															UnaryOperator:*
															Identifier:r
														Constant:'\0'
											CompoundStatement:
												ExpressionStatement:q = r
													AssignmentExpression:q = r
														Identifier:q
														Identifier:r
												WhileStatement:while (*q != ' ' && *q != '/' && *q != '\0')
													Condition:*q != ' ' && *q != '/' && *q != '\0'
														AndExpression:*q != ' ' && *q != '/' && *q != '\0'
															EqualityExpression:*q != ' '
																UnaryOperationExpression:*q
																	UnaryOperator:*
																	Identifier:q
																Constant:' '
															AndExpression:*q != '/' && *q != '\0'
																EqualityExpression:*q != '/'
																	UnaryOperationExpression:*q
																		UnaryOperator:*
																		Identifier:q
																	Constant:'/'
																EqualityExpression:*q != '\0'
																	UnaryOperationExpression:*q
																		UnaryOperator:*
																		Identifier:q
																	Constant:'\0'
													ExpressionStatement:q++
														PostIncDecOperationExpression:q++
															Identifier:q
															IncDec:++
												IfStatement:if (used_arg (r, q - r))
													Condition:used_arg (r, q - r)
														CallExpression:used_arg (r, q - r)
															Callee:used_arg
																Identifier:used_arg
															ArgumentList:r
																Argument:r
																	Identifier:r
																Argument:q - r
																	AdditiveExpression:q - r
																		Identifier:q
																		Identifier:r
													BreakStatement:break;
												IfStatement:if (*q != '/')
													Condition:*q != '/'
														EqualityExpression:*q != '/'
															UnaryOperationExpression:*q
																UnaryOperator:*
																Identifier:q
															Constant:'/'
													CompoundStatement:
														ExpressionStatement:mswitches[n_mswitches].str = mdswitches[i].str
															AssignmentExpression:mswitches[n_mswitches].str = mdswitches[i].str
																MemberAccess:mswitches[n_mswitches].str
																	ArrayIndexing:mswitches[n_mswitches]
																		Identifier:mswitches
																		Identifier:n_mswitches
																	Identifier:str
																MemberAccess:mdswitches[i].str
																	ArrayIndexing:mdswitches[i]
																		Identifier:mdswitches
																		Identifier:i
																	Identifier:str
														ExpressionStatement:mswitches[n_mswitches].len = mdswitches[i].len
															AssignmentExpression:mswitches[n_mswitches].len = mdswitches[i].len
																MemberAccess:mswitches[n_mswitches].len
																	ArrayIndexing:mswitches[n_mswitches]
																		Identifier:mswitches
																		Identifier:n_mswitches
																	Identifier:len
																MemberAccess:mdswitches[i].len
																	ArrayIndexing:mdswitches[i]
																		Identifier:mdswitches
																		Identifier:i
																	Identifier:len
														ExpressionStatement:mswitches[n_mswitches].replace = (char *) 0
															AssignmentExpression:mswitches[n_mswitches].replace = (char *) 0
																MemberAccess:mswitches[n_mswitches].replace
																	ArrayIndexing:mswitches[n_mswitches]
																		Identifier:mswitches
																		Identifier:n_mswitches
																	Identifier:replace
																CastExpression:(char *) 0
																	CastTarget:char *
																	Constant:0
														ExpressionStatement:mswitches[n_mswitches].rep_len = 0
															AssignmentExpression:mswitches[n_mswitches].rep_len = 0
																MemberAccess:mswitches[n_mswitches].rep_len
																	ArrayIndexing:mswitches[n_mswitches]
																		Identifier:mswitches
																		Identifier:n_mswitches
																	Identifier:rep_len
																Constant:0
														ExpressionStatement:n_mswitches++
															PostIncDecOperationExpression:n_mswitches++
																Identifier:n_mswitches
																IncDec:++
														BreakStatement:break;
												ExpressionStatement:r = q + 1
													AssignmentExpression:r = q + 1
														Identifier:r
														AdditiveExpression:q + 1
															Identifier:q
															Constant:1
										BreakStatement:break;
		ForStatement:for (i = 0; i < n_mswitches; i++)
			ForInit:i = 0;
				AssignmentExpression:i = 0
					Identifier:i
					Constant:0
			Condition:i < n_mswitches
				RelationalExpression:i < n_mswitches
					Identifier:i
					Identifier:n_mswitches
			PostIncDecOperationExpression:i++
				Identifier:i
				IncDec:++
			IfStatement:if (len == mswitches[i].len && ! strncmp (p, mswitches[i].str, len))
				Condition:len == mswitches[i].len && ! strncmp (p, mswitches[i].str, len)
					AndExpression:len == mswitches[i].len && ! strncmp (p, mswitches[i].str, len)
						EqualityExpression:len == mswitches[i].len
							Identifier:len
							MemberAccess:mswitches[i].len
								ArrayIndexing:mswitches[i]
									Identifier:mswitches
									Identifier:i
								Identifier:len
						UnaryOperationExpression:! strncmp (p, mswitches[i].str, len)
							UnaryOperator:!
							CallExpression:strncmp (p, mswitches[i].str, len)
								Callee:strncmp
									Identifier:strncmp
								ArgumentList:p
									Argument:p
										Identifier:p
									Argument:mswitches[i].str
										MemberAccess:mswitches[i].str
											ArrayIndexing:mswitches[i]
												Identifier:mswitches
												Identifier:i
											Identifier:str
									Argument:len
										Identifier:len
				ReturnStatement:return 1;
					Constant:1
		ReturnStatement:return 0;
			Constant:0
	Identifier:operator ()
	ParameterList:const char *p , int len
		Parameter:const char *p
			ParameterType:const char *
			Identifier:p
		Parameter:int len
			ParameterType:int
			Identifier:len
FunctionDef:used_arg_t::finalize ()
	CompoundStatement:
		ExpressionStatement:XDELETEVEC (mswitches)
			CallExpression:XDELETEVEC (mswitches)
				Callee:XDELETEVEC
					Identifier:XDELETEVEC
				ArgumentList:mswitches
					Argument:mswitches
						Identifier:mswitches
		ExpressionStatement:mswitches = NULL
			AssignmentExpression:mswitches = NULL
				Identifier:mswitches
				Identifier:NULL
		ExpressionStatement:n_mswitches = 0
			AssignmentExpression:n_mswitches = 0
				Identifier:n_mswitches
				Constant:0
	ReturnType:void
	Identifier:used_arg_t::finalize
	ParameterList:
FunctionDef:intdefault_arg (const char *p , int len)
	CompoundStatement:
		IdentifierDeclStatement:int i;
			IdentifierDecl:i
				IdentifierDeclType:int
				Identifier:i
		ForStatement:for (i = 0; i < n_mdswitches; i++)
			ForInit:i = 0;
				AssignmentExpression:i = 0
					Identifier:i
					Constant:0
			Condition:i < n_mdswitches
				RelationalExpression:i < n_mdswitches
					Identifier:i
					Identifier:n_mdswitches
			PostIncDecOperationExpression:i++
				Identifier:i
				IncDec:++
			IfStatement:if (len == mdswitches[i].len && ! strncmp (p, mdswitches[i].str, len))
				Condition:len == mdswitches[i].len && ! strncmp (p, mdswitches[i].str, len)
					AndExpression:len == mdswitches[i].len && ! strncmp (p, mdswitches[i].str, len)
						EqualityExpression:len == mdswitches[i].len
							Identifier:len
							MemberAccess:mdswitches[i].len
								ArrayIndexing:mdswitches[i]
									Identifier:mdswitches
									Identifier:i
								Identifier:len
						UnaryOperationExpression:! strncmp (p, mdswitches[i].str, len)
							UnaryOperator:!
							CallExpression:strncmp (p, mdswitches[i].str, len)
								Callee:strncmp
									Identifier:strncmp
								ArgumentList:p
									Argument:p
										Identifier:p
									Argument:mdswitches[i].str
										MemberAccess:mdswitches[i].str
											ArrayIndexing:mdswitches[i]
												Identifier:mdswitches
												Identifier:i
											Identifier:str
									Argument:len
										Identifier:len
				ReturnStatement:return 1;
					Constant:1
		ReturnStatement:return 0;
			Constant:0
	Identifier:intdefault_arg
	ParameterList:const char *p , int len
		Parameter:const char *p
			ParameterType:const char *
			Identifier:p
		Parameter:int len
			ParameterType:int
			Identifier:len
FunctionDef:voidset_multilib_dir ()
	CompoundStatement:
		IdentifierDeclStatement:const char *p;
			IdentifierDecl:*p
				IdentifierDeclType:const char *
				Identifier:p
		IdentifierDeclStatement:unsigned int this_path_len;
			IdentifierDecl:this_path_len
				IdentifierDeclType:unsigned int
				Identifier:this_path_len
		IdentifierDeclStatement:const char *this_path, *this_arg;
			IdentifierDecl:*this_path
				IdentifierDeclType:const char *
				Identifier:this_path
			IdentifierDecl:*this_arg
				IdentifierDeclType:const char *
				Identifier:this_arg
		IdentifierDeclStatement:const char *start, *end;
			IdentifierDecl:*start
				IdentifierDeclType:const char *
				Identifier:start
			IdentifierDecl:*end
				IdentifierDeclType:const char *
				Identifier:end
		IdentifierDeclStatement:int not_arg;
			IdentifierDecl:not_arg
				IdentifierDeclType:int
				Identifier:not_arg
		IdentifierDeclStatement:int ok, ndfltok, first;
			IdentifierDecl:ok
				IdentifierDeclType:int
				Identifier:ok
			IdentifierDecl:ndfltok
				IdentifierDeclType:int
				Identifier:ndfltok
			IdentifierDecl:first
				IdentifierDeclType:int
				Identifier:first
		ExpressionStatement:n_mdswitches = 0
			AssignmentExpression:n_mdswitches = 0
				Identifier:n_mdswitches
				Constant:0
		ExpressionStatement:start = multilib_defaults
			AssignmentExpression:start = multilib_defaults
				Identifier:start
				Identifier:multilib_defaults
		WhileStatement:while (*start == ' ' || *start == '\t')
			Condition:*start == ' ' || *start == '\t'
				OrExpression:*start == ' ' || *start == '\t'
					EqualityExpression:*start == ' '
						UnaryOperationExpression:*start
							UnaryOperator:*
							Identifier:start
						Constant:' '
					EqualityExpression:*start == '\t'
						UnaryOperationExpression:*start
							UnaryOperator:*
							Identifier:start
						Constant:'\t'
			ExpressionStatement:start++
				PostIncDecOperationExpression:start++
					Identifier:start
					IncDec:++
		WhileStatement:while (*start != '\0')
			Condition:*start != '\0'
				EqualityExpression:*start != '\0'
					UnaryOperationExpression:*start
						UnaryOperator:*
						Identifier:start
					Constant:'\0'
			CompoundStatement:
				ExpressionStatement:n_mdswitches++
					PostIncDecOperationExpression:n_mdswitches++
						Identifier:n_mdswitches
						IncDec:++
				WhileStatement:while (*start != ' ' && *start != '\t' && *start != '\0')
					Condition:*start != ' ' && *start != '\t' && *start != '\0'
						AndExpression:*start != ' ' && *start != '\t' && *start != '\0'
							EqualityExpression:*start != ' '
								UnaryOperationExpression:*start
									UnaryOperator:*
									Identifier:start
								Constant:' '
							AndExpression:*start != '\t' && *start != '\0'
								EqualityExpression:*start != '\t'
									UnaryOperationExpression:*start
										UnaryOperator:*
										Identifier:start
									Constant:'\t'
								EqualityExpression:*start != '\0'
									UnaryOperationExpression:*start
										UnaryOperator:*
										Identifier:start
									Constant:'\0'
					ExpressionStatement:start++
						PostIncDecOperationExpression:start++
							Identifier:start
							IncDec:++
				WhileStatement:while (*start == ' ' || *start == '\t')
					Condition:*start == ' ' || *start == '\t'
						OrExpression:*start == ' ' || *start == '\t'
							EqualityExpression:*start == ' '
								UnaryOperationExpression:*start
									UnaryOperator:*
									Identifier:start
								Constant:' '
							EqualityExpression:*start == '\t'
								UnaryOperationExpression:*start
									UnaryOperator:*
									Identifier:start
								Constant:'\t'
					ExpressionStatement:start++
						PostIncDecOperationExpression:start++
							Identifier:start
							IncDec:++
		IfStatement:if (n_mdswitches)
			Condition:n_mdswitches
				Identifier:n_mdswitches
			CompoundStatement:
				IdentifierDeclStatement:int i = 0;
					IdentifierDecl:i = 0
						IdentifierDeclType:int
						Identifier:i
						AssignmentExpression:i = 0
							Identifier:i
							Constant:0
				Statement:mdswitches
				Statement:=
				Statement:XNEWVEC
				Statement:(
				Statement:struct
				Statement:mdswitchstr
				Statement:,
				Statement:n_mdswitches
				Statement:)
				ExpressionStatement:
				ForStatement:for (start = multilib_defaults; *start != '\0'; start = end + 1)
					ForInit:start = multilib_defaults;
						AssignmentExpression:start = multilib_defaults
							Identifier:start
							Identifier:multilib_defaults
					Condition:*start != '\0'
						EqualityExpression:*start != '\0'
							UnaryOperationExpression:*start
								UnaryOperator:*
								Identifier:start
							Constant:'\0'
					AssignmentExpression:start = end + 1
						Identifier:start
						AdditiveExpression:end + 1
							Identifier:end
							Constant:1
					CompoundStatement:
						WhileStatement:while (*start == ' ' || *start == '\t')
							Condition:*start == ' ' || *start == '\t'
								OrExpression:*start == ' ' || *start == '\t'
									EqualityExpression:*start == ' '
										UnaryOperationExpression:*start
											UnaryOperator:*
											Identifier:start
										Constant:' '
									EqualityExpression:*start == '\t'
										UnaryOperationExpression:*start
											UnaryOperator:*
											Identifier:start
										Constant:'\t'
							ExpressionStatement:start++
								PostIncDecOperationExpression:start++
									Identifier:start
									IncDec:++
						IfStatement:if (*start == '\0')
							Condition:*start == '\0'
								EqualityExpression:*start == '\0'
									UnaryOperationExpression:*start
										UnaryOperator:*
										Identifier:start
									Constant:'\0'
							BreakStatement:break;
						ForStatement:for (end = start + 1;\t       *end != ' ' && *end != '\t' && *end != '\0'; end++)
							ForInit:end = start + 1;
								AssignmentExpression:end = start + 1
									Identifier:end
									AdditiveExpression:start + 1
										Identifier:start
										Constant:1
							Condition:*end != ' ' && *end != '\t' && *end != '\0'
								AndExpression:*end != ' ' && *end != '\t' && *end != '\0'
									EqualityExpression:*end != ' '
										UnaryOperationExpression:*end
											UnaryOperator:*
											Identifier:end
										Constant:' '
									AndExpression:*end != '\t' && *end != '\0'
										EqualityExpression:*end != '\t'
											UnaryOperationExpression:*end
												UnaryOperator:*
												Identifier:end
											Constant:'\t'
										EqualityExpression:*end != '\0'
											UnaryOperationExpression:*end
												UnaryOperator:*
												Identifier:end
											Constant:'\0'
							PostIncDecOperationExpression:end++
								Identifier:end
								IncDec:++
							ExpressionStatement:
						ExpressionStatement:obstack_grow (&multilib_obstack, start, end - start)
							CallExpression:obstack_grow (&multilib_obstack, start, end - start)
								Callee:obstack_grow
									Identifier:obstack_grow
								ArgumentList:&multilib_obstack
									Argument:&multilib_obstack
										UnaryOperationExpression:&multilib_obstack
											UnaryOperator:&
											Identifier:multilib_obstack
									Argument:start
										Identifier:start
									Argument:end - start
										AdditiveExpression:end - start
											Identifier:end
											Identifier:start
						ExpressionStatement:obstack_1grow (&multilib_obstack, 0)
							CallExpression:obstack_1grow (&multilib_obstack, 0)
								Callee:obstack_1grow
									Identifier:obstack_1grow
								ArgumentList:&multilib_obstack
									Argument:&multilib_obstack
										UnaryOperationExpression:&multilib_obstack
											UnaryOperator:&
											Identifier:multilib_obstack
									Argument:0
										Constant:0
						Statement:mdswitches
						Statement:[
						Statement:i
						Statement:]
						Statement:.
						Statement:str
						Statement:=
						Statement:XOBFINISH
						Statement:(
						Statement:&
						Statement:multilib_obstack
						Statement:,
						Statement:const
						Statement:char
						Statement:*
						Statement:)
						ExpressionStatement:
						ExpressionStatement:mdswitches[i++].len = end - start
							AssignmentExpression:mdswitches[i++].len = end - start
								MemberAccess:mdswitches[i++].len
									ArrayIndexing:mdswitches[i++]
										Identifier:mdswitches
										PostIncDecOperationExpression:i++
											Identifier:i
											IncDec:++
									Identifier:len
								AdditiveExpression:end - start
									Identifier:end
									Identifier:start
						IfStatement:if (*end == '\0')
							Condition:*end == '\0'
								EqualityExpression:*end == '\0'
									UnaryOperationExpression:*end
										UnaryOperator:*
										Identifier:end
									Constant:'\0'
							BreakStatement:break;
		ExpressionStatement:p = multilib_exclusions
			AssignmentExpression:p = multilib_exclusions
				Identifier:p
				Identifier:multilib_exclusions
		WhileStatement:while (*p != '\0')
			Condition:*p != '\0'
				EqualityExpression:*p != '\0'
					UnaryOperationExpression:*p
						UnaryOperator:*
						Identifier:p
					Constant:'\0'
			CompoundStatement:
				Statement:/* Ignore newlines.  */
				IfStatement:if (*p == '\n')
					Condition:*p == '\n'
						EqualityExpression:*p == '\n'
							UnaryOperationExpression:*p
								UnaryOperator:*
								Identifier:p
							Constant:'\n'
					CompoundStatement:
						ExpressionStatement:++p
							UnaryExpression:++p
								IncDec:++
								Identifier:p
						ContinueStatement:continue;
				Statement:/* Check the arguments.  */
				ExpressionStatement:ok = 1
					AssignmentExpression:ok = 1
						Identifier:ok
						Constant:1
				WhileStatement:while (*p != ';')
					Condition:*p != ';'
						EqualityExpression:*p != ';'
							UnaryOperationExpression:*p
								UnaryOperator:*
								Identifier:p
							Constant:';'
					CompoundStatement:
						IfStatement:if (*p == '\0')
							Condition:*p == '\0'
								EqualityExpression:*p == '\0'
									UnaryOperationExpression:*p
										UnaryOperator:*
										Identifier:p
									Constant:'\0'
							CompoundStatement:
								Label:invalid_exclusions:
									Identifier:invalid_exclusions
								ExpressionStatement:fatal_error (input_location, "multilib exclusions %qs is invalid",\t\t\t   multilib_exclusions)
									CallExpression:fatal_error (input_location, "multilib exclusions %qs is invalid",\t\t\t   multilib_exclusions)
										Callee:fatal_error
											Identifier:fatal_error
										ArgumentList:input_location
											Argument:input_location
												Identifier:input_location
											Argument:"multilib exclusions %qs is invalid"
												Constant:"multilib exclusions %qs is invalid"
											Argument:multilib_exclusions
												Identifier:multilib_exclusions
						IfStatement:if (! ok)
							Condition:! ok
								UnaryOperationExpression:! ok
									UnaryOperator:!
									Identifier:ok
							CompoundStatement:
								ExpressionStatement:++p
									UnaryExpression:++p
										IncDec:++
										Identifier:p
								ContinueStatement:continue;
						ExpressionStatement:this_arg = p
							AssignmentExpression:this_arg = p
								Identifier:this_arg
								Identifier:p
						WhileStatement:while (*p != ' ' && *p != ';')
							Condition:*p != ' ' && *p != ';'
								AndExpression:*p != ' ' && *p != ';'
									EqualityExpression:*p != ' '
										UnaryOperationExpression:*p
											UnaryOperator:*
											Identifier:p
										Constant:' '
									EqualityExpression:*p != ';'
										UnaryOperationExpression:*p
											UnaryOperator:*
											Identifier:p
										Constant:';'
							CompoundStatement:
								IfStatement:if (*p == '\0')
									Condition:*p == '\0'
										EqualityExpression:*p == '\0'
											UnaryOperationExpression:*p
												UnaryOperator:*
												Identifier:p
											Constant:'\0'
									GotoStatement:goto invalid_exclusions;
										Identifier:invalid_exclusions
								ExpressionStatement:++p
									UnaryExpression:++p
										IncDec:++
										Identifier:p
						IfStatement:if (*this_arg != '!')
							Condition:*this_arg != '!'
								EqualityExpression:*this_arg != '!'
									UnaryOperationExpression:*this_arg
										UnaryOperator:*
										Identifier:this_arg
									Constant:'!'
							ExpressionStatement:not_arg = 0
								AssignmentExpression:not_arg = 0
									Identifier:not_arg
									Constant:0
						ExpressionStatement:ok = used_arg (this_arg, p - this_arg)
							AssignmentExpression:ok = used_arg (this_arg, p - this_arg)
								Identifier:ok
								CallExpression:used_arg (this_arg, p - this_arg)
									Callee:used_arg
										Identifier:used_arg
									ArgumentList:this_arg
										Argument:this_arg
											Identifier:this_arg
										Argument:p - this_arg
											AdditiveExpression:p - this_arg
												Identifier:p
												Identifier:this_arg
						IfStatement:if (not_arg)
							Condition:not_arg
								Identifier:not_arg
							ExpressionStatement:ok = ! ok
								AssignmentExpression:ok = ! ok
									Identifier:ok
									UnaryOperationExpression:! ok
										UnaryOperator:!
										Identifier:ok
						IfStatement:if (*p == ' ')
							Condition:*p == ' '
								EqualityExpression:*p == ' '
									UnaryOperationExpression:*p
										UnaryOperator:*
										Identifier:p
									Constant:' '
							ExpressionStatement:++p
								UnaryExpression:++p
									IncDec:++
									Identifier:p
				IfStatement:if (ok)
					Condition:ok
						Identifier:ok
					ReturnStatement:return;
				ExpressionStatement:++p
					UnaryExpression:++p
						IncDec:++
						Identifier:p
		ExpressionStatement:first = 1
			AssignmentExpression:first = 1
				Identifier:first
				Constant:1
		ExpressionStatement:p = multilib_select
			AssignmentExpression:p = multilib_select
				Identifier:p
				Identifier:multilib_select
		Statement:/* Append multilib reuse rules if any.  With those rules, we can reuse     one multilib for certain different options sets.  */
		IfStatement:if (strlen (multilib_reuse) > 0)
			Condition:strlen (multilib_reuse) > 0
				RelationalExpression:strlen (multilib_reuse) > 0
					CallExpression:strlen (multilib_reuse)
						Callee:strlen
							Identifier:strlen
						ArgumentList:multilib_reuse
							Argument:multilib_reuse
								Identifier:multilib_reuse
					Constant:0
			ExpressionStatement:p = concat (p, multilib_reuse, NULL)
				AssignmentExpression:p = concat (p, multilib_reuse, NULL)
					Identifier:p
					CallExpression:concat (p, multilib_reuse, NULL)
						Callee:concat
							Identifier:concat
						ArgumentList:p
							Argument:p
								Identifier:p
							Argument:multilib_reuse
								Identifier:multilib_reuse
							Argument:NULL
								Identifier:NULL
		WhileStatement:while (*p != '\0')
			Condition:*p != '\0'
				EqualityExpression:*p != '\0'
					UnaryOperationExpression:*p
						UnaryOperator:*
						Identifier:p
					Constant:'\0'
			CompoundStatement:
				Statement:/* Ignore newlines.  */
				IfStatement:if (*p == '\n')
					Condition:*p == '\n'
						EqualityExpression:*p == '\n'
							UnaryOperationExpression:*p
								UnaryOperator:*
								Identifier:p
							Constant:'\n'
					CompoundStatement:
						ExpressionStatement:++p
							UnaryExpression:++p
								IncDec:++
								Identifier:p
						ContinueStatement:continue;
				Statement:/* Get the initial path.  */
				ExpressionStatement:this_path = p
					AssignmentExpression:this_path = p
						Identifier:this_path
						Identifier:p
				WhileStatement:while (*p != ' ')
					Condition:*p != ' '
						EqualityExpression:*p != ' '
							UnaryOperationExpression:*p
								UnaryOperator:*
								Identifier:p
							Constant:' '
					CompoundStatement:
						IfStatement:if (*p == '\0')
							Condition:*p == '\0'
								EqualityExpression:*p == '\0'
									UnaryOperationExpression:*p
										UnaryOperator:*
										Identifier:p
									Constant:'\0'
							CompoundStatement:
								Label:invalid_select:
									Identifier:invalid_select
								ExpressionStatement:fatal_error (input_location, "multilib select %qs %qs is invalid",\t\t\t   multilib_select, multilib_reuse)
									CallExpression:fatal_error (input_location, "multilib select %qs %qs is invalid",\t\t\t   multilib_select, multilib_reuse)
										Callee:fatal_error
											Identifier:fatal_error
										ArgumentList:input_location
											Argument:input_location
												Identifier:input_location
											Argument:"multilib select %qs %qs is invalid"
												Constant:"multilib select %qs %qs is invalid"
											Argument:multilib_select
												Identifier:multilib_select
											Argument:multilib_reuse
												Identifier:multilib_reuse
						ExpressionStatement:++p
							UnaryExpression:++p
								IncDec:++
								Identifier:p
				ExpressionStatement:this_path_len = p - this_path
					AssignmentExpression:this_path_len = p - this_path
						Identifier:this_path_len
						AdditiveExpression:p - this_path
							Identifier:p
							Identifier:this_path
				Statement:/* Check the arguments.  */
				ExpressionStatement:ok = 1
					AssignmentExpression:ok = 1
						Identifier:ok
						Constant:1
				ExpressionStatement:ndfltok = 1
					AssignmentExpression:ndfltok = 1
						Identifier:ndfltok
						Constant:1
				ExpressionStatement:++p
					UnaryExpression:++p
						IncDec:++
						Identifier:p
				WhileStatement:while (*p != ';')
					Condition:*p != ';'
						EqualityExpression:*p != ';'
							UnaryOperationExpression:*p
								UnaryOperator:*
								Identifier:p
							Constant:';'
					CompoundStatement:
						IfStatement:if (*p == '\0')
							Condition:*p == '\0'
								EqualityExpression:*p == '\0'
									UnaryOperationExpression:*p
										UnaryOperator:*
										Identifier:p
									Constant:'\0'
							GotoStatement:goto invalid_select;
								Identifier:invalid_select
						IfStatement:if (! ok)
							Condition:! ok
								UnaryOperationExpression:! ok
									UnaryOperator:!
									Identifier:ok
							CompoundStatement:
								ExpressionStatement:++p
									UnaryExpression:++p
										IncDec:++
										Identifier:p
								ContinueStatement:continue;
						ExpressionStatement:this_arg = p
							AssignmentExpression:this_arg = p
								Identifier:this_arg
								Identifier:p
						WhileStatement:while (*p != ' ' && *p != ';')
							Condition:*p != ' ' && *p != ';'
								AndExpression:*p != ' ' && *p != ';'
									EqualityExpression:*p != ' '
										UnaryOperationExpression:*p
											UnaryOperator:*
											Identifier:p
										Constant:' '
									EqualityExpression:*p != ';'
										UnaryOperationExpression:*p
											UnaryOperator:*
											Identifier:p
										Constant:';'
							CompoundStatement:
								IfStatement:if (*p == '\0')
									Condition:*p == '\0'
										EqualityExpression:*p == '\0'
											UnaryOperationExpression:*p
												UnaryOperator:*
												Identifier:p
											Constant:'\0'
									GotoStatement:goto invalid_select;
										Identifier:invalid_select
								ExpressionStatement:++p
									UnaryExpression:++p
										IncDec:++
										Identifier:p
						IfStatement:if (*this_arg != '!')
							Condition:*this_arg != '!'
								EqualityExpression:*this_arg != '!'
									UnaryOperationExpression:*this_arg
										UnaryOperator:*
										Identifier:this_arg
									Constant:'!'
							ExpressionStatement:not_arg = 0
								AssignmentExpression:not_arg = 0
									Identifier:not_arg
									Constant:0
						Statement:/* If this is a default argument, we can just ignore it.\t     This is true even if this_arg begins with '!'.  Beginning\t     with '!' does not mean that this argument is necessarily\t     inappropriate for this library: it merely means that\t     there is a more specific library which uses this\t     argument.  If this argument is a default, we need not\t     consider that more specific library.  */
						ExpressionStatement:ok = used_arg (this_arg, p - this_arg)
							AssignmentExpression:ok = used_arg (this_arg, p - this_arg)
								Identifier:ok
								CallExpression:used_arg (this_arg, p - this_arg)
									Callee:used_arg
										Identifier:used_arg
									ArgumentList:this_arg
										Argument:this_arg
											Identifier:this_arg
										Argument:p - this_arg
											AdditiveExpression:p - this_arg
												Identifier:p
												Identifier:this_arg
						IfStatement:if (not_arg)
							Condition:not_arg
								Identifier:not_arg
							ExpressionStatement:ok = ! ok
								AssignmentExpression:ok = ! ok
									Identifier:ok
									UnaryOperationExpression:! ok
										UnaryOperator:!
										Identifier:ok
						IfStatement:if (! ok)
							Condition:! ok
								UnaryOperationExpression:! ok
									UnaryOperator:!
									Identifier:ok
							ExpressionStatement:ndfltok = 0
								AssignmentExpression:ndfltok = 0
									Identifier:ndfltok
									Constant:0
						IfStatement:if (default_arg (this_arg, p - this_arg))
							Condition:default_arg (this_arg, p - this_arg)
								CallExpression:default_arg (this_arg, p - this_arg)
									Callee:default_arg
										Identifier:default_arg
									ArgumentList:this_arg
										Argument:this_arg
											Identifier:this_arg
										Argument:p - this_arg
											AdditiveExpression:p - this_arg
												Identifier:p
												Identifier:this_arg
							ExpressionStatement:ok = 1
								AssignmentExpression:ok = 1
									Identifier:ok
									Constant:1
						IfStatement:if (*p == ' ')
							Condition:*p == ' '
								EqualityExpression:*p == ' '
									UnaryOperationExpression:*p
										UnaryOperator:*
										Identifier:p
									Constant:' '
							ExpressionStatement:++p
								UnaryExpression:++p
									IncDec:++
									Identifier:p
				IfStatement:if (ok && first)
					Condition:ok && first
						AndExpression:ok && first
							Identifier:ok
							Identifier:first
					CompoundStatement:
						IfStatement:if (this_path_len != 1\t      || this_path[0] != '.')
							Condition:this_path_len != 1\t      || this_path[0] != '.'
								OrExpression:this_path_len != 1\t      || this_path[0] != '.'
									EqualityExpression:this_path_len != 1
										Identifier:this_path_len
										Constant:1
									EqualityExpression:this_path[0] != '.'
										ArrayIndexing:this_path[0]
											Identifier:this_path
											Constant:0
										Constant:'.'
							CompoundStatement:
								IdentifierDeclStatement:char *new_multilib_dir = XNEWVEC (char, this_path_len + 1);
									IdentifierDecl:*new_multilib_dir = XNEWVEC (char, this_path_len + 1)
										IdentifierDeclType:char *
										Identifier:new_multilib_dir
										AssignmentExpression:*new_multilib_dir = XNEWVEC (char, this_path_len + 1)
											Identifier:new_multilib_dir
											CallExpression:XNEWVEC (char, this_path_len + 1)
												Callee:XNEWVEC
													Identifier:XNEWVEC
												ArgumentList:char
													Argument:char
														Identifier:char
													Argument:this_path_len + 1
														AdditiveExpression:this_path_len + 1
															Identifier:this_path_len
															Constant:1
								IdentifierDeclStatement:char *q;
									IdentifierDecl:*q
										IdentifierDeclType:char *
										Identifier:q
								ExpressionStatement:strncpy (new_multilib_dir, this_path, this_path_len)
									CallExpression:strncpy (new_multilib_dir, this_path, this_path_len)
										Callee:strncpy
											Identifier:strncpy
										ArgumentList:new_multilib_dir
											Argument:new_multilib_dir
												Identifier:new_multilib_dir
											Argument:this_path
												Identifier:this_path
											Argument:this_path_len
												Identifier:this_path_len
								ExpressionStatement:new_multilib_dir[this_path_len] = '\0'
									AssignmentExpression:new_multilib_dir[this_path_len] = '\0'
										ArrayIndexing:new_multilib_dir[this_path_len]
											Identifier:new_multilib_dir
											Identifier:this_path_len
										Constant:'\0'
								ExpressionStatement:q = strchr (new_multilib_dir, ':')
									AssignmentExpression:q = strchr (new_multilib_dir, ':')
										Identifier:q
										CallExpression:strchr (new_multilib_dir, ':')
											Callee:strchr
												Identifier:strchr
											ArgumentList:new_multilib_dir
												Argument:new_multilib_dir
													Identifier:new_multilib_dir
												Argument:':'
													Constant:':'
								IfStatement:if (q != NULL)
									Condition:q != NULL
										EqualityExpression:q != NULL
											Identifier:q
											Identifier:NULL
									ExpressionStatement:*q = '\0'
										AssignmentExpression:*q = '\0'
											UnaryOperationExpression:*q
												UnaryOperator:*
												Identifier:q
											Constant:'\0'
								ExpressionStatement:multilib_dir = new_multilib_dir
									AssignmentExpression:multilib_dir = new_multilib_dir
										Identifier:multilib_dir
										Identifier:new_multilib_dir
						ExpressionStatement:first = 0
							AssignmentExpression:first = 0
								Identifier:first
								Constant:0
				IfStatement:if (ndfltok)
					Condition:ndfltok
						Identifier:ndfltok
					CompoundStatement:
						IdentifierDeclStatement:const char *q = this_path, *end = this_path + this_path_len;
							IdentifierDecl:*q = this_path
								IdentifierDeclType:const char *
								Identifier:q
								AssignmentExpression:*q = this_path
									Identifier:q
									Identifier:this_path
							IdentifierDecl:*end = this_path + this_path_len
								IdentifierDeclType:const char *
								Identifier:end
								AssignmentExpression:*end = this_path + this_path_len
									Identifier:end
									AdditiveExpression:this_path + this_path_len
										Identifier:this_path
										Identifier:this_path_len
						WhileStatement:while (q < end && *q != ':')
							Condition:q < end && *q != ':'
								AndExpression:q < end && *q != ':'
									RelationalExpression:q < end
										Identifier:q
										Identifier:end
									EqualityExpression:*q != ':'
										UnaryOperationExpression:*q
											UnaryOperator:*
											Identifier:q
										Constant:':'
							ExpressionStatement:q++
								PostIncDecOperationExpression:q++
									Identifier:q
									IncDec:++
						IfStatement:if (q < end)
							Condition:q < end
								RelationalExpression:q < end
									Identifier:q
									Identifier:end
							CompoundStatement:
								IdentifierDeclStatement:const char *q2 = q + 1, *ml_end = end;
									IdentifierDecl:*q2 = q + 1
										IdentifierDeclType:const char *
										Identifier:q2
										AssignmentExpression:*q2 = q + 1
											Identifier:q2
											AdditiveExpression:q + 1
												Identifier:q
												Constant:1
									IdentifierDecl:*ml_end = end
										IdentifierDeclType:const char *
										Identifier:ml_end
										AssignmentExpression:*ml_end = end
											Identifier:ml_end
											Identifier:end
								IdentifierDeclStatement:char *new_multilib_os_dir;
									IdentifierDecl:*new_multilib_os_dir
										IdentifierDeclType:char *
										Identifier:new_multilib_os_dir
								WhileStatement:while (q2 < end && *q2 != ':')
									Condition:q2 < end && *q2 != ':'
										AndExpression:q2 < end && *q2 != ':'
											RelationalExpression:q2 < end
												Identifier:q2
												Identifier:end
											EqualityExpression:*q2 != ':'
												UnaryOperationExpression:*q2
													UnaryOperator:*
													Identifier:q2
												Constant:':'
									ExpressionStatement:q2++
										PostIncDecOperationExpression:q2++
											Identifier:q2
											IncDec:++
								IfStatement:if (*q2 == ':')
									Condition:*q2 == ':'
										EqualityExpression:*q2 == ':'
											UnaryOperationExpression:*q2
												UnaryOperator:*
												Identifier:q2
											Constant:':'
									ExpressionStatement:ml_end = q2
										AssignmentExpression:ml_end = q2
											Identifier:ml_end
											Identifier:q2
								IfStatement:if (ml_end - q == 1)
									Condition:ml_end - q == 1
										EqualityExpression:ml_end - q == 1
											AdditiveExpression:ml_end - q
												Identifier:ml_end
												Identifier:q
											Constant:1
									ExpressionStatement:multilib_os_dir = xstrdup (".")
										AssignmentExpression:multilib_os_dir = xstrdup (".")
											Identifier:multilib_os_dir
											CallExpression:xstrdup (".")
												Callee:xstrdup
													Identifier:xstrdup
												ArgumentList:"."
													Argument:"."
														Constant:"."
								IfStatement:if (q2 < end && *q2 == ':')
									Condition:q2 < end && *q2 == ':'
										AndExpression:q2 < end && *q2 == ':'
											RelationalExpression:q2 < end
												Identifier:q2
												Identifier:end
											EqualityExpression:*q2 == ':'
												UnaryOperationExpression:*q2
													UnaryOperator:*
													Identifier:q2
												Constant:':'
									CompoundStatement:
										IdentifierDeclStatement:char *new_multiarch_dir = XNEWVEC (char, end - q2);
											IdentifierDecl:*new_multiarch_dir = XNEWVEC (char, end - q2)
												IdentifierDeclType:char *
												Identifier:new_multiarch_dir
												AssignmentExpression:*new_multiarch_dir = XNEWVEC (char, end - q2)
													Identifier:new_multiarch_dir
													CallExpression:XNEWVEC (char, end - q2)
														Callee:XNEWVEC
															Identifier:XNEWVEC
														ArgumentList:char
															Argument:char
																Identifier:char
															Argument:end - q2
																AdditiveExpression:end - q2
																	Identifier:end
																	Identifier:q2
										ExpressionStatement:memcpy (new_multiarch_dir, q2 + 1, end - q2 - 1)
											CallExpression:memcpy (new_multiarch_dir, q2 + 1, end - q2 - 1)
												Callee:memcpy
													Identifier:memcpy
												ArgumentList:new_multiarch_dir
													Argument:new_multiarch_dir
														Identifier:new_multiarch_dir
													Argument:q2 + 1
														AdditiveExpression:q2 + 1
															Identifier:q2
															Constant:1
													Argument:end - q2 - 1
														AdditiveExpression:end - q2 - 1
															Identifier:end
															AdditiveExpression:q2 - 1
																Identifier:q2
																Constant:1
										ExpressionStatement:new_multiarch_dir[end - q2 - 1] = '\0'
											AssignmentExpression:new_multiarch_dir[end - q2 - 1] = '\0'
												ArrayIndexing:new_multiarch_dir[end - q2 - 1]
													Identifier:new_multiarch_dir
													AdditiveExpression:end - q2 - 1
														Identifier:end
														AdditiveExpression:q2 - 1
															Identifier:q2
															Constant:1
												Constant:'\0'
										ExpressionStatement:multiarch_dir = new_multiarch_dir
											AssignmentExpression:multiarch_dir = new_multiarch_dir
												Identifier:multiarch_dir
												Identifier:new_multiarch_dir
								BreakStatement:break;
				ExpressionStatement:++p
					UnaryExpression:++p
						IncDec:++
						Identifier:p
		IfStatement:if (multilib_dir == NULL && multilib_os_dir != NULL      && strcmp (multilib_os_dir, ".") == 0)
			Condition:multilib_dir == NULL && multilib_os_dir != NULL      && strcmp (multilib_os_dir, ".") == 0
				AndExpression:multilib_dir == NULL && multilib_os_dir != NULL      && strcmp (multilib_os_dir, ".") == 0
					EqualityExpression:multilib_dir == NULL
						Identifier:multilib_dir
						Identifier:NULL
					AndExpression:multilib_os_dir != NULL      && strcmp (multilib_os_dir, ".") == 0
						EqualityExpression:multilib_os_dir != NULL
							Identifier:multilib_os_dir
							Identifier:NULL
						EqualityExpression:strcmp (multilib_os_dir, ".") == 0
							CallExpression:strcmp (multilib_os_dir, ".")
								Callee:strcmp
									Identifier:strcmp
								ArgumentList:multilib_os_dir
									Argument:multilib_os_dir
										Identifier:multilib_os_dir
									Argument:"."
										Constant:"."
							Constant:0
			CompoundStatement:
				Statement:free
				Statement:(
				Statement:CONST_CAST
				Statement:(
				Statement:char
				Statement:*
				Statement:,
				Statement:multilib_os_dir
				Statement:)
				Statement:)
				ExpressionStatement:
				ExpressionStatement:multilib_os_dir = NULL
					AssignmentExpression:multilib_os_dir = NULL
						Identifier:multilib_os_dir
						Identifier:NULL
	Identifier:voidset_multilib_dir
	ParameterList:
FunctionDef:voidprint_multilib_info ()
	CompoundStatement:
		IdentifierDeclStatement:const char *p = multilib_select;
			IdentifierDecl:*p = multilib_select
				IdentifierDeclType:const char *
				Identifier:p
				AssignmentExpression:*p = multilib_select
					Identifier:p
					Identifier:multilib_select
		IdentifierDeclStatement:const char *last_path = 0, *this_path;
			IdentifierDecl:*last_path = 0
				IdentifierDeclType:const char *
				Identifier:last_path
				AssignmentExpression:*last_path = 0
					Identifier:last_path
					Constant:0
			IdentifierDecl:*this_path
				IdentifierDeclType:const char *
				Identifier:this_path
		IdentifierDeclStatement:int skip;
			IdentifierDecl:skip
				IdentifierDeclType:int
				Identifier:skip
		IdentifierDeclStatement:unsigned int last_path_len = 0;
			IdentifierDecl:last_path_len = 0
				IdentifierDeclType:unsigned int
				Identifier:last_path_len
				AssignmentExpression:last_path_len = 0
					Identifier:last_path_len
					Constant:0
		WhileStatement:while (*p != '\0')
			Condition:*p != '\0'
				EqualityExpression:*p != '\0'
					UnaryOperationExpression:*p
						UnaryOperator:*
						Identifier:p
					Constant:'\0'
			CompoundStatement:
				ExpressionStatement:skip = 0
					AssignmentExpression:skip = 0
						Identifier:skip
						Constant:0
				Statement:/* Ignore newlines.  */
				IfStatement:if (*p == '\n')
					Condition:*p == '\n'
						EqualityExpression:*p == '\n'
							UnaryOperationExpression:*p
								UnaryOperator:*
								Identifier:p
							Constant:'\n'
					CompoundStatement:
						ExpressionStatement:++p
							UnaryExpression:++p
								IncDec:++
								Identifier:p
						ContinueStatement:continue;
				Statement:/* Get the initial path.  */
				ExpressionStatement:this_path = p
					AssignmentExpression:this_path = p
						Identifier:this_path
						Identifier:p
				WhileStatement:while (*p != ' ')
					Condition:*p != ' '
						EqualityExpression:*p != ' '
							UnaryOperationExpression:*p
								UnaryOperator:*
								Identifier:p
							Constant:' '
					CompoundStatement:
						IfStatement:if (*p == '\0')
							Condition:*p == '\0'
								EqualityExpression:*p == '\0'
									UnaryOperationExpression:*p
										UnaryOperator:*
										Identifier:p
									Constant:'\0'
							CompoundStatement:
								Label:invalid_select:
									Identifier:invalid_select
								ExpressionStatement:fatal_error (input_location,\t\t\t   "multilib select %qs is invalid", multilib_select)
									CallExpression:fatal_error (input_location,\t\t\t   "multilib select %qs is invalid", multilib_select)
										Callee:fatal_error
											Identifier:fatal_error
										ArgumentList:input_location
											Argument:input_location
												Identifier:input_location
											Argument:"multilib select %qs is invalid"
												Constant:"multilib select %qs is invalid"
											Argument:multilib_select
												Identifier:multilib_select
						ExpressionStatement:++p
							UnaryExpression:++p
								IncDec:++
								Identifier:p
				Statement:/* When --disable-multilib was used but target defines\t MULTILIB_OSDIRNAMES, entries starting with .: (and not starting         with .:: for multiarch configurations) are there just to find         multilib_os_dir, so skip them from output.  */
				IfStatement:if (this_path[0] == '.' && this_path[1] == ':' && this_path[2] != ':')
					Condition:this_path[0] == '.' && this_path[1] == ':' && this_path[2] != ':'
						AndExpression:this_path[0] == '.' && this_path[1] == ':' && this_path[2] != ':'
							EqualityExpression:this_path[0] == '.'
								ArrayIndexing:this_path[0]
									Identifier:this_path
									Constant:0
								Constant:'.'
							AndExpression:this_path[1] == ':' && this_path[2] != ':'
								EqualityExpression:this_path[1] == ':'
									ArrayIndexing:this_path[1]
										Identifier:this_path
										Constant:1
									Constant:':'
								EqualityExpression:this_path[2] != ':'
									ArrayIndexing:this_path[2]
										Identifier:this_path
										Constant:2
									Constant:':'
					ExpressionStatement:skip = 1
						AssignmentExpression:skip = 1
							Identifier:skip
							Constant:1
				Statement:/* Check for matches with the multilib_exclusions. We don't bother         with the '!' in either list. If any of the exclusion rules match         all of its options with the select rule, we skip it.  */
				CompoundStatement:
					IdentifierDeclStatement:const char *e = multilib_exclusions;
						IdentifierDecl:*e = multilib_exclusions
							IdentifierDeclType:const char *
							Identifier:e
							AssignmentExpression:*e = multilib_exclusions
								Identifier:e
								Identifier:multilib_exclusions
					IdentifierDeclStatement:const char *this_arg;
						IdentifierDecl:*this_arg
							IdentifierDeclType:const char *
							Identifier:this_arg
					WhileStatement:while (*e != '\0')
						Condition:*e != '\0'
							EqualityExpression:*e != '\0'
								UnaryOperationExpression:*e
									UnaryOperator:*
									Identifier:e
								Constant:'\0'
						CompoundStatement:
							IdentifierDeclStatement:int m = 1;
								IdentifierDecl:m = 1
									IdentifierDeclType:int
									Identifier:m
									AssignmentExpression:m = 1
										Identifier:m
										Constant:1
							Statement:/* Ignore newlines.  */
							IfStatement:if (*e == '\n')
								Condition:*e == '\n'
									EqualityExpression:*e == '\n'
										UnaryOperationExpression:*e
											UnaryOperator:*
											Identifier:e
										Constant:'\n'
								CompoundStatement:
									ExpressionStatement:++e
										UnaryExpression:++e
											IncDec:++
											Identifier:e
									ContinueStatement:continue;
							Statement:/* Check the arguments.  */
							WhileStatement:while (*e != ';')
								Condition:*e != ';'
									EqualityExpression:*e != ';'
										UnaryOperationExpression:*e
											UnaryOperator:*
											Identifier:e
										Constant:';'
								CompoundStatement:
									IdentifierDeclStatement:const char *q;
										IdentifierDecl:*q
											IdentifierDeclType:const char *
											Identifier:q
									IdentifierDeclStatement:int mp = 0;
										IdentifierDecl:mp = 0
											IdentifierDeclType:int
											Identifier:mp
											AssignmentExpression:mp = 0
												Identifier:mp
												Constant:0
									IfStatement:if (*e == '\0')
										Condition:*e == '\0'
											EqualityExpression:*e == '\0'
												UnaryOperationExpression:*e
													UnaryOperator:*
													Identifier:e
												Constant:'\0'
										CompoundStatement:
											Label:invalid_exclusion:
												Identifier:invalid_exclusion
											ExpressionStatement:fatal_error (input_location,\t\t\t\t "multilib exclusion %qs is invalid",\t\t\t\t multilib_exclusions)
												CallExpression:fatal_error (input_location,\t\t\t\t "multilib exclusion %qs is invalid",\t\t\t\t multilib_exclusions)
													Callee:fatal_error
														Identifier:fatal_error
													ArgumentList:input_location
														Argument:input_location
															Identifier:input_location
														Argument:"multilib exclusion %qs is invalid"
															Constant:"multilib exclusion %qs is invalid"
														Argument:multilib_exclusions
															Identifier:multilib_exclusions
									IfStatement:if (! m)
										Condition:! m
											UnaryOperationExpression:! m
												UnaryOperator:!
												Identifier:m
										CompoundStatement:
											ExpressionStatement:++e
												UnaryExpression:++e
													IncDec:++
													Identifier:e
											ContinueStatement:continue;
									ExpressionStatement:this_arg = e
										AssignmentExpression:this_arg = e
											Identifier:this_arg
											Identifier:e
									WhileStatement:while (*e != ' ' && *e != ';')
										Condition:*e != ' ' && *e != ';'
											AndExpression:*e != ' ' && *e != ';'
												EqualityExpression:*e != ' '
													UnaryOperationExpression:*e
														UnaryOperator:*
														Identifier:e
													Constant:' '
												EqualityExpression:*e != ';'
													UnaryOperationExpression:*e
														UnaryOperator:*
														Identifier:e
													Constant:';'
										CompoundStatement:
											IfStatement:if (*e == '\0')
												Condition:*e == '\0'
													EqualityExpression:*e == '\0'
														UnaryOperationExpression:*e
															UnaryOperator:*
															Identifier:e
														Constant:'\0'
												GotoStatement:goto invalid_exclusion;
													Identifier:invalid_exclusion
											ExpressionStatement:++e
												UnaryExpression:++e
													IncDec:++
													Identifier:e
									ExpressionStatement:q = p + 1
										AssignmentExpression:q = p + 1
											Identifier:q
											AdditiveExpression:p + 1
												Identifier:p
												Constant:1
									WhileStatement:while (*q != ';')
										Condition:*q != ';'
											EqualityExpression:*q != ';'
												UnaryOperationExpression:*q
													UnaryOperator:*
													Identifier:q
												Constant:';'
										CompoundStatement:
											IdentifierDeclStatement:const char *arg;
												IdentifierDecl:*arg
													IdentifierDeclType:const char *
													Identifier:arg
											IdentifierDeclStatement:int len = e - this_arg;
												IdentifierDecl:len = e - this_arg
													IdentifierDeclType:int
													Identifier:len
													AssignmentExpression:len = e - this_arg
														Identifier:len
														AdditiveExpression:e - this_arg
															Identifier:e
															Identifier:this_arg
											IfStatement:if (*q == '\0')
												Condition:*q == '\0'
													EqualityExpression:*q == '\0'
														UnaryOperationExpression:*q
															UnaryOperator:*
															Identifier:q
														Constant:'\0'
												GotoStatement:goto invalid_select;
													Identifier:invalid_select
											ExpressionStatement:arg = q
												AssignmentExpression:arg = q
													Identifier:arg
													Identifier:q
											WhileStatement:while (*q != ' ' && *q != ';')
												Condition:*q != ' ' && *q != ';'
													AndExpression:*q != ' ' && *q != ';'
														EqualityExpression:*q != ' '
															UnaryOperationExpression:*q
																UnaryOperator:*
																Identifier:q
															Constant:' '
														EqualityExpression:*q != ';'
															UnaryOperationExpression:*q
																UnaryOperator:*
																Identifier:q
															Constant:';'
												CompoundStatement:
													IfStatement:if (*q == '\0')
														Condition:*q == '\0'
															EqualityExpression:*q == '\0'
																UnaryOperationExpression:*q
																	UnaryOperator:*
																	Identifier:q
																Constant:'\0'
														GotoStatement:goto invalid_select;
															Identifier:invalid_select
													ExpressionStatement:++q
														UnaryExpression:++q
															IncDec:++
															Identifier:q
											IfStatement:if (! strncmp (arg, this_arg,\t\t\t\t   (len < q - arg) ? q - arg : len)\t\t\t|| default_arg (this_arg, e - this_arg))
												Condition:! strncmp (arg, this_arg,\t\t\t\t   (len < q - arg) ? q - arg : len)\t\t\t|| default_arg (this_arg, e - this_arg)
													OrExpression:! strncmp (arg, this_arg,\t\t\t\t   (len < q - arg) ? q - arg : len)\t\t\t|| default_arg (this_arg, e - this_arg)
														UnaryOperationExpression:! strncmp (arg, this_arg,\t\t\t\t   (len < q - arg) ? q - arg : len)
															UnaryOperator:!
															CallExpression:strncmp (arg, this_arg,\t\t\t\t   (len < q - arg) ? q - arg : len)
																Callee:strncmp
																	Identifier:strncmp
																ArgumentList:arg
																	Argument:arg
																		Identifier:arg
																	Argument:this_arg
																		Identifier:this_arg
																	Argument:(len < q - arg) ? q - arg : len
																		ConditionalExpression:(len < q - arg) ? q - arg : len
																			Condition:len < q - arg
																				RelationalExpression:len < q - arg
																					Identifier:len
																					AdditiveExpression:q - arg
																						Identifier:q
																						Identifier:arg
																			AdditiveExpression:q - arg
																				Identifier:q
																				Identifier:arg
																			Identifier:len
														CallExpression:default_arg (this_arg, e - this_arg)
															Callee:default_arg
																Identifier:default_arg
															ArgumentList:this_arg
																Argument:this_arg
																	Identifier:this_arg
																Argument:e - this_arg
																	AdditiveExpression:e - this_arg
																		Identifier:e
																		Identifier:this_arg
												CompoundStatement:
													ExpressionStatement:mp = 1
														AssignmentExpression:mp = 1
															Identifier:mp
															Constant:1
													BreakStatement:break;
											IfStatement:if (*q == ' ')
												Condition:*q == ' '
													EqualityExpression:*q == ' '
														UnaryOperationExpression:*q
															UnaryOperator:*
															Identifier:q
														Constant:' '
												ExpressionStatement:++q
													UnaryExpression:++q
														IncDec:++
														Identifier:q
									IfStatement:if (! mp)
										Condition:! mp
											UnaryOperationExpression:! mp
												UnaryOperator:!
												Identifier:mp
										ExpressionStatement:m = 0
											AssignmentExpression:m = 0
												Identifier:m
												Constant:0
									IfStatement:if (*e == ' ')
										Condition:*e == ' '
											EqualityExpression:*e == ' '
												UnaryOperationExpression:*e
													UnaryOperator:*
													Identifier:e
												Constant:' '
										ExpressionStatement:++e
											UnaryExpression:++e
												IncDec:++
												Identifier:e
							IfStatement:if (m)
								Condition:m
									Identifier:m
								CompoundStatement:
									ExpressionStatement:skip = 1
										AssignmentExpression:skip = 1
											Identifier:skip
											Constant:1
									BreakStatement:break;
							IfStatement:if (*e != '\0')
								Condition:*e != '\0'
									EqualityExpression:*e != '\0'
										UnaryOperationExpression:*e
											UnaryOperator:*
											Identifier:e
										Constant:'\0'
								ExpressionStatement:++e
									UnaryExpression:++e
										IncDec:++
										Identifier:e
				IfStatement:if (! skip)
					Condition:! skip
						UnaryOperationExpression:! skip
							UnaryOperator:!
							Identifier:skip
					CompoundStatement:
						Statement:/* If this is a duplicate, skip it.  */
						ExpressionStatement:skip = (last_path != 0\t\t  && (unsigned int) (p - this_path) == last_path_len\t\t  && ! filename_ncmp (last_path, this_path, last_path_len))
							AssignmentExpression:skip = (last_path != 0\t\t  && (unsigned int) (p - this_path) == last_path_len\t\t  && ! filename_ncmp (last_path, this_path, last_path_len))
								Identifier:skip
								AndExpression:last_path != 0\t\t  && (unsigned int) (p - this_path) == last_path_len\t\t  && ! filename_ncmp (last_path, this_path, last_path_len)
									EqualityExpression:last_path != 0
										Identifier:last_path
										Constant:0
									AndExpression:(unsigned int) (p - this_path) == last_path_len\t\t  && ! filename_ncmp (last_path, this_path, last_path_len)
										EqualityExpression:(unsigned int) (p - this_path) == last_path_len
											CastExpression:(unsigned int) (p - this_path)
												CastTarget:unsigned int
												AdditiveExpression:p - this_path
													Identifier:p
													Identifier:this_path
											Identifier:last_path_len
										UnaryOperationExpression:! filename_ncmp (last_path, this_path, last_path_len)
											UnaryOperator:!
											CallExpression:filename_ncmp (last_path, this_path, last_path_len)
												Callee:filename_ncmp
													Identifier:filename_ncmp
												ArgumentList:last_path
													Argument:last_path
														Identifier:last_path
													Argument:this_path
														Identifier:this_path
													Argument:last_path_len
														Identifier:last_path_len
						ExpressionStatement:last_path = this_path
							AssignmentExpression:last_path = this_path
								Identifier:last_path
								Identifier:this_path
						ExpressionStatement:last_path_len = p - this_path
							AssignmentExpression:last_path_len = p - this_path
								Identifier:last_path_len
								AdditiveExpression:p - this_path
									Identifier:p
									Identifier:this_path
				Statement:/* If this directory requires any default arguments, we can skip\t it.  We will already have printed a directory identical to\t this one which does not require that default argument.  */
				IfStatement:if (! skip)
					Condition:! skip
						UnaryOperationExpression:! skip
							UnaryOperator:!
							Identifier:skip
					CompoundStatement:
						IdentifierDeclStatement:const char *q;
							IdentifierDecl:*q
								IdentifierDeclType:const char *
								Identifier:q
						ExpressionStatement:q = p + 1
							AssignmentExpression:q = p + 1
								Identifier:q
								AdditiveExpression:p + 1
									Identifier:p
									Constant:1
						WhileStatement:while (*q != ';')
							Condition:*q != ';'
								EqualityExpression:*q != ';'
									UnaryOperationExpression:*q
										UnaryOperator:*
										Identifier:q
									Constant:';'
							CompoundStatement:
								IdentifierDeclStatement:const char *arg;
									IdentifierDecl:*arg
										IdentifierDeclType:const char *
										Identifier:arg
								IfStatement:if (*q == '\0')
									Condition:*q == '\0'
										EqualityExpression:*q == '\0'
											UnaryOperationExpression:*q
												UnaryOperator:*
												Identifier:q
											Constant:'\0'
									GotoStatement:goto invalid_select;
										Identifier:invalid_select
								IfStatement:if (*q == '!')
									Condition:*q == '!'
										EqualityExpression:*q == '!'
											UnaryOperationExpression:*q
												UnaryOperator:*
												Identifier:q
											Constant:'!'
									ExpressionStatement:arg = NULL
										AssignmentExpression:arg = NULL
											Identifier:arg
											Identifier:NULL
								WhileStatement:while (*q != ' ' && *q != ';')
									Condition:*q != ' ' && *q != ';'
										AndExpression:*q != ' ' && *q != ';'
											EqualityExpression:*q != ' '
												UnaryOperationExpression:*q
													UnaryOperator:*
													Identifier:q
												Constant:' '
											EqualityExpression:*q != ';'
												UnaryOperationExpression:*q
													UnaryOperator:*
													Identifier:q
												Constant:';'
									CompoundStatement:
										IfStatement:if (*q == '\0')
											Condition:*q == '\0'
												EqualityExpression:*q == '\0'
													UnaryOperationExpression:*q
														UnaryOperator:*
														Identifier:q
													Constant:'\0'
											GotoStatement:goto invalid_select;
												Identifier:invalid_select
										ExpressionStatement:++q
											UnaryExpression:++q
												IncDec:++
												Identifier:q
								IfStatement:if (arg != NULL\t\t  && default_arg (arg, q - arg))
									Condition:arg != NULL\t\t  && default_arg (arg, q - arg)
										AndExpression:arg != NULL\t\t  && default_arg (arg, q - arg)
											EqualityExpression:arg != NULL
												Identifier:arg
												Identifier:NULL
											CallExpression:default_arg (arg, q - arg)
												Callee:default_arg
													Identifier:default_arg
												ArgumentList:arg
													Argument:arg
														Identifier:arg
													Argument:q - arg
														AdditiveExpression:q - arg
															Identifier:q
															Identifier:arg
									CompoundStatement:
										ExpressionStatement:skip = 1
											AssignmentExpression:skip = 1
												Identifier:skip
												Constant:1
										BreakStatement:break;
								IfStatement:if (*q == ' ')
									Condition:*q == ' '
										EqualityExpression:*q == ' '
											UnaryOperationExpression:*q
												UnaryOperator:*
												Identifier:q
											Constant:' '
									ExpressionStatement:++q
										UnaryExpression:++q
											IncDec:++
											Identifier:q
				IfStatement:if (! skip)
					Condition:! skip
						UnaryOperationExpression:! skip
							UnaryOperator:!
							Identifier:skip
					CompoundStatement:
						IdentifierDeclStatement:const char *p1;
							IdentifierDecl:*p1
								IdentifierDeclType:const char *
								Identifier:p1
						ForStatement:for (p1 = last_path; p1 < p && *p1 != ':'; p1++)
							ForInit:p1 = last_path;
								AssignmentExpression:p1 = last_path
									Identifier:p1
									Identifier:last_path
							Condition:p1 < p && *p1 != ':'
								AndExpression:p1 < p && *p1 != ':'
									RelationalExpression:p1 < p
										Identifier:p1
										Identifier:p
									EqualityExpression:*p1 != ':'
										UnaryOperationExpression:*p1
											UnaryOperator:*
											Identifier:p1
										Constant:':'
							PostIncDecOperationExpression:p1++
								Identifier:p1
								IncDec:++
							ExpressionStatement:putchar (*p1)
								CallExpression:putchar (*p1)
									Callee:putchar
										Identifier:putchar
									ArgumentList:*p1
										Argument:*p1
											UnaryOperationExpression:*p1
												UnaryOperator:*
												Identifier:p1
						ExpressionStatement:putchar (';')
							CallExpression:putchar (';')
								Callee:putchar
									Identifier:putchar
								ArgumentList:';'
									Argument:';'
										Constant:';'
				ExpressionStatement:++p
					UnaryExpression:++p
						IncDec:++
						Identifier:p
				WhileStatement:while (*p != ';')
					Condition:*p != ';'
						EqualityExpression:*p != ';'
							UnaryOperationExpression:*p
								UnaryOperator:*
								Identifier:p
							Constant:';'
					CompoundStatement:
						IdentifierDeclStatement:int use_arg;
							IdentifierDecl:use_arg
								IdentifierDeclType:int
								Identifier:use_arg
						IfStatement:if (*p == '\0')
							Condition:*p == '\0'
								EqualityExpression:*p == '\0'
									UnaryOperationExpression:*p
										UnaryOperator:*
										Identifier:p
									Constant:'\0'
							GotoStatement:goto invalid_select;
								Identifier:invalid_select
						IfStatement:if (skip)
							Condition:skip
								Identifier:skip
							CompoundStatement:
								ExpressionStatement:++p
									UnaryExpression:++p
										IncDec:++
										Identifier:p
								ContinueStatement:continue;
						ExpressionStatement:use_arg = *p != '!'
							AssignmentExpression:use_arg = *p != '!'
								Identifier:use_arg
								EqualityExpression:*p != '!'
									UnaryOperationExpression:*p
										UnaryOperator:*
										Identifier:p
									Constant:'!'
						IfStatement:if (use_arg)
							Condition:use_arg
								Identifier:use_arg
							ExpressionStatement:putchar ('@')
								CallExpression:putchar ('@')
									Callee:putchar
										Identifier:putchar
									ArgumentList:'@'
										Argument:'@'
											Constant:'@'
						WhileStatement:while (*p != ' ' && *p != ';')
							Condition:*p != ' ' && *p != ';'
								AndExpression:*p != ' ' && *p != ';'
									EqualityExpression:*p != ' '
										UnaryOperationExpression:*p
											UnaryOperator:*
											Identifier:p
										Constant:' '
									EqualityExpression:*p != ';'
										UnaryOperationExpression:*p
											UnaryOperator:*
											Identifier:p
										Constant:';'
							CompoundStatement:
								IfStatement:if (*p == '\0')
									Condition:*p == '\0'
										EqualityExpression:*p == '\0'
											UnaryOperationExpression:*p
												UnaryOperator:*
												Identifier:p
											Constant:'\0'
									GotoStatement:goto invalid_select;
										Identifier:invalid_select
								IfStatement:if (use_arg)
									Condition:use_arg
										Identifier:use_arg
									ExpressionStatement:putchar (*p)
										CallExpression:putchar (*p)
											Callee:putchar
												Identifier:putchar
											ArgumentList:*p
												Argument:*p
													UnaryOperationExpression:*p
														UnaryOperator:*
														Identifier:p
								ExpressionStatement:++p
									UnaryExpression:++p
										IncDec:++
										Identifier:p
						IfStatement:if (*p == ' ')
							Condition:*p == ' '
								EqualityExpression:*p == ' '
									UnaryOperationExpression:*p
										UnaryOperator:*
										Identifier:p
									Constant:' '
							ExpressionStatement:++p
								UnaryExpression:++p
									IncDec:++
									Identifier:p
				IfStatement:if (! skip)
					Condition:! skip
						UnaryOperationExpression:! skip
							UnaryOperator:!
							Identifier:skip
					CompoundStatement:
						Statement:/* If there are extra options, print them now.  */
						IfStatement:if (multilib_extra && *multilib_extra)
							Condition:multilib_extra && *multilib_extra
								AndExpression:multilib_extra && *multilib_extra
									Identifier:multilib_extra
									UnaryOperationExpression:*multilib_extra
										UnaryOperator:*
										Identifier:multilib_extra
							CompoundStatement:
								IdentifierDeclStatement:int print_at = TRUE;
									IdentifierDecl:print_at = TRUE
										IdentifierDeclType:int
										Identifier:print_at
										AssignmentExpression:print_at = TRUE
											Identifier:print_at
											Identifier:TRUE
								IdentifierDeclStatement:const char *q;
									IdentifierDecl:*q
										IdentifierDeclType:const char *
										Identifier:q
								ForStatement:for (q = multilib_extra; *q != '\0'; q++)
									ForInit:q = multilib_extra;
										AssignmentExpression:q = multilib_extra
											Identifier:q
											Identifier:multilib_extra
									Condition:*q != '\0'
										EqualityExpression:*q != '\0'
											UnaryOperationExpression:*q
												UnaryOperator:*
												Identifier:q
											Constant:'\0'
									PostIncDecOperationExpression:q++
										Identifier:q
										IncDec:++
									CompoundStatement:
										IfStatement:if (*q == ' ')
											Condition:*q == ' '
												EqualityExpression:*q == ' '
													UnaryOperationExpression:*q
														UnaryOperator:*
														Identifier:q
													Constant:' '
											ExpressionStatement:print_at = TRUE
												AssignmentExpression:print_at = TRUE
													Identifier:print_at
													Identifier:TRUE
						ExpressionStatement:putchar ('\n')
							CallExpression:putchar ('\n')
								Callee:putchar
									Identifier:putchar
								ArgumentList:'\n'
									Argument:'\n'
										Constant:'\n'
				ExpressionStatement:++p
					UnaryExpression:++p
						IncDec:++
						Identifier:p
	Identifier:voidprint_multilib_info
	ParameterList:
FunctionDef:getenv_spec_function (int argc , const char **argv)
	CompoundStatement:
		IdentifierDeclStatement:const char *value;
			IdentifierDecl:*value
				IdentifierDeclType:const char *
				Identifier:value
		IdentifierDeclStatement:const char *varname;
			IdentifierDecl:*varname
				IdentifierDeclType:const char *
				Identifier:varname
		IdentifierDeclStatement:char *result;
			IdentifierDecl:*result
				IdentifierDeclType:char *
				Identifier:result
		IdentifierDeclStatement:char *ptr;
			IdentifierDecl:*ptr
				IdentifierDeclType:char *
				Identifier:ptr
		IdentifierDeclStatement:size_t len;
			IdentifierDecl:len
				IdentifierDeclType:size_t
				Identifier:len
		IfStatement:if (argc != 2)
			Condition:argc != 2
				EqualityExpression:argc != 2
					Identifier:argc
					Constant:2
			ReturnStatement:return NULL;
				Identifier:NULL
		ExpressionStatement:varname = argv[0]
			AssignmentExpression:varname = argv[0]
				Identifier:varname
				ArrayIndexing:argv[0]
					Identifier:argv
					Constant:0
		ExpressionStatement:value = env.get (varname)
			AssignmentExpression:value = env.get (varname)
				Identifier:value
				CallExpression:env.get (varname)
					Callee:env.get
						MemberAccess:env.get
							Identifier:env
							Identifier:get
					ArgumentList:varname
						Argument:varname
							Identifier:varname
		IfStatement:if (!value && spec_undefvar_allowed)
			Condition:!value && spec_undefvar_allowed
				AndExpression:!value && spec_undefvar_allowed
					UnaryOperationExpression:!value
						UnaryOperator:!
						Identifier:value
					Identifier:spec_undefvar_allowed
			ExpressionStatement:value = varname
				AssignmentExpression:value = varname
					Identifier:value
					Identifier:varname
		IfStatement:if (!value)
			Condition:!value
				UnaryOperationExpression:!value
					UnaryOperator:!
					Identifier:value
			ExpressionStatement:fatal_error (input_location,\t\t "environment variable %qs not defined", varname)
				CallExpression:fatal_error (input_location,\t\t "environment variable %qs not defined", varname)
					Callee:fatal_error
						Identifier:fatal_error
					ArgumentList:input_location
						Argument:input_location
							Identifier:input_location
						Argument:"environment variable %qs not defined"
							Constant:"environment variable %qs not defined"
						Argument:varname
							Identifier:varname
		Statement:/* We have to escape every character of the environment variable so     they are not interpreted as active spec characters.  A     particularly painful case is when we are reading a variable     holding a windows path complete with \ separators.  */
		ExpressionStatement:len = strlen (value) * 2 + strlen (argv[1]) + 1
			AssignmentExpression:len = strlen (value) * 2 + strlen (argv[1]) + 1
				Identifier:len
				AdditiveExpression:strlen (value) * 2 + strlen (argv[1]) + 1
					MultiplicativeExpression:strlen (value) * 2
						CallExpression:strlen (value)
							Callee:strlen
								Identifier:strlen
							ArgumentList:value
								Argument:value
									Identifier:value
						Constant:2
					AdditiveExpression:strlen (argv[1]) + 1
						CallExpression:strlen (argv[1])
							Callee:strlen
								Identifier:strlen
							ArgumentList:argv[1]
								Argument:argv[1]
									ArrayIndexing:argv[1]
										Identifier:argv
										Constant:1
						Constant:1
		ExpressionStatement:result = XNEWVAR (char, len)
			AssignmentExpression:result = XNEWVAR (char, len)
				Identifier:result
				CallExpression:XNEWVAR (char, len)
					Callee:XNEWVAR
						Identifier:XNEWVAR
					ArgumentList:char
						Argument:char
							Identifier:char
						Argument:len
							Identifier:len
		ForStatement:for (ptr = result; *value; ptr += 2)
			ForInit:ptr = result;
				AssignmentExpression:ptr = result
					Identifier:ptr
					Identifier:result
			Condition:*value
				UnaryOperationExpression:*value
					UnaryOperator:*
					Identifier:value
			AssignmentExpression:ptr += 2
				Identifier:ptr
				Constant:2
			CompoundStatement:
				ExpressionStatement:ptr[0] = '\\'
					AssignmentExpression:ptr[0] = '\\'
						ArrayIndexing:ptr[0]
							Identifier:ptr
							Constant:0
						Constant:'\\'
				ExpressionStatement:ptr[1] = *value++
					AssignmentExpression:ptr[1] = *value++
						ArrayIndexing:ptr[1]
							Identifier:ptr
							Constant:1
						UnaryOperationExpression:*value++
							UnaryOperator:*
							PostIncDecOperationExpression:value++
								Identifier:value
								IncDec:++
		ExpressionStatement:strcpy (ptr, argv[1])
			CallExpression:strcpy (ptr, argv[1])
				Callee:strcpy
					Identifier:strcpy
				ArgumentList:ptr
					Argument:ptr
						Identifier:ptr
					Argument:argv[1]
						ArrayIndexing:argv[1]
							Identifier:argv
							Constant:1
		ReturnStatement:return result;
			Identifier:result
	ReturnType:static const char *
	Identifier:getenv_spec_function
	ParameterList:int argc , const char **argv
		Parameter:int argc
			ParameterType:int
			Identifier:argc
		Parameter:const char **argv
			ParameterType:const char * *
			Identifier:argv
FunctionDef:if_exists_spec_function (int argc , const char **argv)
	CompoundStatement:
		Statement:/* Must have only one argument.  */
		IfStatement:if (argc == 1 && IS_ABSOLUTE_PATH (argv[0]) && ! access (argv[0], R_OK))
			Condition:argc == 1 && IS_ABSOLUTE_PATH (argv[0]) && ! access (argv[0], R_OK)
				AndExpression:argc == 1 && IS_ABSOLUTE_PATH (argv[0]) && ! access (argv[0], R_OK)
					EqualityExpression:argc == 1
						Identifier:argc
						Constant:1
					AndExpression:IS_ABSOLUTE_PATH (argv[0]) && ! access (argv[0], R_OK)
						CallExpression:IS_ABSOLUTE_PATH (argv[0])
							Callee:IS_ABSOLUTE_PATH
								Identifier:IS_ABSOLUTE_PATH
							ArgumentList:argv[0]
								Argument:argv[0]
									ArrayIndexing:argv[0]
										Identifier:argv
										Constant:0
						UnaryOperationExpression:! access (argv[0], R_OK)
							UnaryOperator:!
							CallExpression:access (argv[0], R_OK)
								Callee:access
									Identifier:access
								ArgumentList:argv[0]
									Argument:argv[0]
										ArrayIndexing:argv[0]
											Identifier:argv
											Constant:0
									Argument:R_OK
										Identifier:R_OK
			ReturnStatement:return argv[0];
				ArrayIndexing:argv[0]
					Identifier:argv
					Constant:0
		ReturnStatement:return NULL;
			Identifier:NULL
	ReturnType:static const char *
	Identifier:if_exists_spec_function
	ParameterList:int argc , const char **argv
		Parameter:int argc
			ParameterType:int
			Identifier:argc
		Parameter:const char **argv
			ParameterType:const char * *
			Identifier:argv
FunctionDef:if_exists_else_spec_function (int argc , const char **argv)
	CompoundStatement:
		Statement:/* Must have exactly two arguments.  */
		IfStatement:if (argc != 2)
			Condition:argc != 2
				EqualityExpression:argc != 2
					Identifier:argc
					Constant:2
			ReturnStatement:return NULL;
				Identifier:NULL
		IfStatement:if (IS_ABSOLUTE_PATH (argv[0]) && ! access (argv[0], R_OK))
			Condition:IS_ABSOLUTE_PATH (argv[0]) && ! access (argv[0], R_OK)
				AndExpression:IS_ABSOLUTE_PATH (argv[0]) && ! access (argv[0], R_OK)
					CallExpression:IS_ABSOLUTE_PATH (argv[0])
						Callee:IS_ABSOLUTE_PATH
							Identifier:IS_ABSOLUTE_PATH
						ArgumentList:argv[0]
							Argument:argv[0]
								ArrayIndexing:argv[0]
									Identifier:argv
									Constant:0
					UnaryOperationExpression:! access (argv[0], R_OK)
						UnaryOperator:!
						CallExpression:access (argv[0], R_OK)
							Callee:access
								Identifier:access
							ArgumentList:argv[0]
								Argument:argv[0]
									ArrayIndexing:argv[0]
										Identifier:argv
										Constant:0
								Argument:R_OK
									Identifier:R_OK
			ReturnStatement:return argv[0];
				ArrayIndexing:argv[0]
					Identifier:argv
					Constant:0
		ReturnStatement:return argv[1];
			ArrayIndexing:argv[1]
				Identifier:argv
				Constant:1
	ReturnType:static const char *
	Identifier:if_exists_else_spec_function
	ParameterList:int argc , const char **argv
		Parameter:int argc
			ParameterType:int
			Identifier:argc
		Parameter:const char **argv
			ParameterType:const char * *
			Identifier:argv
FunctionDef:sanitize_spec_function (int argc , const char **argv)
	CompoundStatement:
		IfStatement:if (argc != 1)
			Condition:argc != 1
				EqualityExpression:argc != 1
					Identifier:argc
					Constant:1
			ReturnStatement:return NULL;
				Identifier:NULL
		IfStatement:if (strcmp (argv[0], "address") == 0)
			Condition:strcmp (argv[0], "address") == 0
				EqualityExpression:strcmp (argv[0], "address") == 0
					CallExpression:strcmp (argv[0], "address")
						Callee:strcmp
							Identifier:strcmp
						ArgumentList:argv[0]
							Argument:argv[0]
								ArrayIndexing:argv[0]
									Identifier:argv
									Constant:0
							Argument:"address"
								Constant:"address"
					Constant:0
			ReturnStatement:return (flag_sanitize & SANITIZE_USER_ADDRESS) ? "" : NULL;
				ConditionalExpression:(flag_sanitize & SANITIZE_USER_ADDRESS) ? "" : NULL
					Condition:flag_sanitize & SANITIZE_USER_ADDRESS
						BitAndExpression:flag_sanitize & SANITIZE_USER_ADDRESS
							Identifier:flag_sanitize
							Identifier:SANITIZE_USER_ADDRESS
					Constant:""
					Identifier:NULL
		IfStatement:if (strcmp (argv[0], "kernel-address") == 0)
			Condition:strcmp (argv[0], "kernel-address") == 0
				EqualityExpression:strcmp (argv[0], "kernel-address") == 0
					CallExpression:strcmp (argv[0], "kernel-address")
						Callee:strcmp
							Identifier:strcmp
						ArgumentList:argv[0]
							Argument:argv[0]
								ArrayIndexing:argv[0]
									Identifier:argv
									Constant:0
							Argument:"kernel-address"
								Constant:"kernel-address"
					Constant:0
			ReturnStatement:return (flag_sanitize & SANITIZE_KERNEL_ADDRESS) ? "" : NULL;
				ConditionalExpression:(flag_sanitize & SANITIZE_KERNEL_ADDRESS) ? "" : NULL
					Condition:flag_sanitize & SANITIZE_KERNEL_ADDRESS
						BitAndExpression:flag_sanitize & SANITIZE_KERNEL_ADDRESS
							Identifier:flag_sanitize
							Identifier:SANITIZE_KERNEL_ADDRESS
					Constant:""
					Identifier:NULL
		IfStatement:if (strcmp (argv[0], "thread") == 0)
			Condition:strcmp (argv[0], "thread") == 0
				EqualityExpression:strcmp (argv[0], "thread") == 0
					CallExpression:strcmp (argv[0], "thread")
						Callee:strcmp
							Identifier:strcmp
						ArgumentList:argv[0]
							Argument:argv[0]
								ArrayIndexing:argv[0]
									Identifier:argv
									Constant:0
							Argument:"thread"
								Constant:"thread"
					Constant:0
			ReturnStatement:return (flag_sanitize & SANITIZE_THREAD) ? "" : NULL;
				ConditionalExpression:(flag_sanitize & SANITIZE_THREAD) ? "" : NULL
					Condition:flag_sanitize & SANITIZE_THREAD
						BitAndExpression:flag_sanitize & SANITIZE_THREAD
							Identifier:flag_sanitize
							Identifier:SANITIZE_THREAD
					Constant:""
					Identifier:NULL
		IfStatement:if (strcmp (argv[0], "undefined") == 0)
			Condition:strcmp (argv[0], "undefined") == 0
				EqualityExpression:strcmp (argv[0], "undefined") == 0
					CallExpression:strcmp (argv[0], "undefined")
						Callee:strcmp
							Identifier:strcmp
						ArgumentList:argv[0]
							Argument:argv[0]
								ArrayIndexing:argv[0]
									Identifier:argv
									Constant:0
							Argument:"undefined"
								Constant:"undefined"
					Constant:0
			ReturnStatement:return ((flag_sanitize\t     & (SANITIZE_UNDEFINED | SANITIZE_UNDEFINED_NONDEFAULT))\t    && !flag_sanitize_undefined_trap_on_error) ? "" : NULL;
				ConditionalExpression:((flag_sanitize\t     & (SANITIZE_UNDEFINED | SANITIZE_UNDEFINED_NONDEFAULT))\t    && !flag_sanitize_undefined_trap_on_error) ? "" : NULL
					Condition:(flag_sanitize\t     & (SANITIZE_UNDEFINED | SANITIZE_UNDEFINED_NONDEFAULT))\t    && !flag_sanitize_undefined_trap_on_error
						AndExpression:(flag_sanitize\t     & (SANITIZE_UNDEFINED | SANITIZE_UNDEFINED_NONDEFAULT))\t    && !flag_sanitize_undefined_trap_on_error
							BitAndExpression:flag_sanitize\t     & (SANITIZE_UNDEFINED | SANITIZE_UNDEFINED_NONDEFAULT)
								Identifier:flag_sanitize
								InclusiveOrExpression:SANITIZE_UNDEFINED | SANITIZE_UNDEFINED_NONDEFAULT
									Identifier:SANITIZE_UNDEFINED
									Identifier:SANITIZE_UNDEFINED_NONDEFAULT
							UnaryOperationExpression:!flag_sanitize_undefined_trap_on_error
								UnaryOperator:!
								Identifier:flag_sanitize_undefined_trap_on_error
					Constant:""
					Identifier:NULL
		IfStatement:if (strcmp (argv[0], "leak") == 0)
			Condition:strcmp (argv[0], "leak") == 0
				EqualityExpression:strcmp (argv[0], "leak") == 0
					CallExpression:strcmp (argv[0], "leak")
						Callee:strcmp
							Identifier:strcmp
						ArgumentList:argv[0]
							Argument:argv[0]
								ArrayIndexing:argv[0]
									Identifier:argv
									Constant:0
							Argument:"leak"
								Constant:"leak"
					Constant:0
			ReturnStatement:return ((flag_sanitize\t     & (SANITIZE_ADDRESS | SANITIZE_LEAK | SANITIZE_THREAD))\t    == SANITIZE_LEAK) ? "" : NULL;
				ConditionalExpression:((flag_sanitize\t     & (SANITIZE_ADDRESS | SANITIZE_LEAK | SANITIZE_THREAD))\t    == SANITIZE_LEAK) ? "" : NULL
					Condition:(flag_sanitize\t     & (SANITIZE_ADDRESS | SANITIZE_LEAK | SANITIZE_THREAD))\t    == SANITIZE_LEAK
						EqualityExpression:(flag_sanitize\t     & (SANITIZE_ADDRESS | SANITIZE_LEAK | SANITIZE_THREAD))\t    == SANITIZE_LEAK
							BitAndExpression:flag_sanitize\t     & (SANITIZE_ADDRESS | SANITIZE_LEAK | SANITIZE_THREAD)
								Identifier:flag_sanitize
								InclusiveOrExpression:SANITIZE_ADDRESS | SANITIZE_LEAK | SANITIZE_THREAD
									Identifier:SANITIZE_ADDRESS
									InclusiveOrExpression:SANITIZE_LEAK | SANITIZE_THREAD
										Identifier:SANITIZE_LEAK
										Identifier:SANITIZE_THREAD
							Identifier:SANITIZE_LEAK
					Constant:""
					Identifier:NULL
		ReturnStatement:return NULL;
			Identifier:NULL
	ReturnType:static const char *
	Identifier:sanitize_spec_function
	ParameterList:int argc , const char **argv
		Parameter:int argc
			ParameterType:int
			Identifier:argc
		Parameter:const char **argv
			ParameterType:const char * *
			Identifier:argv
FunctionDef:replace_outfile_spec_function (int argc , const char **argv)
	CompoundStatement:
		IdentifierDeclStatement:int i;
			IdentifierDecl:i
				IdentifierDeclType:int
				Identifier:i
		Statement:/* Must have exactly two arguments.  */
		IfStatement:if (argc != 2)
			Condition:argc != 2
				EqualityExpression:argc != 2
					Identifier:argc
					Constant:2
			ExpressionStatement:abort ()
				CallExpression:abort ()
					Callee:abort
						Identifier:abort
					ArgumentList:
		ForStatement:for (i = 0; i < n_infiles; i++)
			ForInit:i = 0;
				AssignmentExpression:i = 0
					Identifier:i
					Constant:0
			Condition:i < n_infiles
				RelationalExpression:i < n_infiles
					Identifier:i
					Identifier:n_infiles
			PostIncDecOperationExpression:i++
				Identifier:i
				IncDec:++
			CompoundStatement:
				IfStatement:if (outfiles[i] && !filename_cmp (outfiles[i], argv[0]))
					Condition:outfiles[i] && !filename_cmp (outfiles[i], argv[0])
						AndExpression:outfiles[i] && !filename_cmp (outfiles[i], argv[0])
							ArrayIndexing:outfiles[i]
								Identifier:outfiles
								Identifier:i
							UnaryOperationExpression:!filename_cmp (outfiles[i], argv[0])
								UnaryOperator:!
								CallExpression:filename_cmp (outfiles[i], argv[0])
									Callee:filename_cmp
										Identifier:filename_cmp
									ArgumentList:outfiles[i]
										Argument:outfiles[i]
											ArrayIndexing:outfiles[i]
												Identifier:outfiles
												Identifier:i
										Argument:argv[0]
											ArrayIndexing:argv[0]
												Identifier:argv
												Constant:0
					ExpressionStatement:outfiles[i] = xstrdup (argv[1])
						AssignmentExpression:outfiles[i] = xstrdup (argv[1])
							ArrayIndexing:outfiles[i]
								Identifier:outfiles
								Identifier:i
							CallExpression:xstrdup (argv[1])
								Callee:xstrdup
									Identifier:xstrdup
								ArgumentList:argv[1]
									Argument:argv[1]
										ArrayIndexing:argv[1]
											Identifier:argv
											Constant:1
		ReturnStatement:return NULL;
			Identifier:NULL
	ReturnType:static const char *
	Identifier:replace_outfile_spec_function
	ParameterList:int argc , const char **argv
		Parameter:int argc
			ParameterType:int
			Identifier:argc
		Parameter:const char **argv
			ParameterType:const char * *
			Identifier:argv
FunctionDef:remove_outfile_spec_function (int argc , const char **argv)
	CompoundStatement:
		IdentifierDeclStatement:int i;
			IdentifierDecl:i
				IdentifierDeclType:int
				Identifier:i
		Statement:/* Must have exactly one argument.  */
		IfStatement:if (argc != 1)
			Condition:argc != 1
				EqualityExpression:argc != 1
					Identifier:argc
					Constant:1
			ExpressionStatement:abort ()
				CallExpression:abort ()
					Callee:abort
						Identifier:abort
					ArgumentList:
		ForStatement:for (i = 0; i < n_infiles; i++)
			ForInit:i = 0;
				AssignmentExpression:i = 0
					Identifier:i
					Constant:0
			Condition:i < n_infiles
				RelationalExpression:i < n_infiles
					Identifier:i
					Identifier:n_infiles
			PostIncDecOperationExpression:i++
				Identifier:i
				IncDec:++
			CompoundStatement:
				IfStatement:if (outfiles[i] && !filename_cmp (outfiles[i], argv[0]))
					Condition:outfiles[i] && !filename_cmp (outfiles[i], argv[0])
						AndExpression:outfiles[i] && !filename_cmp (outfiles[i], argv[0])
							ArrayIndexing:outfiles[i]
								Identifier:outfiles
								Identifier:i
							UnaryOperationExpression:!filename_cmp (outfiles[i], argv[0])
								UnaryOperator:!
								CallExpression:filename_cmp (outfiles[i], argv[0])
									Callee:filename_cmp
										Identifier:filename_cmp
									ArgumentList:outfiles[i]
										Argument:outfiles[i]
											ArrayIndexing:outfiles[i]
												Identifier:outfiles
												Identifier:i
										Argument:argv[0]
											ArrayIndexing:argv[0]
												Identifier:argv
												Constant:0
					ExpressionStatement:outfiles[i] = NULL
						AssignmentExpression:outfiles[i] = NULL
							ArrayIndexing:outfiles[i]
								Identifier:outfiles
								Identifier:i
							Identifier:NULL
		ReturnStatement:return NULL;
			Identifier:NULL
	ReturnType:static const char *
	Identifier:remove_outfile_spec_function
	ParameterList:int argc , const char **argv
		Parameter:int argc
			ParameterType:int
			Identifier:argc
		Parameter:const char **argv
			ParameterType:const char * *
			Identifier:argv
FunctionDef:intcompare_version_strings (const char *v1 , const char *v2)
	CompoundStatement:
		IdentifierDeclStatement:int rresult;
			IdentifierDecl:rresult
				IdentifierDeclType:int
				Identifier:rresult
		IdentifierDeclStatement:regex_t r;
			IdentifierDecl:r
				IdentifierDeclType:regex_t
				Identifier:r
		IfStatement:if (regcomp (&r, "^([1-9][0-9]*|0)(\\.([1-9][0-9]*|0))*$",\t       REG_EXTENDED | REG_NOSUB) != 0)
			Condition:regcomp (&r, "^([1-9][0-9]*|0)(\\.([1-9][0-9]*|0))*$",\t       REG_EXTENDED | REG_NOSUB) != 0
				EqualityExpression:regcomp (&r, "^([1-9][0-9]*|0)(\\.([1-9][0-9]*|0))*$",\t       REG_EXTENDED | REG_NOSUB) != 0
					CallExpression:regcomp (&r, "^([1-9][0-9]*|0)(\\.([1-9][0-9]*|0))*$",\t       REG_EXTENDED | REG_NOSUB)
						Callee:regcomp
							Identifier:regcomp
						ArgumentList:&r
							Argument:&r
								UnaryOperationExpression:&r
									UnaryOperator:&
									Identifier:r
							Argument:"^([1-9][0-9]*|0)(\\.([1-9][0-9]*|0))*$"
								Constant:"^([1-9][0-9]*|0)(\\.([1-9][0-9]*|0))*$"
							Argument:REG_EXTENDED | REG_NOSUB
								InclusiveOrExpression:REG_EXTENDED | REG_NOSUB
									Identifier:REG_EXTENDED
									Identifier:REG_NOSUB
					Constant:0
			ExpressionStatement:abort ()
				CallExpression:abort ()
					Callee:abort
						Identifier:abort
					ArgumentList:
		ExpressionStatement:rresult = regexec (&r, v1, 0, NULL, 0)
			AssignmentExpression:rresult = regexec (&r, v1, 0, NULL, 0)
				Identifier:rresult
				CallExpression:regexec (&r, v1, 0, NULL, 0)
					Callee:regexec
						Identifier:regexec
					ArgumentList:&r
						Argument:&r
							UnaryOperationExpression:&r
								UnaryOperator:&
								Identifier:r
						Argument:v1
							Identifier:v1
						Argument:0
							Constant:0
						Argument:NULL
							Identifier:NULL
						Argument:0
							Constant:0
		IfStatement:if (rresult == REG_NOMATCH)
			Condition:rresult == REG_NOMATCH
				EqualityExpression:rresult == REG_NOMATCH
					Identifier:rresult
					Identifier:REG_NOMATCH
			ExpressionStatement:fatal_error (input_location, "invalid version number %qs", v1)
				CallExpression:fatal_error (input_location, "invalid version number %qs", v1)
					Callee:fatal_error
						Identifier:fatal_error
					ArgumentList:input_location
						Argument:input_location
							Identifier:input_location
						Argument:"invalid version number %qs"
							Constant:"invalid version number %qs"
						Argument:v1
							Identifier:v1
		ExpressionStatement:rresult = regexec (&r, v2, 0, NULL, 0)
			AssignmentExpression:rresult = regexec (&r, v2, 0, NULL, 0)
				Identifier:rresult
				CallExpression:regexec (&r, v2, 0, NULL, 0)
					Callee:regexec
						Identifier:regexec
					ArgumentList:&r
						Argument:&r
							UnaryOperationExpression:&r
								UnaryOperator:&
								Identifier:r
						Argument:v2
							Identifier:v2
						Argument:0
							Constant:0
						Argument:NULL
							Identifier:NULL
						Argument:0
							Constant:0
		IfStatement:if (rresult == REG_NOMATCH)
			Condition:rresult == REG_NOMATCH
				EqualityExpression:rresult == REG_NOMATCH
					Identifier:rresult
					Identifier:REG_NOMATCH
			ExpressionStatement:fatal_error (input_location, "invalid version number %qs", v2)
				CallExpression:fatal_error (input_location, "invalid version number %qs", v2)
					Callee:fatal_error
						Identifier:fatal_error
					ArgumentList:input_location
						Argument:input_location
							Identifier:input_location
						Argument:"invalid version number %qs"
							Constant:"invalid version number %qs"
						Argument:v2
							Identifier:v2
		ReturnStatement:return strverscmp (v1, v2);
			CallExpression:strverscmp (v1, v2)
				Callee:strverscmp
					Identifier:strverscmp
				ArgumentList:v1
					Argument:v1
						Identifier:v1
					Argument:v2
						Identifier:v2
	Identifier:intcompare_version_strings
	ParameterList:const char *v1 , const char *v2
		Parameter:const char *v1
			ParameterType:const char *
			Identifier:v1
		Parameter:const char *v2
			ParameterType:const char *
			Identifier:v2
FunctionDef:version_compare_spec_function (int argc , const char **argv)
	CompoundStatement:
		IdentifierDeclStatement:int comp1, comp2;
			IdentifierDecl:comp1
				IdentifierDeclType:int
				Identifier:comp1
			IdentifierDecl:comp2
				IdentifierDeclType:int
				Identifier:comp2
		IdentifierDeclStatement:size_t switch_len;
			IdentifierDecl:switch_len
				IdentifierDeclType:size_t
				Identifier:switch_len
		IdentifierDeclStatement:const char *switch_value = NULL;
			IdentifierDecl:*switch_value = NULL
				IdentifierDeclType:const char *
				Identifier:switch_value
				AssignmentExpression:*switch_value = NULL
					Identifier:switch_value
					Identifier:NULL
		IdentifierDeclStatement:int nargs = 1, i;
			IdentifierDecl:nargs = 1
				IdentifierDeclType:int
				Identifier:nargs
				AssignmentExpression:nargs = 1
					Identifier:nargs
					Constant:1
			IdentifierDecl:i
				IdentifierDeclType:int
				Identifier:i
		IdentifierDeclStatement:bool result;
			IdentifierDecl:result
				IdentifierDeclType:bool
				Identifier:result
		IfStatement:if (argc < 3)
			Condition:argc < 3
				RelationalExpression:argc < 3
					Identifier:argc
					Constant:3
			ExpressionStatement:fatal_error (input_location, "too few arguments to %%:version-compare")
				CallExpression:fatal_error (input_location, "too few arguments to %%:version-compare")
					Callee:fatal_error
						Identifier:fatal_error
					ArgumentList:input_location
						Argument:input_location
							Identifier:input_location
						Argument:"too few arguments to %%:version-compare"
							Constant:"too few arguments to %%:version-compare"
		IfStatement:if (argv[0][0] == '\0')
			Condition:argv[0][0] == '\0'
				EqualityExpression:argv[0][0] == '\0'
					ArrayIndexing:argv[0][0]
						ArrayIndexing:argv[0]
							Identifier:argv
							Constant:0
						Constant:0
					Constant:'\0'
			ExpressionStatement:abort ()
				CallExpression:abort ()
					Callee:abort
						Identifier:abort
					ArgumentList:
		IfStatement:if ((argv[0][1] == '<' || argv[0][1] == '>') && argv[0][0] != '!')
			Condition:(argv[0][1] == '<' || argv[0][1] == '>') && argv[0][0] != '!'
				AndExpression:(argv[0][1] == '<' || argv[0][1] == '>') && argv[0][0] != '!'
					OrExpression:argv[0][1] == '<' || argv[0][1] == '>'
						EqualityExpression:argv[0][1] == '<'
							ArrayIndexing:argv[0][1]
								ArrayIndexing:argv[0]
									Identifier:argv
									Constant:0
								Constant:1
							Constant:'<'
						EqualityExpression:argv[0][1] == '>'
							ArrayIndexing:argv[0][1]
								ArrayIndexing:argv[0]
									Identifier:argv
									Constant:0
								Constant:1
							Constant:'>'
					EqualityExpression:argv[0][0] != '!'
						ArrayIndexing:argv[0][0]
							ArrayIndexing:argv[0]
								Identifier:argv
								Constant:0
							Constant:0
						Constant:'!'
			ExpressionStatement:nargs = 2
				AssignmentExpression:nargs = 2
					Identifier:nargs
					Constant:2
		IfStatement:if (argc != nargs + 3)
			Condition:argc != nargs + 3
				EqualityExpression:argc != nargs + 3
					Identifier:argc
					AdditiveExpression:nargs + 3
						Identifier:nargs
						Constant:3
			ExpressionStatement:fatal_error (input_location, "too many arguments to %%:version-compare")
				CallExpression:fatal_error (input_location, "too many arguments to %%:version-compare")
					Callee:fatal_error
						Identifier:fatal_error
					ArgumentList:input_location
						Argument:input_location
							Identifier:input_location
						Argument:"too many arguments to %%:version-compare"
							Constant:"too many arguments to %%:version-compare"
		ExpressionStatement:switch_len = strlen (argv[nargs + 1])
			AssignmentExpression:switch_len = strlen (argv[nargs + 1])
				Identifier:switch_len
				CallExpression:strlen (argv[nargs + 1])
					Callee:strlen
						Identifier:strlen
					ArgumentList:argv[nargs + 1]
						Argument:argv[nargs + 1]
							ArrayIndexing:argv[nargs + 1]
								Identifier:argv
								AdditiveExpression:nargs + 1
									Identifier:nargs
									Constant:1
		ForStatement:for (i = 0; i < n_switches; i++)
			ForInit:i = 0;
				AssignmentExpression:i = 0
					Identifier:i
					Constant:0
			Condition:i < n_switches
				RelationalExpression:i < n_switches
					Identifier:i
					Identifier:n_switches
			PostIncDecOperationExpression:i++
				Identifier:i
				IncDec:++
			IfStatement:if (!strncmp (switches[i].part1, argv[nargs + 1], switch_len)\t&& check_live_switch (i, switch_len))
				Condition:!strncmp (switches[i].part1, argv[nargs + 1], switch_len)\t&& check_live_switch (i, switch_len)
					AndExpression:!strncmp (switches[i].part1, argv[nargs + 1], switch_len)\t&& check_live_switch (i, switch_len)
						UnaryOperationExpression:!strncmp (switches[i].part1, argv[nargs + 1], switch_len)
							UnaryOperator:!
							CallExpression:strncmp (switches[i].part1, argv[nargs + 1], switch_len)
								Callee:strncmp
									Identifier:strncmp
								ArgumentList:switches[i].part1
									Argument:switches[i].part1
										MemberAccess:switches[i].part1
											ArrayIndexing:switches[i]
												Identifier:switches
												Identifier:i
											Identifier:part1
									Argument:argv[nargs + 1]
										ArrayIndexing:argv[nargs + 1]
											Identifier:argv
											AdditiveExpression:nargs + 1
												Identifier:nargs
												Constant:1
									Argument:switch_len
										Identifier:switch_len
						CallExpression:check_live_switch (i, switch_len)
							Callee:check_live_switch
								Identifier:check_live_switch
							ArgumentList:i
								Argument:i
									Identifier:i
								Argument:switch_len
									Identifier:switch_len
				ExpressionStatement:switch_value = switches[i].part1 + switch_len
					AssignmentExpression:switch_value = switches[i].part1 + switch_len
						Identifier:switch_value
						AdditiveExpression:switches[i].part1 + switch_len
							MemberAccess:switches[i].part1
								ArrayIndexing:switches[i]
									Identifier:switches
									Identifier:i
								Identifier:part1
							Identifier:switch_len
		IfStatement:if (switch_value == NULL)
			Condition:switch_value == NULL
				EqualityExpression:switch_value == NULL
					Identifier:switch_value
					Identifier:NULL
			ExpressionStatement:comp1 = comp2 = -1
				AssignmentExpression:comp1 = comp2 = -1
					Identifier:comp1
					AssignmentExpression:comp2 = -1
						Identifier:comp2
						UnaryOperationExpression:-1
							UnaryOperator:-
							Constant:1
		SwitchStatement:switch (argv[0][0] << 8 | argv[0][1])
			Condition:argv[0][0] << 8 | argv[0][1]
				InclusiveOrExpression:argv[0][0] << 8 | argv[0][1]
					ShiftExpression:argv[0][0] << 8
						ArrayIndexing:argv[0][0]
							ArrayIndexing:argv[0]
								Identifier:argv
								Constant:0
							Constant:0
						Constant:8
					ArrayIndexing:argv[0][1]
						ArrayIndexing:argv[0]
							Identifier:argv
							Constant:0
						Constant:1
			CompoundStatement:
				Statement:case
				Statement:'>'
				Statement:<<
				Statement:8
				Statement:|
				Label:'=':
				ExpressionStatement:result = comp1 >= 0
					AssignmentExpression:result = comp1 >= 0
						Identifier:result
						RelationalExpression:comp1 >= 0
							Identifier:comp1
							Constant:0
				BreakStatement:break;
				Statement:case
				Statement:'!'
				Statement:<<
				Statement:8
				Statement:|
				Label:'<':
				ExpressionStatement:result = comp1 >= 0 || switch_value == NULL
					AssignmentExpression:result = comp1 >= 0 || switch_value == NULL
						Identifier:result
						OrExpression:comp1 >= 0 || switch_value == NULL
							RelationalExpression:comp1 >= 0
								Identifier:comp1
								Constant:0
							EqualityExpression:switch_value == NULL
								Identifier:switch_value
								Identifier:NULL
				BreakStatement:break;
				Statement:case
				Statement:'<'
				Statement:<<
				Label:8:
				ExpressionStatement:result = comp1 < 0
					AssignmentExpression:result = comp1 < 0
						Identifier:result
						RelationalExpression:comp1 < 0
							Identifier:comp1
							Constant:0
				BreakStatement:break;
				Statement:case
				Statement:'!'
				Statement:<<
				Statement:8
				Statement:|
				Label:'>':
				ExpressionStatement:result = comp1 < 0 || switch_value == NULL
					AssignmentExpression:result = comp1 < 0 || switch_value == NULL
						Identifier:result
						OrExpression:comp1 < 0 || switch_value == NULL
							RelationalExpression:comp1 < 0
								Identifier:comp1
								Constant:0
							EqualityExpression:switch_value == NULL
								Identifier:switch_value
								Identifier:NULL
				BreakStatement:break;
				Statement:case
				Statement:'>'
				Statement:<<
				Statement:8
				Statement:|
				Label:'<':
				ExpressionStatement:result = comp1 >= 0 && comp2 < 0
					AssignmentExpression:result = comp1 >= 0 && comp2 < 0
						Identifier:result
						AndExpression:comp1 >= 0 && comp2 < 0
							RelationalExpression:comp1 >= 0
								Identifier:comp1
								Constant:0
							RelationalExpression:comp2 < 0
								Identifier:comp2
								Constant:0
				BreakStatement:break;
				Statement:case
				Statement:'<'
				Statement:<<
				Statement:8
				Statement:|
				Label:'>':
				ExpressionStatement:result = comp1 < 0 || comp2 >= 0
					AssignmentExpression:result = comp1 < 0 || comp2 >= 0
						Identifier:result
						OrExpression:comp1 < 0 || comp2 >= 0
							RelationalExpression:comp1 < 0
								Identifier:comp1
								Constant:0
							RelationalExpression:comp2 >= 0
								Identifier:comp2
								Constant:0
				BreakStatement:break;
				Label:default:
					Identifier:default
				ExpressionStatement:fatal_error (input_location,\t\t   "unknown operator %qs in %%:version-compare", argv[0])
					CallExpression:fatal_error (input_location,\t\t   "unknown operator %qs in %%:version-compare", argv[0])
						Callee:fatal_error
							Identifier:fatal_error
						ArgumentList:input_location
							Argument:input_location
								Identifier:input_location
							Argument:"unknown operator %qs in %%:version-compare"
								Constant:"unknown operator %qs in %%:version-compare"
							Argument:argv[0]
								ArrayIndexing:argv[0]
									Identifier:argv
									Constant:0
		IfStatement:if (! result)
			Condition:! result
				UnaryOperationExpression:! result
					UnaryOperator:!
					Identifier:result
			ReturnStatement:return NULL;
				Identifier:NULL
		ReturnStatement:return argv[nargs + 2];
			ArrayIndexing:argv[nargs + 2]
				Identifier:argv
				AdditiveExpression:nargs + 2
					Identifier:nargs
					Constant:2
	ReturnType:static const char *
	Identifier:version_compare_spec_function
	ParameterList:int argc , const char **argv
		Parameter:int argc
			ParameterType:int
			Identifier:argc
		Parameter:const char **argv
			ParameterType:const char * *
			Identifier:argv
FunctionDef:include_spec_function (int argc , const char **argv)
	CompoundStatement:
		IdentifierDeclStatement:char *file;
			IdentifierDecl:*file
				IdentifierDeclType:char *
				Identifier:file
		IfStatement:if (argc != 1)
			Condition:argc != 1
				EqualityExpression:argc != 1
					Identifier:argc
					Constant:1
			ExpressionStatement:abort ()
				CallExpression:abort ()
					Callee:abort
						Identifier:abort
					ArgumentList:
		ExpressionStatement:file = find_a_file (&startfile_prefixes, argv[0], R_OK, true)
			AssignmentExpression:file = find_a_file (&startfile_prefixes, argv[0], R_OK, true)
				Identifier:file
				CallExpression:find_a_file (&startfile_prefixes, argv[0], R_OK, true)
					Callee:find_a_file
						Identifier:find_a_file
					ArgumentList:&startfile_prefixes
						Argument:&startfile_prefixes
							UnaryOperationExpression:&startfile_prefixes
								UnaryOperator:&
								Identifier:startfile_prefixes
						Argument:argv[0]
							ArrayIndexing:argv[0]
								Identifier:argv
								Constant:0
						Argument:R_OK
							Identifier:R_OK
						Argument:true
							Identifier:true
		ExpressionStatement:read_specs (file ? file : argv[0], false, false)
			CallExpression:read_specs (file ? file : argv[0], false, false)
				Callee:read_specs
					Identifier:read_specs
				ArgumentList:file ? file : argv[0]
					Argument:file ? file : argv[0]
						ConditionalExpression:file ? file : argv[0]
							Condition:file
								Identifier:file
							Identifier:file
							ArrayIndexing:argv[0]
								Identifier:argv
								Constant:0
					Argument:false
						Identifier:false
					Argument:false
						Identifier:false
		ReturnStatement:return NULL;
			Identifier:NULL
	ReturnType:static const char *
	Identifier:include_spec_function
	ParameterList:int argc , const char **argv
		Parameter:int argc
			ParameterType:int
			Identifier:argc
		Parameter:const char **argv
			ParameterType:const char * *
			Identifier:argv
FunctionDef:find_file_spec_function (int argc , const char **argv)
	CompoundStatement:
		IdentifierDeclStatement:const char *file;
			IdentifierDecl:*file
				IdentifierDeclType:const char *
				Identifier:file
		IfStatement:if (argc != 1)
			Condition:argc != 1
				EqualityExpression:argc != 1
					Identifier:argc
					Constant:1
			ExpressionStatement:abort ()
				CallExpression:abort ()
					Callee:abort
						Identifier:abort
					ArgumentList:
		ExpressionStatement:file = find_file (argv[0])
			AssignmentExpression:file = find_file (argv[0])
				Identifier:file
				CallExpression:find_file (argv[0])
					Callee:find_file
						Identifier:find_file
					ArgumentList:argv[0]
						Argument:argv[0]
							ArrayIndexing:argv[0]
								Identifier:argv
								Constant:0
		ReturnStatement:return file;
			Identifier:file
	ReturnType:static const char *
	Identifier:find_file_spec_function
	ParameterList:int argc , const char **argv
		Parameter:int argc
			ParameterType:int
			Identifier:argc
		Parameter:const char **argv
			ParameterType:const char * *
			Identifier:argv
IdentifierDeclStatement:null
	IdentifierDecl:*option
		IdentifierDeclType:const char *
		Identifier:option
FunctionDef:HOST_WIDE_INTget_random_number ()
	CompoundStatement:
		IdentifierDeclStatement:unsigned HOST_WIDE_INT ret = 0;
			IdentifierDecl:ret = 0
				IdentifierDeclType:unsigned HOST_WIDE_INT
				Identifier:ret
				AssignmentExpression:ret = 0
					Identifier:ret
					Constant:0
		IdentifierDeclStatement:int fd;
			IdentifierDecl:fd
				IdentifierDeclType:int
				Identifier:fd
		ExpressionStatement:fd = open ("/dev/urandom", O_RDONLY)
			AssignmentExpression:fd = open ("/dev/urandom", O_RDONLY)
				Identifier:fd
				CallExpression:open ("/dev/urandom", O_RDONLY)
					Callee:open
						Identifier:open
					ArgumentList:"/dev/urandom"
						Argument:"/dev/urandom"
							Constant:"/dev/urandom"
						Argument:O_RDONLY
							Identifier:O_RDONLY
		IfStatement:if (fd >= 0)
			Condition:fd >= 0
				RelationalExpression:fd >= 0
					Identifier:fd
					Constant:0
			CompoundStatement:
				ExpressionStatement:read (fd, &ret, sizeof (HOST_WIDE_INT))
					CallExpression:read (fd, &ret, sizeof (HOST_WIDE_INT))
						Callee:read
							Identifier:read
						ArgumentList:fd
							Argument:fd
								Identifier:fd
							Argument:&ret
								UnaryOperationExpression:&ret
									UnaryOperator:&
									Identifier:ret
							Argument:sizeof (HOST_WIDE_INT)
								SizeofExpression:sizeof (HOST_WIDE_INT)
									Sizeof:sizeof
									Identifier:HOST_WIDE_INT
				ExpressionStatement:close (fd)
					CallExpression:close (fd)
						Callee:close
							Identifier:close
						ArgumentList:fd
							Argument:fd
								Identifier:fd
				IfStatement:if (ret)
					Condition:ret
						Identifier:ret
					ReturnStatement:return ret;
						Identifier:ret
		Statement:/* Get some more or less random data.  */
		Statement:ifdef
		Statement:HAVE_GETTIMEOFDAY
		CompoundStatement:
			IdentifierDeclStatement:struct timeval tv;
				IdentifierDecl:tv
					IdentifierDeclType:struct timeval
					Identifier:tv
			ExpressionStatement:gettimeofday (&tv, NULL)
				CallExpression:gettimeofday (&tv, NULL)
					Callee:gettimeofday
						Identifier:gettimeofday
					ArgumentList:&tv
						Argument:&tv
							UnaryOperationExpression:&tv
								UnaryOperator:&
								Identifier:tv
						Argument:NULL
							Identifier:NULL
			ExpressionStatement:ret = tv.tv_sec * 1000 + tv.tv_usec / 1000
				AssignmentExpression:ret = tv.tv_sec * 1000 + tv.tv_usec / 1000
					Identifier:ret
					AdditiveExpression:tv.tv_sec * 1000 + tv.tv_usec / 1000
						MultiplicativeExpression:tv.tv_sec * 1000
							MemberAccess:tv.tv_sec
								Identifier:tv
								Identifier:tv_sec
							Constant:1000
						MultiplicativeExpression:tv.tv_usec / 1000
							MemberAccess:tv.tv_usec
								Identifier:tv
								Identifier:tv_usec
							Constant:1000
		Statement:endif
		ReturnStatement:return ret ^ getpid ();
			ExclusiveOrExpression:ret ^ getpid ()
				Identifier:ret
				CallExpression:getpid ()
					Callee:getpid
						Identifier:getpid
					ArgumentList:
	ReturnType:static unsigned
	Identifier:HOST_WIDE_INTget_random_number
	ParameterList:
IdentifierDeclStatement:null
	IdentifierDecl:*ret
		IdentifierDeclType:char *
		Identifier:ret
IdentifierDeclStatement:null
	IdentifierDecl:*name
		IdentifierDeclType:char *
		Identifier:name
IdentifierDeclStatement:null
	IdentifierDecl:which
		IdentifierDeclType:int
		Identifier:which
IdentifierDeclStatement:null
	IdentifierDecl:random_seed[HOST_BITS_PER_WIDE_INT / 4 + 3]
		IdentifierDeclType:char [ HOST_BITS_PER_WIDE_INT / 4 + 3 ]
		Identifier:random_seed
IdentifierDeclStatement:null
	IdentifierDecl:*ext
		IdentifierDeclType:const char *
		Identifier:ext
IdentifierDeclStatement:null
	IdentifierDecl:value
		IdentifierDeclType:unsigned HOST_WIDE_INT
		Identifier:value
IdentifierDeclStatement:null
	IdentifierDecl:*tmp
		IdentifierDeclType:char *
		Identifier:tmp
IdentifierDeclStatement:null
	IdentifierDecl:*debug_auxbase_opt
		IdentifierDeclType:const char *
		Identifier:debug_auxbase_opt
FunctionDef:voiddriver_get_configure_time_options (void (*cb) (const char *option,\t\t\t\t\t       void *user_data) , void *user_data)
	CompoundStatement:
		IdentifierDeclStatement:size_t i;
			IdentifierDecl:i
				IdentifierDeclType:size_t
				Identifier:i
		ExpressionStatement:obstack_init (&obstack)
			CallExpression:obstack_init (&obstack)
				Callee:obstack_init
					Identifier:obstack_init
				ArgumentList:&obstack
					Argument:&obstack
						UnaryOperationExpression:&obstack
							UnaryOperator:&
							Identifier:obstack
		ExpressionStatement:init_opts_obstack ()
			CallExpression:init_opts_obstack ()
				Callee:init_opts_obstack
					Identifier:init_opts_obstack
				ArgumentList:
		ExpressionStatement:n_switches = 0
			AssignmentExpression:n_switches = 0
				Identifier:n_switches
				Constant:0
		ForStatement:for (i = 0; i < ARRAY_SIZE (option_default_specs); i++)
			ForInit:i = 0;
				AssignmentExpression:i = 0
					Identifier:i
					Constant:0
			Condition:i < ARRAY_SIZE (option_default_specs)
				RelationalExpression:i < ARRAY_SIZE (option_default_specs)
					Identifier:i
					CallExpression:ARRAY_SIZE (option_default_specs)
						Callee:ARRAY_SIZE
							Identifier:ARRAY_SIZE
						ArgumentList:option_default_specs
							Argument:option_default_specs
								Identifier:option_default_specs
			PostIncDecOperationExpression:i++
				Identifier:i
				IncDec:++
			ExpressionStatement:do_option_spec (option_default_specs[i].name,\t\t    option_default_specs[i].spec)
				CallExpression:do_option_spec (option_default_specs[i].name,\t\t    option_default_specs[i].spec)
					Callee:do_option_spec
						Identifier:do_option_spec
					ArgumentList:option_default_specs[i].name
						Argument:option_default_specs[i].name
							MemberAccess:option_default_specs[i].name
								ArrayIndexing:option_default_specs[i]
									Identifier:option_default_specs
									Identifier:i
								Identifier:name
						Argument:option_default_specs[i].spec
							MemberAccess:option_default_specs[i].spec
								ArrayIndexing:option_default_specs[i]
									Identifier:option_default_specs
									Identifier:i
								Identifier:spec
		ForStatement:for (i = 0; (int) i < n_switches; i++)
			ForInit:i = 0;
				AssignmentExpression:i = 0
					Identifier:i
					Constant:0
			Condition:(int) i < n_switches
				RelationalExpression:(int) i < n_switches
					CastExpression:(int) i
						CastTarget:int
						Identifier:i
					Identifier:n_switches
			PostIncDecOperationExpression:i++
				Identifier:i
				IncDec:++
			CompoundStatement:
				ExpressionStatement:gcc_assert (switches[i].part1)
					CallExpression:gcc_assert (switches[i].part1)
						Callee:gcc_assert
							Identifier:gcc_assert
						ArgumentList:switches[i].part1
							Argument:switches[i].part1
								MemberAccess:switches[i].part1
									ArrayIndexing:switches[i]
										Identifier:switches
										Identifier:i
									Identifier:part1
				ExpressionStatement:(*cb) (switches[i].part1, user_data)
					CallExpression:(*cb) (switches[i].part1, user_data)
						Callee:*cb
							UnaryOperationExpression:*cb
								UnaryOperator:*
								Identifier:cb
						ArgumentList:switches[i].part1
							Argument:switches[i].part1
								MemberAccess:switches[i].part1
									ArrayIndexing:switches[i]
										Identifier:switches
										Identifier:i
									Identifier:part1
							Argument:user_data
								Identifier:user_data
		ExpressionStatement:obstack_free (&opts_obstack, NULL)
			CallExpression:obstack_free (&opts_obstack, NULL)
				Callee:obstack_free
					Identifier:obstack_free
				ArgumentList:&opts_obstack
					Argument:&opts_obstack
						UnaryOperationExpression:&opts_obstack
							UnaryOperator:&
							Identifier:opts_obstack
					Argument:NULL
						Identifier:NULL
		ExpressionStatement:obstack_free (&obstack, NULL)
			CallExpression:obstack_free (&obstack, NULL)
				Callee:obstack_free
					Identifier:obstack_free
				ArgumentList:&obstack
					Argument:&obstack
						UnaryOperationExpression:&obstack
							UnaryOperator:&
							Identifier:obstack
					Argument:NULL
						Identifier:NULL
		ExpressionStatement:n_switches = 0
			AssignmentExpression:n_switches = 0
				Identifier:n_switches
				Constant:0
	Identifier:voiddriver_get_configure_time_options
	ParameterList:void (*cb) (const char *option,\t\t\t\t\t       void *user_data) , void *user_data
		Parameter:void (*cb) (const char *option,\t\t\t\t\t       void *user_data)
			ParameterType:(( const char * option , void * user_data ) void) *
			Identifier:cb
		Parameter:void *user_data
			ParameterType:void *
			Identifier:user_data
